{"version":3,"sources":["../node_modules/ergo-lib-wasm-browser/ergo_lib_wasm.js","../node_modules/ergo-lib-wasm-browser/ergo_lib_wasm_bg.js","../node_modules/webpack/buildin/harmony-module.js"],"names":["heap","Array","fill","undefined","getObject","idx","push","heap_next","length","takeObject","ret","dropObject","cachedTextDecoder","TextDecoder","module","require","ignoreBOM","fatal","decode","cachegetUint8Memory0","getUint8Memory0","buffer","wasm","Uint8Array","getStringFromWasm0","ptr","len","subarray","addHeapObject","obj","WASM_VECTOR_LEN","cachedTextEncoder","TextEncoder","encodeString","encodeInto","arg","view","buf","encode","set","read","written","passStringToWasm0","malloc","realloc","mem","offset","code","charCodeAt","slice","cachegetInt32Memory0","getInt32Memory0","Int32Array","debugString","val","type","description","name","isArray","debug","i","className","builtInMatches","exec","toString","call","JSON","stringify","_","Error","message","stack","__wbg_adapter_34","arg0","arg1","arg2","getArrayU8FromWasm0","_assertClass","instance","klass","passArray8ToWasm0","cachegetUint32Memory0","getUint32Memory0","Uint32Array","passArray32ToWasm0","passArrayJsValueToWasm0","array","getArrayJsValueFromWasm0","result","base16_decode","data","retptr","ptr0","len0","r0","r1","v1","get_info","node","NodeConf","handleError","f","args","apply","this","e","NonMandatoryRegisterId","Object","freeze","R4","R5","R6","R7","R8","R9","NetworkPrefix","Mainnet","Testnet","AddressTypePrefix","P2Pk","Pay2Sh","Pay2S","Address","__destroy_into_raw","network_prefix","v0","ErgoTree","__wrap","create","prototype","ergo_tree","bytes","s","BlockHeader","json","BlockHeaders","b","json_vals","index","BoxId","box_id_str","BoxSelection","boxes","change","ErgoBoxes","ErgoBoxAssetsDataList","BoxValue","I64","v","Constant","ErgoBox","base16_bytes_str","num","arr","bytes1","bytes2","ptr1","len1","l1","l2","ContextExtension","id","value","key","Contract","recipient","source","DataInput","box_id","DataInputs","elem","DerivationPath","acc","address_indices","path","creation_height","contract","tx_id","tokens","TxId","Tokens","register_id","ErgoBoxAssetsData","ErgoBoxCandidate","fee_amount","ErgoBoxCandidateBuilder","new_min_value_per_byte","new_value","token","token_name","token_desc","num_decimals","Token","token_id","amount","TokenId","TokenAmount","ErgoBoxCandidates","box_candidate","ErgoStateContext","pre_header","headers","PreHeader","constant","ExtPubKey","public_key_bytes","chain_code","derivation_path","ExtSecretKey","secret_key_bytes","seed_bytes","other","string","Input","ProverResult","Inputs","LevelNode","hash","side","MerkleProof","level","expected_root","leaf_data","MinerAddress","Mnemonic","mnemonic_phrase","mnemonic_pass","v2","NetworkAddress","network","address","addr","block_header","ReducedTransaction","UnsignedTransaction","unsigned_tx","boxes_to_spend","data_boxes","state_context","SecretKey","SecretKeys","SimpleBoxSelector","inputs","target_balance","target_tokens","str","Transaction","proofs","TxBuilder","data_inputs","box_selection","output_candidates","current_height","change_address","min_change_value","UnsignedInput","ext","UnsignedInputs","input_id","Wallet","secret","_state_context","tx","reduced_tx","__wbindgen_object_drop_ref","__wbindgen_string_new","__wbindgen_is_string","__wbindgen_string_get","x","__wbindgen_json_parse","parse","__wbindgen_json_serialize","__wbindgen_number_new","__wbindgen_object_clone_ref","__wbg_fetch_fb26f738d9707b16","fetch","__wbindgen_cb_drop","original","cnt","a","__wbg_fetch_b4e81012e07ff95a","__wbg_new_9c35e8e8b09fb4a3","Headers","arguments","__wbg_append_fb85316567f7a798","arg3","arg4","append","__wbg_instanceof_Response_e1b11afbefa5b563","Response","__wbg_url_50e0bdb6051741be","url","__wbg_status_6d8bb444ddc5a7b2","status","__wbg_headers_5ffa990806e04cfc","__wbg_arrayBuffer_b8937ed04beb0d36","arrayBuffer","__wbg_newwithstrandinit_9b0fa00478c37287","Request","__wbg_getRandomValues_98117e9a7e993920","getRandomValues","__wbg_randomFillSync_64cc7d048f228ca8","randomFillSync","__wbg_process_2f24d6544ea7b200","process","__wbindgen_is_object","__wbg_versions_6164651e75405d4a","versions","__wbg_node_4b517d861cbcb3bc","__wbg_modulerequire_3440a4bcf44437db","__wbg_crypto_98fc271021c7d2ad","crypto","__wbg_msCrypto_a2cdb043d2bfe57f","msCrypto","__wbindgen_is_function","__wbg_newnoargs_be86524d73f67598","Function","__wbg_next_c4151d46d5fa7097","next","__wbg_next_7720502039b96d00","__wbg_done_b06cf0578e89ff68","done","__wbg_value_e74a542443d92451","__wbg_iterator_4fc4ce93e6b92958","Symbol","iterator","__wbg_get_4d0f21c2f823742e","Reflect","get","__wbg_call_888d259a5fefc347","__wbg_new_0b83d3df67ecb33e","__wbg_new_342a24ca698edd87","__wbg_call_346669c262382ad7","__wbg_new_b1d61b5687f5e73a","state0","Promise","__wbg_adapter_347","__wbg_resolve_d23068002f584f22","resolve","__wbg_then_2fcac196782070cc","then","__wbg_then_8c2d62e8ae5978f7","__wbg_self_c6fbdfc2918d5e58","self","__wbg_window_baec038b5ab35c54","window","__wbg_globalThis_3f735a5746d41fbd","globalThis","__wbg_global_1bc0b39582740e95","global","__wbindgen_is_undefined","__wbg_buffer_397eaa4d72ee94dd","__wbg_newwithbyteoffsetandlength_4b9b8c4e3f5adbff","__wbg_new_a7ce447f15ff496f","__wbg_set_969ad0a60e51d320","__wbg_length_1eb8fc608a0d4cdb","__wbg_newwithlength_929232475839a482","__wbg_subarray_8b658422a224f479","__wbg_has_1275b5eec3dc7a7a","has","__wbg_set_82a4e8a85e31ac42","__wbg_stringify_d4507a59932eed0c","__wbindgen_debug_string","__wbindgen_throw","__wbindgen_rethrow","__wbindgen_memory","__wbindgen_closure_wrapper7258","dtor","state","real","makeMutClosure","exports","originalModule","webpackPolyfill","children","defineProperty","enumerable","l"],"mappings":"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","file":"static/js/3.1988b652.chunk.js","sourcesContent":["import * as wasm from \"./ergo_lib_wasm_bg.wasm\";\nexport * from \"./ergo_lib_wasm_bg.js\";","import * as wasm from './ergo_lib_wasm_bg.wasm';\n\nconst heap = new Array(32).fill(undefined);\n\nheap.push(undefined, null, true, false);\n\nfunction getObject(idx) { return heap[idx]; }\n\nlet heap_next = heap.length;\n\nfunction dropObject(idx) {\n    if (idx < 36) return;\n    heap[idx] = heap_next;\n    heap_next = idx;\n}\n\nfunction takeObject(idx) {\n    const ret = getObject(idx);\n    dropObject(idx);\n    return ret;\n}\n\nconst lTextDecoder = typeof TextDecoder === 'undefined' ? (0, module.require)('util').TextDecoder : TextDecoder;\n\nlet cachedTextDecoder = new lTextDecoder('utf-8', { ignoreBOM: true, fatal: true });\n\ncachedTextDecoder.decode();\n\nlet cachegetUint8Memory0 = null;\nfunction getUint8Memory0() {\n    if (cachegetUint8Memory0 === null || cachegetUint8Memory0.buffer !== wasm.memory.buffer) {\n        cachegetUint8Memory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachegetUint8Memory0;\n}\n\nfunction getStringFromWasm0(ptr, len) {\n    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));\n}\n\nfunction addHeapObject(obj) {\n    if (heap_next === heap.length) heap.push(heap.length + 1);\n    const idx = heap_next;\n    heap_next = heap[idx];\n\n    heap[idx] = obj;\n    return idx;\n}\n\nlet WASM_VECTOR_LEN = 0;\n\nconst lTextEncoder = typeof TextEncoder === 'undefined' ? (0, module.require)('util').TextEncoder : TextEncoder;\n\nlet cachedTextEncoder = new lTextEncoder('utf-8');\n\nconst encodeString = (typeof cachedTextEncoder.encodeInto === 'function'\n    ? function (arg, view) {\n    return cachedTextEncoder.encodeInto(arg, view);\n}\n    : function (arg, view) {\n    const buf = cachedTextEncoder.encode(arg);\n    view.set(buf);\n    return {\n        read: arg.length,\n        written: buf.length\n    };\n});\n\nfunction passStringToWasm0(arg, malloc, realloc) {\n\n    if (realloc === undefined) {\n        const buf = cachedTextEncoder.encode(arg);\n        const ptr = malloc(buf.length);\n        getUint8Memory0().subarray(ptr, ptr + buf.length).set(buf);\n        WASM_VECTOR_LEN = buf.length;\n        return ptr;\n    }\n\n    let len = arg.length;\n    let ptr = malloc(len);\n\n    const mem = getUint8Memory0();\n\n    let offset = 0;\n\n    for (; offset < len; offset++) {\n        const code = arg.charCodeAt(offset);\n        if (code > 0x7F) break;\n        mem[ptr + offset] = code;\n    }\n\n    if (offset !== len) {\n        if (offset !== 0) {\n            arg = arg.slice(offset);\n        }\n        ptr = realloc(ptr, len, len = offset + arg.length * 3);\n        const view = getUint8Memory0().subarray(ptr + offset, ptr + len);\n        const ret = encodeString(arg, view);\n\n        offset += ret.written;\n    }\n\n    WASM_VECTOR_LEN = offset;\n    return ptr;\n}\n\nfunction isLikeNone(x) {\n    return x === undefined || x === null;\n}\n\nlet cachegetInt32Memory0 = null;\nfunction getInt32Memory0() {\n    if (cachegetInt32Memory0 === null || cachegetInt32Memory0.buffer !== wasm.memory.buffer) {\n        cachegetInt32Memory0 = new Int32Array(wasm.memory.buffer);\n    }\n    return cachegetInt32Memory0;\n}\n\nfunction debugString(val) {\n    // primitive types\n    const type = typeof val;\n    if (type == 'number' || type == 'boolean' || val == null) {\n        return  `${val}`;\n    }\n    if (type == 'string') {\n        return `\"${val}\"`;\n    }\n    if (type == 'symbol') {\n        const description = val.description;\n        if (description == null) {\n            return 'Symbol';\n        } else {\n            return `Symbol(${description})`;\n        }\n    }\n    if (type == 'function') {\n        const name = val.name;\n        if (typeof name == 'string' && name.length > 0) {\n            return `Function(${name})`;\n        } else {\n            return 'Function';\n        }\n    }\n    // objects\n    if (Array.isArray(val)) {\n        const length = val.length;\n        let debug = '[';\n        if (length > 0) {\n            debug += debugString(val[0]);\n        }\n        for(let i = 1; i < length; i++) {\n            debug += ', ' + debugString(val[i]);\n        }\n        debug += ']';\n        return debug;\n    }\n    // Test for built-in\n    const builtInMatches = /\\[object ([^\\]]+)\\]/.exec(toString.call(val));\n    let className;\n    if (builtInMatches.length > 1) {\n        className = builtInMatches[1];\n    } else {\n        // Failed to match the standard '[object ClassName]'\n        return toString.call(val);\n    }\n    if (className == 'Object') {\n        // we're a user defined class or Object\n        // JSON.stringify avoids problems with cycles, and is generally much\n        // easier than looping through ownProperties of `val`.\n        try {\n            return 'Object(' + JSON.stringify(val) + ')';\n        } catch (_) {\n            return 'Object';\n        }\n    }\n    // errors\n    if (val instanceof Error) {\n        return `${val.name}: ${val.message}\\n${val.stack}`;\n    }\n    // TODO we could test for more things here, like `Set`s and `Map`s.\n    return className;\n}\n\nfunction makeMutClosure(arg0, arg1, dtor, f) {\n    const state = { a: arg0, b: arg1, cnt: 1, dtor };\n    const real = (...args) => {\n        // First up with a closure we increment the internal reference\n        // count. This ensures that the Rust closure environment won't\n        // be deallocated while we're invoking it.\n        state.cnt++;\n        const a = state.a;\n        state.a = 0;\n        try {\n            return f(a, state.b, ...args);\n        } finally {\n            if (--state.cnt === 0) {\n                wasm.__wbindgen_export_2.get(state.dtor)(a, state.b);\n\n            } else {\n                state.a = a;\n            }\n        }\n    };\n    real.original = state;\n\n    return real;\n}\nfunction __wbg_adapter_34(arg0, arg1, arg2) {\n    wasm._dyn_core__ops__function__FnMut__A____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__ha9ab65b8d16902bf(arg0, arg1, addHeapObject(arg2));\n}\n\nfunction getArrayU8FromWasm0(ptr, len) {\n    return getUint8Memory0().subarray(ptr / 1, ptr / 1 + len);\n}\n\nfunction _assertClass(instance, klass) {\n    if (!(instance instanceof klass)) {\n        throw new Error(`expected instance of ${klass.name}`);\n    }\n    return instance.ptr;\n}\n\nfunction passArray8ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 1);\n    getUint8Memory0().set(arg, ptr / 1);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n\nlet cachegetUint32Memory0 = null;\nfunction getUint32Memory0() {\n    if (cachegetUint32Memory0 === null || cachegetUint32Memory0.buffer !== wasm.memory.buffer) {\n        cachegetUint32Memory0 = new Uint32Array(wasm.memory.buffer);\n    }\n    return cachegetUint32Memory0;\n}\n\nfunction passArray32ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 4);\n    getUint32Memory0().set(arg, ptr / 4);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n\nfunction getArrayI32FromWasm0(ptr, len) {\n    return getInt32Memory0().subarray(ptr / 4, ptr / 4 + len);\n}\n\nfunction passArrayJsValueToWasm0(array, malloc) {\n    const ptr = malloc(array.length * 4);\n    const mem = getUint32Memory0();\n    for (let i = 0; i < array.length; i++) {\n        mem[ptr / 4 + i] = addHeapObject(array[i]);\n    }\n    WASM_VECTOR_LEN = array.length;\n    return ptr;\n}\n\nfunction getArrayJsValueFromWasm0(ptr, len) {\n    const mem = getUint32Memory0();\n    const slice = mem.subarray(ptr / 4, ptr / 4 + len);\n    const result = [];\n    for (let i = 0; i < slice.length; i++) {\n        result.push(takeObject(slice[i]));\n    }\n    return result;\n}\n/**\n* Decodes a base16 string into an array of bytes\n* @param {string} data\n* @returns {Uint8Array}\n*/\nexport function base16_decode(data) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        var ptr0 = passStringToWasm0(data, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        wasm.base16_decode(retptr, ptr0, len0);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var v1 = getArrayU8FromWasm0(r0, r1).slice();\n        wasm.__wbindgen_free(r0, r1 * 1);\n        return v1;\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* GET on /info endpoint\n* @param {NodeConf} node\n* @returns {Promise<any>}\n*/\nexport function get_info(node) {\n    _assertClass(node, NodeConf);\n    var ptr0 = node.ptr;\n    node.ptr = 0;\n    var ret = wasm.get_info(ptr0);\n    return takeObject(ret);\n}\n\nfunction handleError(f, args) {\n    try {\n        return f.apply(this, args);\n    } catch (e) {\n        wasm.__wbindgen_exn_store(addHeapObject(e));\n    }\n}\nfunction __wbg_adapter_347(arg0, arg1, arg2, arg3) {\n    wasm.wasm_bindgen__convert__closures__invoke2_mut__h8b0df6897c174155(arg0, arg1, addHeapObject(arg2), addHeapObject(arg3));\n}\n\n/**\n* newtype for box registers R4 - R9\n*/\nexport const NonMandatoryRegisterId = Object.freeze({\n/**\n* id for R4 register\n*/\nR4:4,\"4\":\"R4\",\n/**\n* id for R5 register\n*/\nR5:5,\"5\":\"R5\",\n/**\n* id for R6 register\n*/\nR6:6,\"6\":\"R6\",\n/**\n* id for R7 register\n*/\nR7:7,\"7\":\"R7\",\n/**\n* id for R8 register\n*/\nR8:8,\"8\":\"R8\",\n/**\n* id for R9 register\n*/\nR9:9,\"9\":\"R9\", });\n/**\n* Network type\n*/\nexport const NetworkPrefix = Object.freeze({\n/**\n* Mainnet\n*/\nMainnet:0,\"0\":\"Mainnet\",\n/**\n* Testnet\n*/\nTestnet:16,\"16\":\"Testnet\", });\n/**\n* Address types\n*/\nexport const AddressTypePrefix = Object.freeze({\n/**\n* 0x01 - Pay-to-PublicKey(P2PK) address\n*/\nP2Pk:1,\"1\":\"P2Pk\",\n/**\n* 0x02 - Pay-to-Script-Hash(P2SH)\n*/\nPay2Sh:2,\"2\":\"Pay2Sh\",\n/**\n* 0x03 - Pay-to-Script(P2S)\n*/\nPay2S:3,\"3\":\"Pay2S\", });\n/**\n*\n* * An address is a short string corresponding to some script used to protect a box. Unlike (string-encoded) binary\n* * representation of a script, an address has some useful characteristics:\n* *\n* * - Integrity of an address could be checked., as it is incorporating a checksum.\n* * - A prefix of address is showing network and an address type.\n* * - An address is using an encoding (namely, Base58) which is avoiding similarly l0Oking characters, friendly to\n* * double-clicking and line-breaking in emails.\n* *\n* *\n* *\n* * An address is encoding network type, address type, checksum, and enough information to watch for a particular scripts.\n* *\n* * Possible network types are:\n* * Mainnet - 0x00\n* * Testnet - 0x10\n* *\n* * For an address type, we form content bytes as follows:\n* *\n* * P2PK - serialized (compressed) public key\n* * P2SH - first 192 bits of the Blake2b256 hash of serialized script bytes\n* * P2S  - serialized script\n* *\n* * Address examples for testnet:\n* *\n* * 3   - P2PK (3WvsT2Gm4EpsM9Pg18PdY6XyhNNMqXDsvJTbbf6ihLvAmSb7u5RN)\n* * ?   - P2SH (rbcrmKEYduUvADj9Ts3dSVSG27h54pgrq5fPuwB)\n* * ?   - P2S (Ms7smJwLGbUAjuWQ)\n* *\n* * for mainnet:\n* *\n* * 9  - P2PK (9fRAWhdxEsTcdb8PhGNrZfwqa65zfkuYHAMmkQLcic1gdLSV5vA)\n* * ?  - P2SH (8UApt8czfFVuTgQmMwtsRBZ4nfWquNiSwCWUjMg)\n* * ?  - P2S (4MQyML64GnzMxZgm, BxKBaHkvrTvLZrDcZjcsxsF7aSsrN73ijeFZXtbj4CXZHHcvBtqSxQ)\n* *\n* *\n* * Prefix byte = network type + address type\n* *\n* * checksum = blake2b256(prefix byte ++ content bytes)\n* *\n* * address = prefix byte ++ content bytes ++ checksum\n* *\n*\n*/\nexport class Address {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Address.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_address_free(ptr);\n    }\n    /**\n    * Re-create the address from ErgoTree that was built from the address\n    *\n    * At some point in the past a user entered an address from which the ErgoTree was built.\n    * Re-create the address from this ErgoTree.\n    * `tree` - ErgoTree that was created from an Address\n    * @param {ErgoTree} ergo_tree\n    * @returns {Address}\n    */\n    static recreate_from_ergo_tree(ergo_tree) {\n        _assertClass(ergo_tree, ErgoTree);\n        var ret = wasm.address_recreate_from_ergo_tree(ergo_tree.ptr);\n        return Address.__wrap(ret);\n    }\n    /**\n    * Create a P2PK address from serialized PK bytes(EcPoint/GroupElement)\n    * @param {Uint8Array} bytes\n    * @returns {Address}\n    */\n    static p2pk_from_pk_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.address_p2pk_from_pk_bytes(ptr0, len0);\n        return Address.__wrap(ret);\n    }\n    /**\n    * Decode (base58) testnet address from string, checking that address is from the testnet\n    * @param {string} s\n    * @returns {Address}\n    */\n    static from_testnet_str(s) {\n        var ptr0 = passStringToWasm0(s, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.address_from_testnet_str(ptr0, len0);\n        return Address.__wrap(ret);\n    }\n    /**\n    * Decode (base58) mainnet address from string, checking that address is from the mainnet\n    * @param {string} s\n    * @returns {Address}\n    */\n    static from_mainnet_str(s) {\n        var ptr0 = passStringToWasm0(s, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.address_from_mainnet_str(ptr0, len0);\n        return Address.__wrap(ret);\n    }\n    /**\n    * Decode (base58) address from string without checking the network prefix\n    * @param {string} s\n    * @returns {Address}\n    */\n    static from_base58(s) {\n        var ptr0 = passStringToWasm0(s, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.address_from_base58(ptr0, len0);\n        return Address.__wrap(ret);\n    }\n    /**\n    * Encode (base58) address\n    * @param {number} network_prefix\n    * @returns {string}\n    */\n    to_base58(network_prefix) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.address_to_base58(retptr, this.ptr, network_prefix);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * Decode from a serialized address (that includes the network prefix)\n    * @param {Uint8Array} data\n    * @returns {Address}\n    */\n    static from_bytes(data) {\n        var ptr0 = passArray8ToWasm0(data, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.address_from_bytes(ptr0, len0);\n        return Address.__wrap(ret);\n    }\n    /**\n    * Encode address as serialized bytes (that includes the network prefix)\n    * @param {number} network_prefix\n    * @returns {Uint8Array}\n    */\n    to_bytes(network_prefix) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.address_to_bytes(retptr, this.ptr, network_prefix);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Get the type of the address\n    * @returns {number}\n    */\n    address_type_prefix() {\n        var ret = wasm.address_address_type_prefix(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Create an address from a public key\n    * @param {Uint8Array} bytes\n    * @returns {Address}\n    */\n    static from_public_key(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.address_from_public_key(ptr0, len0);\n        return Address.__wrap(ret);\n    }\n    /**\n    * Creates an ErgoTree script from the address\n    * @returns {ErgoTree}\n    */\n    to_ergo_tree() {\n        var ret = wasm.address_to_ergo_tree(this.ptr);\n        return ErgoTree.__wrap(ret);\n    }\n}\n/**\n* Block header\n*/\nexport class BlockHeader {\n\n    static __wrap(ptr) {\n        const obj = Object.create(BlockHeader.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_blockheader_free(ptr);\n    }\n    /**\n    * Parse from JSON (Node API)\n    * @param {string} json\n    * @returns {BlockHeader}\n    */\n    static from_json(json) {\n        var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.blockheader_from_json(ptr0, len0);\n        return BlockHeader.__wrap(ret);\n    }\n}\n/**\n* Collection of BlockHeaders\n*/\nexport class BlockHeaders {\n\n    static __wrap(ptr) {\n        const obj = Object.create(BlockHeaders.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_blockheaders_free(ptr);\n    }\n    /**\n    * parse BlockHeader array from JSON (Node API)\n    * @param {any[]} json_vals\n    * @returns {BlockHeaders}\n    */\n    static from_json(json_vals) {\n        var ptr0 = passArrayJsValueToWasm0(json_vals, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.blockheaders_from_json(ptr0, len0);\n        return BlockHeaders.__wrap(ret);\n    }\n    /**\n    * Create new collection with one element\n    * @param {BlockHeader} b\n    */\n    constructor(b) {\n        _assertClass(b, BlockHeader);\n        var ret = wasm.blockheaders_new(b.ptr);\n        return BlockHeaders.__wrap(ret);\n    }\n    /**\n    * Returns the number of elements in the collection\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.blockheaders_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Add an element to the collection\n    * @param {BlockHeader} b\n    */\n    add(b) {\n        _assertClass(b, BlockHeader);\n        wasm.blockheaders_add(this.ptr, b.ptr);\n    }\n    /**\n    * Returns the element of the collection with a given index\n    * @param {number} index\n    * @returns {BlockHeader}\n    */\n    get(index) {\n        var ret = wasm.blockheaders_get(this.ptr, index);\n        return BlockHeader.__wrap(ret);\n    }\n}\n/**\n* Box id (32-byte digest)\n*/\nexport class BoxId {\n\n    static __wrap(ptr) {\n        const obj = Object.create(BoxId.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_boxid_free(ptr);\n    }\n    /**\n    * Parse box id (32 byte digest) from base16-encoded string\n    * @param {string} box_id_str\n    * @returns {BoxId}\n    */\n    static from_str(box_id_str) {\n        var ptr0 = passStringToWasm0(box_id_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.boxid_from_str(ptr0, len0);\n        return BoxId.__wrap(ret);\n    }\n    /**\n    * Base16 encoded string\n    * @returns {string}\n    */\n    to_str() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.boxid_to_str(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * Returns byte array (32 bytes)\n    * @returns {Uint8Array}\n    */\n    as_bytes() {\n        var ret = wasm.boxid_as_bytes(this.ptr);\n        return takeObject(ret);\n    }\n}\n/**\n* Selected boxes with change boxes (by [`BoxSelector`])\n*/\nexport class BoxSelection {\n\n    static __wrap(ptr) {\n        const obj = Object.create(BoxSelection.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_boxselection_free(ptr);\n    }\n    /**\n    * Create a selection to easily inject custom selection algorithms\n    * @param {ErgoBoxes} boxes\n    * @param {ErgoBoxAssetsDataList} change\n    */\n    constructor(boxes, change) {\n        _assertClass(boxes, ErgoBoxes);\n        _assertClass(change, ErgoBoxAssetsDataList);\n        var ret = wasm.boxselection_new(boxes.ptr, change.ptr);\n        return BoxSelection.__wrap(ret);\n    }\n    /**\n    * Selected boxes to spend as transaction inputs\n    * @returns {ErgoBoxes}\n    */\n    boxes() {\n        var ret = wasm.boxselection_boxes(this.ptr);\n        return ErgoBoxes.__wrap(ret);\n    }\n    /**\n    * Selected boxes to use as change\n    * @returns {ErgoBoxAssetsDataList}\n    */\n    change() {\n        var ret = wasm.boxselection_change(this.ptr);\n        return ErgoBoxAssetsDataList.__wrap(ret);\n    }\n}\n/**\n* Box value in nanoERGs with bound checks\n*/\nexport class BoxValue {\n\n    static __wrap(ptr) {\n        const obj = Object.create(BoxValue.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_boxvalue_free(ptr);\n    }\n    /**\n    * Recommended (safe) minimal box value to use in case box size estimation is unavailable.\n    * Allows box size upto 2777 bytes with current min box value per byte of 360 nanoERGs\n    * @returns {BoxValue}\n    */\n    static SAFE_USER_MIN() {\n        var ret = wasm.boxvalue_SAFE_USER_MIN();\n        return BoxValue.__wrap(ret);\n    }\n    /**\n    * Number of units inside one ERGO (i.e. one ERG using nano ERG representation)\n    * @returns {I64}\n    */\n    static UNITS_PER_ERGO() {\n        var ret = wasm.boxvalue_UNITS_PER_ERGO();\n        return I64.__wrap(ret);\n    }\n    /**\n    * Create from i64 with bounds check\n    * @param {I64} v\n    * @returns {BoxValue}\n    */\n    static from_i64(v) {\n        _assertClass(v, I64);\n        var ret = wasm.boxvalue_from_i64(v.ptr);\n        return BoxValue.__wrap(ret);\n    }\n    /**\n    * Get value as signed 64-bit long (I64)\n    * @returns {I64}\n    */\n    as_i64() {\n        var ret = wasm.boxvalue_as_i64(this.ptr);\n        return I64.__wrap(ret);\n    }\n    /**\n    * big-endian byte array representation\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.boxvalue_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n* Ergo constant(evaluated) values\n*/\nexport class Constant {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Constant.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_constant_free(ptr);\n    }\n    /**\n    * Decode from Base16-encoded ErgoTree serialized value\n    * @param {string} base16_bytes_str\n    * @returns {Constant}\n    */\n    static decode_from_base16(base16_bytes_str) {\n        var ptr0 = passStringToWasm0(base16_bytes_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.constant_decode_from_base16(ptr0, len0);\n        return Constant.__wrap(ret);\n    }\n    /**\n    * Encode as Base16-encoded ErgoTree serialized value or return an error if serialization\n    * failed\n    * @returns {string}\n    */\n    encode_to_base16() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.constant_encode_to_base16(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * Returns serialized bytes or fails with error if Constant cannot be serialized\n    * @returns {Uint8Array}\n    */\n    sigma_serialize_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.constant_sigma_serialize_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Create from i32 value\n    * @param {number} v\n    * @returns {Constant}\n    */\n    static from_i32(v) {\n        var ret = wasm.constant_from_i32(v);\n        return Constant.__wrap(ret);\n    }\n    /**\n    * Extract i32 value, returning error if wrong type\n    * @returns {number}\n    */\n    to_i32() {\n        var ret = wasm.constant_to_i32(this.ptr);\n        return ret;\n    }\n    /**\n    * Create from i64\n    * @param {I64} v\n    * @returns {Constant}\n    */\n    static from_i64(v) {\n        _assertClass(v, I64);\n        var ret = wasm.constant_from_i64(v.ptr);\n        return Constant.__wrap(ret);\n    }\n    /**\n    * Extract i64 value, returning error if wrong type\n    * @returns {I64}\n    */\n    to_i64() {\n        var ret = wasm.constant_to_i64(this.ptr);\n        return I64.__wrap(ret);\n    }\n    /**\n    * Create BigInt constant from byte array (signed bytes bit-endian)\n    * @param {Uint8Array} num\n    * @returns {Constant}\n    */\n    static from_bigint_signed_bytes_be(num) {\n        var ptr0 = passArray8ToWasm0(num, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.constant_from_bigint_signed_bytes_be(ptr0, len0);\n        return Constant.__wrap(ret);\n    }\n    /**\n    * Create from byte array\n    * @param {Uint8Array} v\n    * @returns {Constant}\n    */\n    static from_byte_array(v) {\n        var ptr0 = passArray8ToWasm0(v, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.constant_from_byte_array(ptr0, len0);\n        return Constant.__wrap(ret);\n    }\n    /**\n    * Extract byte array, returning error if wrong type\n    * @returns {Uint8Array}\n    */\n    to_byte_array() {\n        var ret = wasm.constant_to_byte_array(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * Create `Coll[Int]` from integer array\n    * @param {Int32Array} arr\n    * @returns {Constant}\n    */\n    static from_i32_array(arr) {\n        var ptr0 = passArray32ToWasm0(arr, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.constant_from_i32_array(ptr0, len0);\n        return Constant.__wrap(ret);\n    }\n    /**\n    * Extract `Coll[Int]` as integer array\n    * @returns {Int32Array}\n    */\n    to_i32_array() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.constant_to_i32_array(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayI32FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 4);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Create `Coll[Long]` from string array\n    * @param {any[]} arr\n    * @returns {Constant}\n    */\n    static from_i64_str_array(arr) {\n        var ptr0 = passArrayJsValueToWasm0(arr, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.constant_from_i64_str_array(ptr0, len0);\n        return Constant.__wrap(ret);\n    }\n    /**\n    * Extract `Coll[Long]` as string array\n    * @returns {any[]}\n    */\n    to_i64_str_array() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.constant_to_i64_str_array(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 4);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Extract `Coll[Coll[Byte]]` as array of byte arrays\n    * @returns {(Uint8Array)[]}\n    */\n    to_coll_coll_byte() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.constant_to_coll_coll_byte(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 4);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Create `Coll[Coll[Byte]]` from array byte array\n    * @param {(Uint8Array)[]} arr\n    * @returns {Constant}\n    */\n    static from_coll_coll_byte(arr) {\n        var ptr0 = passArrayJsValueToWasm0(arr, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.constant_from_coll_coll_byte(ptr0, len0);\n        return Constant.__wrap(ret);\n    }\n    /**\n    * Parse raw [`EcPoint`] value from bytes and make [`ProveDlog`] constant\n    * @param {Uint8Array} bytes\n    * @returns {Constant}\n    */\n    static from_ecpoint_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.constant_from_ecpoint_bytes(ptr0, len0);\n        return Constant.__wrap(ret);\n    }\n    /**\n    * Parse raw [`EcPoint`] value from bytes and make [`groupElement`] constant\n    * @param {Uint8Array} bytes\n    * @returns {Constant}\n    */\n    static from_ecpoint_bytes_group_element(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.constant_from_ecpoint_bytes_group_element(ptr0, len0);\n        return Constant.__wrap(ret);\n    }\n    /**\n    * Create `(Coll[Byte], Coll[Byte])` tuple Constant\n    * @param {Uint8Array} bytes1\n    * @param {Uint8Array} bytes2\n    * @returns {Constant}\n    */\n    static from_tuple_coll_bytes(bytes1, bytes2) {\n        var ptr0 = passArray8ToWasm0(bytes1, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ptr1 = passArray8ToWasm0(bytes2, wasm.__wbindgen_malloc);\n        var len1 = WASM_VECTOR_LEN;\n        var ret = wasm.constant_from_tuple_coll_bytes(ptr0, len0, ptr1, len1);\n        return Constant.__wrap(ret);\n    }\n    /**\n    * Extract `(Coll[Byte], Coll[Byte])` tuple from Constant as array of Uint8Array\n    * @returns {(Uint8Array)[]}\n    */\n    to_tuple_coll_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.constant_to_tuple_coll_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 4);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Create `(Int, Int)` tuple Constant\n    * @returns {any[]}\n    */\n    to_tuple_i32() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.constant_to_tuple_i32(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 4);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Create `(Long, Long)` tuple Constant\n    * @param {I64} l1\n    * @param {I64} l2\n    * @returns {Constant}\n    */\n    static from_tuple_i64(l1, l2) {\n        _assertClass(l1, I64);\n        _assertClass(l2, I64);\n        var ret = wasm.constant_from_tuple_i64(l1.ptr, l2.ptr);\n        return Constant.__wrap(ret);\n    }\n    /**\n    * Extract `(Long, Long)` tuple from Constant as array of strings\n    * @returns {any[]}\n    */\n    to_tuple_i64() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.constant_to_tuple_i64(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 4);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Create from ErgoBox value\n    * @param {ErgoBox} v\n    * @returns {Constant}\n    */\n    static from_ergo_box(v) {\n        _assertClass(v, ErgoBox);\n        var ret = wasm.constant_from_ergo_box(v.ptr);\n        return Constant.__wrap(ret);\n    }\n    /**\n    * Extract ErgoBox value, returning error if wrong type\n    * @returns {ErgoBox}\n    */\n    to_ergo_box() {\n        var ret = wasm.constant_to_ergo_box(this.ptr);\n        return ErgoBox.__wrap(ret);\n    }\n}\n/**\n* User-defined variables to be put into context\n*/\nexport class ContextExtension {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ContextExtension.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_contextextension_free(ptr);\n    }\n    /**\n    * Create new ContextExtension instance\n    */\n    constructor() {\n        var ret = wasm.contextextension_new();\n        return ContextExtension.__wrap(ret);\n    }\n    /**\n    * Set the supplied pair in the ContextExtension\n    * @param {number} id\n    * @param {Constant} value\n    */\n    set_pair(id, value) {\n        _assertClass(value, Constant);\n        wasm.contextextension_set_pair(this.ptr, id, value.ptr);\n    }\n    /**\n    * Returns the number of elements in the collection\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.contextextension_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * get from map or fail if key is missing\n    * @param {number} key\n    * @returns {Constant}\n    */\n    get(key) {\n        var ret = wasm.contextextension_get(this.ptr, key);\n        return Constant.__wrap(ret);\n    }\n    /**\n    * Returns all keys in the map\n    * @returns {Uint8Array}\n    */\n    keys() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.contextextension_keys(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Returns serialized bytes or fails with error if ContextExtension cannot be serialized\n    * @returns {Uint8Array}\n    */\n    sigma_serialize_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.contextextension_sigma_serialize_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n* Defines the contract(script) that will be guarding box contents\n*/\nexport class Contract {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Contract.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_contract_free(ptr);\n    }\n    /**\n    * Create new contract from ErgoTree\n    * @param {ErgoTree} ergo_tree\n    * @returns {Contract}\n    */\n    static new(ergo_tree) {\n        _assertClass(ergo_tree, ErgoTree);\n        var ptr0 = ergo_tree.ptr;\n        ergo_tree.ptr = 0;\n        var ret = wasm.contract_new(ptr0);\n        return Contract.__wrap(ret);\n    }\n    /**\n    * create new contract that allow spending of the guarded box by a given recipient ([`Address`])\n    * @param {Address} recipient\n    * @returns {Contract}\n    */\n    static pay_to_address(recipient) {\n        _assertClass(recipient, Address);\n        var ret = wasm.contract_pay_to_address(recipient.ptr);\n        return Contract.__wrap(ret);\n    }\n    /**\n    * Compiles a contract from ErgoScript source code\n    * @param {string} source\n    * @returns {Contract}\n    */\n    static compile(source) {\n        var ptr0 = passStringToWasm0(source, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.contract_compile(ptr0, len0);\n        return Contract.__wrap(ret);\n    }\n    /**\n    * Get the ErgoTree of the contract\n    * @returns {ErgoTree}\n    */\n    ergo_tree() {\n        var ret = wasm.contract_ergo_tree(this.ptr);\n        return ErgoTree.__wrap(ret);\n    }\n}\n/**\n* Inputs, that are used to enrich script context, but won't be spent by the transaction\n*/\nexport class DataInput {\n\n    static __wrap(ptr) {\n        const obj = Object.create(DataInput.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_datainput_free(ptr);\n    }\n    /**\n    * Parse box id (32 byte digest) from base16-encoded string\n    * @param {BoxId} box_id\n    */\n    constructor(box_id) {\n        _assertClass(box_id, BoxId);\n        var ptr0 = box_id.ptr;\n        box_id.ptr = 0;\n        var ret = wasm.datainput_new(ptr0);\n        return DataInput.__wrap(ret);\n    }\n    /**\n    * Get box id\n    * @returns {BoxId}\n    */\n    box_id() {\n        var ret = wasm.datainput_box_id(this.ptr);\n        return BoxId.__wrap(ret);\n    }\n}\n/**\n* DataInput collection\n*/\nexport class DataInputs {\n\n    static __wrap(ptr) {\n        const obj = Object.create(DataInputs.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_datainputs_free(ptr);\n    }\n    /**\n    * Create empty DataInputs\n    */\n    constructor() {\n        var ret = wasm.datainputs_new();\n        return DataInputs.__wrap(ret);\n    }\n    /**\n    * Returns the number of elements in the collection\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.datainputs_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Returns the element of the collection with a given index\n    * @param {number} index\n    * @returns {DataInput}\n    */\n    get(index) {\n        var ret = wasm.datainputs_get(this.ptr, index);\n        return DataInput.__wrap(ret);\n    }\n    /**\n    * Adds an elements to the collection\n    * @param {DataInput} elem\n    */\n    add(elem) {\n        _assertClass(elem, DataInput);\n        wasm.datainputs_add(this.ptr, elem.ptr);\n    }\n}\n/**\n* According to\n* BIP-44 <https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki>\n* and EIP-3 <https://github.com/ergoplatform/eips/blob/master/eip-0003.md>\n*/\nexport class DerivationPath {\n\n    static __wrap(ptr) {\n        const obj = Object.create(DerivationPath.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_derivationpath_free(ptr);\n    }\n    /**\n    * Create derivation path for a given account index (hardened) and address indices\n    * `m / 44' / 429' / acc' / 0 / address[0] / address[1] / ...`\n    * or `m / 44' / 429' / acc' / 0` if address indices are empty\n    * change is always zero according to EIP-3\n    * acc is expected as a 31-bit value (32th bit should not be set)\n    * @param {number} acc\n    * @param {Uint32Array} address_indices\n    * @returns {DerivationPath}\n    */\n    static new(acc, address_indices) {\n        var ptr0 = passArray32ToWasm0(address_indices, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.derivationpath_new(acc, ptr0, len0);\n        return DerivationPath.__wrap(ret);\n    }\n    /**\n    * Create root derivation path\n    * @returns {DerivationPath}\n    */\n    static master_path() {\n        var ret = wasm.derivationpath_master_path();\n        return DerivationPath.__wrap(ret);\n    }\n    /**\n    * Returns the length of the derivation path\n    * @returns {number}\n    */\n    depth() {\n        var ret = wasm.derivationpath_depth(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Returns a new path with the last element of the deriviation path being increased, e.g. m/1/2 -> m/1/3\n    * Returns an empty path error if the path is empty (master node)\n    * @returns {DerivationPath}\n    */\n    next() {\n        var ret = wasm.derivationpath_next(this.ptr);\n        return DerivationPath.__wrap(ret);\n    }\n    /**\n    * String representation of derivation path\n    * E.g m/44'/429'/0'/0/1\n    * @returns {string}\n    */\n    toString() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.derivationpath_toString(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * Create a derivation path from a formatted string\n    * E.g \"m/44'/429'/0'/0/1\"\n    * @param {string} path\n    * @returns {DerivationPath}\n    */\n    static from_string(path) {\n        var ptr0 = passStringToWasm0(path, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.derivationpath_from_string(ptr0, len0);\n        return DerivationPath.__wrap(ret);\n    }\n    /**\n    * For 0x21 Sign Transaction command of Ergo Ledger App Protocol\n    * P2PK Sign (0x0D) instruction\n    * Sign calculated TX hash with private key for provided BIP44 path.\n    * Data:\n    *\n    * Field\n    * Size (B)\n    * Description\n    *\n    * BIP32 path length\n    * 1\n    * Value: 0x02-0x0A (2-10). Number of path components\n    *\n    * First derivation index\n    * 4\n    * Big-endian. Value: 44\n    *\n    * Second derivation index\n    * 4\n    * Big-endian. Value: 429 (Ergo coin id)\n    *\n    * Optional Third index\n    * 4\n    * Big-endian. Any valid bip44 hardened value.\n    * ...\n    * Optional Last index\n    * 4\n    * Big-endian. Any valid bip44 value.\n    * @returns {Uint8Array}\n    */\n    ledger_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.derivationpath_ledger_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n* Ergo box, that is taking part in some transaction on the chain\n* Differs with [`ErgoBoxCandidate`] by added transaction id and an index in the input of that transaction\n*/\nexport class ErgoBox {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ErgoBox.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_ergobox_free(ptr);\n    }\n    /**\n    * make a new box with:\n    * `value` - amount of money associated with the box\n    * `contract` - guarding contract([`Contract`]), which should be evaluated to true in order\n    * to open(spend) this box\n    * `creation_height` - height when a transaction containing the box is created.\n    * `tx_id` - transaction id in which this box was \"created\" (participated in outputs)\n    * `index` - index (in outputs) in the transaction\n    * @param {BoxValue} value\n    * @param {number} creation_height\n    * @param {Contract} contract\n    * @param {TxId} tx_id\n    * @param {number} index\n    * @param {Tokens} tokens\n    */\n    constructor(value, creation_height, contract, tx_id, index, tokens) {\n        _assertClass(value, BoxValue);\n        _assertClass(contract, Contract);\n        _assertClass(tx_id, TxId);\n        _assertClass(tokens, Tokens);\n        var ret = wasm.ergobox_new(value.ptr, creation_height, contract.ptr, tx_id.ptr, index, tokens.ptr);\n        return ErgoBox.__wrap(ret);\n    }\n    /**\n    * Get box id\n    * @returns {BoxId}\n    */\n    box_id() {\n        var ret = wasm.ergobox_box_id(this.ptr);\n        return BoxId.__wrap(ret);\n    }\n    /**\n    * Get box creation height\n    * @returns {number}\n    */\n    creation_height() {\n        var ret = wasm.ergobox_creation_height(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Get tokens for box\n    * @returns {Tokens}\n    */\n    tokens() {\n        var ret = wasm.ergobox_tokens(this.ptr);\n        return Tokens.__wrap(ret);\n    }\n    /**\n    * Get ergo tree for box\n    * @returns {ErgoTree}\n    */\n    ergo_tree() {\n        var ret = wasm.ergobox_ergo_tree(this.ptr);\n        return ErgoTree.__wrap(ret);\n    }\n    /**\n    * Get box value in nanoERGs\n    * @returns {BoxValue}\n    */\n    value() {\n        var ret = wasm.ergobox_value(this.ptr);\n        return BoxValue.__wrap(ret);\n    }\n    /**\n    * Returns value (ErgoTree constant) stored in the register or None if the register is empty\n    * @param {number} register_id\n    * @returns {Constant | undefined}\n    */\n    register_value(register_id) {\n        var ret = wasm.ergobox_register_value(this.ptr, register_id);\n        return ret === 0 ? undefined : Constant.__wrap(ret);\n    }\n    /**\n    * JSON representation as text (compatible with Ergo Node/Explorer API, numbers are encoded as numbers)\n    * @returns {string}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ergobox_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * JSON representation according to EIP-12 <https://github.com/ergoplatform/eips/pull/23>\n    * (similar to [`Self::to_json`], but as JS object with box value and token amounts encoding as strings)\n    * @returns {any}\n    */\n    to_js_eip12() {\n        var ret = wasm.ergobox_to_js_eip12(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * parse from JSON\n    * supports Ergo Node/Explorer API and box values and token amount encoded as strings\n    * @param {string} json\n    * @returns {ErgoBox}\n    */\n    static from_json(json) {\n        var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.ergobox_from_json(ptr0, len0);\n        return ErgoBox.__wrap(ret);\n    }\n    /**\n    * Serialized additional register as defined in ErgoBox serialization (registers count,\n    * followed by every non-empyt register value serialized)\n    * @returns {Uint8Array}\n    */\n    serialized_additional_registers() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ergobox_serialized_additional_registers(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Returns serialized bytes or fails with error if cannot be serialized\n    * @returns {Uint8Array}\n    */\n    sigma_serialize_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ergobox_sigma_serialize_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Parses ErgoBox or fails with error\n    * @param {Uint8Array} data\n    * @returns {ErgoBox}\n    */\n    static sigma_parse_bytes(data) {\n        var ptr0 = passArray8ToWasm0(data, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.ergobox_sigma_parse_bytes(ptr0, len0);\n        return ErgoBox.__wrap(ret);\n    }\n}\n/**\n* Pair of <value, tokens> for an box\n*/\nexport class ErgoBoxAssetsData {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ErgoBoxAssetsData.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_ergoboxassetsdata_free(ptr);\n    }\n    /**\n    * Create new instance\n    * @param {BoxValue} value\n    * @param {Tokens} tokens\n    */\n    constructor(value, tokens) {\n        _assertClass(value, BoxValue);\n        _assertClass(tokens, Tokens);\n        var ret = wasm.ergoboxassetsdata_new(value.ptr, tokens.ptr);\n        return ErgoBoxAssetsData.__wrap(ret);\n    }\n    /**\n    * Value part of the box\n    * @returns {BoxValue}\n    */\n    value() {\n        var ret = wasm.ergoboxassetsdata_value(this.ptr);\n        return BoxValue.__wrap(ret);\n    }\n    /**\n    * Tokens part of the box\n    * @returns {Tokens}\n    */\n    tokens() {\n        var ret = wasm.ergoboxassetsdata_tokens(this.ptr);\n        return Tokens.__wrap(ret);\n    }\n}\n/**\n* List of asset data for a box\n*/\nexport class ErgoBoxAssetsDataList {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ErgoBoxAssetsDataList.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_ergoboxassetsdatalist_free(ptr);\n    }\n    /**\n    * Create empty Tokens\n    */\n    constructor() {\n        var ret = wasm.ergoboxassetsdatalist_new();\n        return ErgoBoxAssetsDataList.__wrap(ret);\n    }\n    /**\n    * Returns the number of elements in the collection\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.ergoboxassetsdatalist_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Returns the element of the collection with a given index\n    * @param {number} index\n    * @returns {ErgoBoxAssetsData}\n    */\n    get(index) {\n        var ret = wasm.ergoboxassetsdatalist_get(this.ptr, index);\n        return ErgoBoxAssetsData.__wrap(ret);\n    }\n    /**\n    * Adds an elements to the collection\n    * @param {ErgoBoxAssetsData} elem\n    */\n    add(elem) {\n        _assertClass(elem, ErgoBoxAssetsData);\n        wasm.ergoboxassetsdatalist_add(this.ptr, elem.ptr);\n    }\n}\n/**\n* ErgoBox candidate not yet included in any transaction on the chain\n*/\nexport class ErgoBoxCandidate {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ErgoBoxCandidate.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_ergoboxcandidate_free(ptr);\n    }\n    /**\n    * Create a box with miner's contract and given value\n    * @param {BoxValue} fee_amount\n    * @param {number} creation_height\n    * @returns {ErgoBoxCandidate}\n    */\n    static new_miner_fee_box(fee_amount, creation_height) {\n        _assertClass(fee_amount, BoxValue);\n        var ret = wasm.ergoboxcandidate_new_miner_fee_box(fee_amount.ptr, creation_height);\n        return ErgoBoxCandidate.__wrap(ret);\n    }\n    /**\n    * Returns value (ErgoTree constant) stored in the register or None if the register is empty\n    * @param {number} register_id\n    * @returns {Constant | undefined}\n    */\n    register_value(register_id) {\n        var ret = wasm.ergoboxcandidate_register_value(this.ptr, register_id);\n        return ret === 0 ? undefined : Constant.__wrap(ret);\n    }\n    /**\n    * Get box creation height\n    * @returns {number}\n    */\n    creation_height() {\n        var ret = wasm.ergoboxcandidate_creation_height(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Get tokens for box\n    * @returns {Tokens}\n    */\n    tokens() {\n        var ret = wasm.ergoboxcandidate_tokens(this.ptr);\n        return Tokens.__wrap(ret);\n    }\n    /**\n    * Get ergo tree for box\n    * @returns {ErgoTree}\n    */\n    ergo_tree() {\n        var ret = wasm.ergoboxcandidate_ergo_tree(this.ptr);\n        return ErgoTree.__wrap(ret);\n    }\n    /**\n    * Get box value in nanoERGs\n    * @returns {BoxValue}\n    */\n    value() {\n        var ret = wasm.ergoboxcandidate_value(this.ptr);\n        return BoxValue.__wrap(ret);\n    }\n}\n/**\n* ErgoBoxCandidate builder\n*/\nexport class ErgoBoxCandidateBuilder {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ErgoBoxCandidateBuilder.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_ergoboxcandidatebuilder_free(ptr);\n    }\n    /**\n    * Create builder with required box parameters:\n    * `value` - amount of money associated with the box\n    * `contract` - guarding contract([`Contract`]), which should be evaluated to true in order\n    * to open(spend) this box\n    * `creation_height` - height when a transaction containing the box is created.\n    * It should not exceed height of the block, containing the transaction with this box.\n    * @param {BoxValue} value\n    * @param {Contract} contract\n    * @param {number} creation_height\n    */\n    constructor(value, contract, creation_height) {\n        _assertClass(value, BoxValue);\n        _assertClass(contract, Contract);\n        var ret = wasm.ergoboxcandidatebuilder_new(value.ptr, contract.ptr, creation_height);\n        return ErgoBoxCandidateBuilder.__wrap(ret);\n    }\n    /**\n    * Set minimal value (per byte of the serialized box size)\n    * @param {number} new_min_value_per_byte\n    */\n    set_min_box_value_per_byte(new_min_value_per_byte) {\n        wasm.ergoboxcandidatebuilder_set_min_box_value_per_byte(this.ptr, new_min_value_per_byte);\n    }\n    /**\n    * Get minimal value (per byte of the serialized box size)\n    * @returns {number}\n    */\n    min_box_value_per_byte() {\n        var ret = wasm.ergoboxcandidatebuilder_min_box_value_per_byte(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Set new box value\n    * @param {BoxValue} new_value\n    */\n    set_value(new_value) {\n        _assertClass(new_value, BoxValue);\n        var ptr0 = new_value.ptr;\n        new_value.ptr = 0;\n        wasm.ergoboxcandidatebuilder_set_value(this.ptr, ptr0);\n    }\n    /**\n    * Get box value\n    * @returns {BoxValue}\n    */\n    value() {\n        var ret = wasm.ergoboxcandidatebuilder_value(this.ptr);\n        return BoxValue.__wrap(ret);\n    }\n    /**\n    * Calculate serialized box size(in bytes)\n    * @returns {number}\n    */\n    calc_box_size_bytes() {\n        var ret = wasm.ergoboxcandidatebuilder_calc_box_size_bytes(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Calculate minimal box value for the current box serialized size(in bytes)\n    * @returns {BoxValue}\n    */\n    calc_min_box_value() {\n        var ret = wasm.ergoboxcandidatebuilder_calc_min_box_value(this.ptr);\n        return BoxValue.__wrap(ret);\n    }\n    /**\n    * Set register with a given id (R4-R9) to the given value\n    * @param {number} register_id\n    * @param {Constant} value\n    */\n    set_register_value(register_id, value) {\n        _assertClass(value, Constant);\n        wasm.ergoboxcandidatebuilder_set_register_value(this.ptr, register_id, value.ptr);\n    }\n    /**\n    * Returns register value for the given register id (R4-R9), or None if the register is empty\n    * @param {number} register_id\n    * @returns {Constant | undefined}\n    */\n    register_value(register_id) {\n        var ret = wasm.ergoboxcandidatebuilder_register_value(this.ptr, register_id);\n        return ret === 0 ? undefined : Constant.__wrap(ret);\n    }\n    /**\n    * Delete register value(make register empty) for the given register id (R4-R9)\n    * @param {number} register_id\n    */\n    delete_register_value(register_id) {\n        wasm.ergoboxcandidatebuilder_delete_register_value(this.ptr, register_id);\n    }\n    /**\n    * Mint token, as defined in <https://github.com/ergoplatform/eips/blob/master/eip-0004.md>\n    * `token` - token id(box id of the first input box in transaction) and token amount,\n    * `token_name` - token name (will be encoded in R4),\n    * `token_desc` - token description (will be encoded in R5),\n    * `num_decimals` - number of decimals (will be encoded in R6)\n    * @param {Token} token\n    * @param {string} token_name\n    * @param {string} token_desc\n    * @param {number} num_decimals\n    */\n    mint_token(token, token_name, token_desc, num_decimals) {\n        _assertClass(token, Token);\n        var ptr0 = passStringToWasm0(token_name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ptr1 = passStringToWasm0(token_desc, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len1 = WASM_VECTOR_LEN;\n        wasm.ergoboxcandidatebuilder_mint_token(this.ptr, token.ptr, ptr0, len0, ptr1, len1, num_decimals);\n    }\n    /**\n    * Add given token id and token amount\n    * @param {TokenId} token_id\n    * @param {TokenAmount} amount\n    */\n    add_token(token_id, amount) {\n        _assertClass(token_id, TokenId);\n        _assertClass(amount, TokenAmount);\n        wasm.ergoboxcandidatebuilder_add_token(this.ptr, token_id.ptr, amount.ptr);\n    }\n    /**\n    * Build the box candidate\n    * @returns {ErgoBoxCandidate}\n    */\n    build() {\n        var ret = wasm.ergoboxcandidatebuilder_build(this.ptr);\n        return ErgoBoxCandidate.__wrap(ret);\n    }\n}\n/**\n* Collection of ErgoBoxCandidates\n*/\nexport class ErgoBoxCandidates {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ErgoBoxCandidates.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_ergoboxcandidates_free(ptr);\n    }\n    /**\n    * Create new outputs\n    * @param {ErgoBoxCandidate} box_candidate\n    */\n    constructor(box_candidate) {\n        _assertClass(box_candidate, ErgoBoxCandidate);\n        var ret = wasm.ergoboxcandidates_new(box_candidate.ptr);\n        return ErgoBoxCandidates.__wrap(ret);\n    }\n    /**\n    * sometimes it's useful to keep track of an empty list\n    * but keep in mind Ergo transactions need at least 1 output\n    * @returns {ErgoBoxCandidates}\n    */\n    static empty() {\n        var ret = wasm.ergoboxcandidates_empty();\n        return ErgoBoxCandidates.__wrap(ret);\n    }\n    /**\n    * Returns the number of elements in the collection\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.ergoboxcandidates_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Returns the element of the collection with a given index\n    * @param {number} index\n    * @returns {ErgoBoxCandidate}\n    */\n    get(index) {\n        var ret = wasm.ergoboxcandidates_get(this.ptr, index);\n        return ErgoBoxCandidate.__wrap(ret);\n    }\n    /**\n    * Add an element to the collection\n    * @param {ErgoBoxCandidate} b\n    */\n    add(b) {\n        _assertClass(b, ErgoBoxCandidate);\n        wasm.ergoboxcandidates_add(this.ptr, b.ptr);\n    }\n}\n/**\n* Collection of ErgoBox'es\n*/\nexport class ErgoBoxes {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ErgoBoxes.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_ergoboxes_free(ptr);\n    }\n    /**\n    * parse ErgoBox array from json\n    * @param {any[]} json_vals\n    * @returns {ErgoBoxes}\n    */\n    static from_boxes_json(json_vals) {\n        var ptr0 = passArrayJsValueToWasm0(json_vals, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.ergoboxes_from_boxes_json(ptr0, len0);\n        return ErgoBoxes.__wrap(ret);\n    }\n    /**\n    * Create a new empty set of ergo boxes\n    * @returns {ErgoBoxes}\n    */\n    static empty() {\n        var ret = wasm.ergoboxes_empty();\n        return ErgoBoxes.__wrap(ret);\n    }\n    /**\n    * Create new collection with one element\n    * @param {ErgoBox} b\n    */\n    constructor(b) {\n        _assertClass(b, ErgoBox);\n        var ret = wasm.ergoboxes_new(b.ptr);\n        return ErgoBoxes.__wrap(ret);\n    }\n    /**\n    * Returns the number of elements in the collection\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.ergoboxes_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Add an element to the collection\n    * @param {ErgoBox} b\n    */\n    add(b) {\n        _assertClass(b, ErgoBox);\n        wasm.ergoboxes_add(this.ptr, b.ptr);\n    }\n    /**\n    * Returns the element of the collection with a given index\n    * @param {number} index\n    * @returns {ErgoBox}\n    */\n    get(index) {\n        var ret = wasm.ergoboxes_get(this.ptr, index);\n        return ErgoBox.__wrap(ret);\n    }\n}\n/**\n* Blockchain state (last headers, etc.)\n*/\nexport class ErgoStateContext {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ErgoStateContext.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_ergostatecontext_free(ptr);\n    }\n    /**\n    * Create new context from pre-header\n    * @param {PreHeader} pre_header\n    * @param {BlockHeaders} headers\n    */\n    constructor(pre_header, headers) {\n        _assertClass(pre_header, PreHeader);\n        var ptr0 = pre_header.ptr;\n        pre_header.ptr = 0;\n        _assertClass(headers, BlockHeaders);\n        var ptr1 = headers.ptr;\n        headers.ptr = 0;\n        var ret = wasm.ergostatecontext_new(ptr0, ptr1);\n        return ErgoStateContext.__wrap(ret);\n    }\n}\n/**\n* The root of ErgoScript IR. Serialized instances of this class are self sufficient and can be passed around.\n*/\nexport class ErgoTree {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ErgoTree.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_ergotree_free(ptr);\n    }\n    /**\n    * Decode from base16 encoded serialized ErgoTree\n    * @param {string} s\n    * @returns {ErgoTree}\n    */\n    static from_base16_bytes(s) {\n        var ptr0 = passStringToWasm0(s, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.ergotree_from_base16_bytes(ptr0, len0);\n        return ErgoTree.__wrap(ret);\n    }\n    /**\n    * Decode from encoded serialized ErgoTree\n    * @param {Uint8Array} data\n    * @returns {ErgoTree}\n    */\n    static from_bytes(data) {\n        var ptr0 = passArray8ToWasm0(data, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.ergotree_from_bytes(ptr0, len0);\n        return ErgoTree.__wrap(ret);\n    }\n    /**\n    * Returns serialized bytes or fails with error if ErgoTree cannot be serialized\n    * @returns {Uint8Array}\n    */\n    sigma_serialize_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ergotree_sigma_serialize_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Returns Base16-encoded serialized bytes\n    * @returns {string}\n    */\n    to_base16_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ergotree_to_base16_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * Returns constants number as stored in serialized ErgoTree or error if the parsing of\n    * constants is failed\n    * @returns {number}\n    */\n    constants_len() {\n        var ret = wasm.ergotree_constants_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Returns constant with given index (as stored in serialized ErgoTree)\n    * or None if index is out of bounds\n    * or error if constants parsing were failed\n    * @param {number} index\n    * @returns {Constant | undefined}\n    */\n    get_constant(index) {\n        var ret = wasm.ergotree_get_constant(this.ptr, index);\n        return ret === 0 ? undefined : Constant.__wrap(ret);\n    }\n    /**\n    * Consumes the calling ErgoTree and returns new ErgoTree with a new constant value\n    * for a given index in constants list (as stored in serialized ErgoTree), or an error.\n    * After the call the calling ErgoTree will be null.\n    * @param {number} index\n    * @param {Constant} constant\n    * @returns {ErgoTree}\n    */\n    with_constant(index, constant) {\n        const ptr = this.__destroy_into_raw();\n        _assertClass(constant, Constant);\n        var ret = wasm.ergotree_with_constant(ptr, index, constant.ptr);\n        return ErgoTree.__wrap(ret);\n    }\n    /**\n    * Serialized proposition expression of SigmaProp type with\n    * ConstantPlaceholder nodes instead of Constant nodes\n    * @returns {Uint8Array}\n    */\n    template_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ergotree_template_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n* Extented public key implemented according to BIP-32\n*/\nexport class ExtPubKey {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ExtPubKey.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_extpubkey_free(ptr);\n    }\n    /**\n    * Create ExtPubKey from public key bytes (from SEC1 compressed), chain code and derivation\n    * path\n    * @param {Uint8Array} public_key_bytes\n    * @param {Uint8Array} chain_code\n    * @param {DerivationPath} derivation_path\n    * @returns {ExtPubKey}\n    */\n    static new(public_key_bytes, chain_code, derivation_path) {\n        var ptr0 = passArray8ToWasm0(public_key_bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ptr1 = passArray8ToWasm0(chain_code, wasm.__wbindgen_malloc);\n        var len1 = WASM_VECTOR_LEN;\n        _assertClass(derivation_path, DerivationPath);\n        var ret = wasm.extpubkey_new(ptr0, len0, ptr1, len1, derivation_path.ptr);\n        return ExtPubKey.__wrap(ret);\n    }\n    /**\n    * Soft derivation of the child public key with a given index\n    * index is expected to be a 31-bit value(32th bit should not be set)\n    * @param {number} index\n    * @returns {ExtPubKey}\n    */\n    child(index) {\n        var ret = wasm.extpubkey_child(this.ptr, index);\n        return ExtPubKey.__wrap(ret);\n    }\n    /**\n    * Derive a new extended pub key from the derivation path\n    * @param {DerivationPath} path\n    * @returns {ExtPubKey}\n    */\n    derive(path) {\n        _assertClass(path, DerivationPath);\n        var ptr0 = path.ptr;\n        path.ptr = 0;\n        var ret = wasm.extpubkey_derive(this.ptr, ptr0);\n        return ExtPubKey.__wrap(ret);\n    }\n    /**\n    * Create address (P2PK) from this extended public key\n    * @returns {Address}\n    */\n    to_address() {\n        var ret = wasm.extpubkey_to_address(this.ptr);\n        return Address.__wrap(ret);\n    }\n}\n/**\n* Extented secret key implemented according to BIP-32\n*/\nexport class ExtSecretKey {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ExtSecretKey.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_extsecretkey_free(ptr);\n    }\n    /**\n    * Create ExtSecretKey from secret key bytes, chain code and derivation path\n    * @param {Uint8Array} secret_key_bytes\n    * @param {Uint8Array} chain_code\n    * @param {DerivationPath} derivation_path\n    * @returns {ExtSecretKey}\n    */\n    static new(secret_key_bytes, chain_code, derivation_path) {\n        var ptr0 = passArray8ToWasm0(secret_key_bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ptr1 = passArray8ToWasm0(chain_code, wasm.__wbindgen_malloc);\n        var len1 = WASM_VECTOR_LEN;\n        _assertClass(derivation_path, DerivationPath);\n        var ret = wasm.extsecretkey_new(ptr0, len0, ptr1, len1, derivation_path.ptr);\n        return ExtSecretKey.__wrap(ret);\n    }\n    /**\n    * Derive root extended secret key\n    * @param {Uint8Array} seed_bytes\n    * @returns {ExtSecretKey}\n    */\n    static derive_master(seed_bytes) {\n        var ptr0 = passArray8ToWasm0(seed_bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.extsecretkey_derive_master(ptr0, len0);\n        return ExtSecretKey.__wrap(ret);\n    }\n    /**\n    * Derive a new extended secret key from the provided index\n    * The index is in the form of soft or hardened indices\n    * For example: 4 or 4' respectively\n    * @param {string} index\n    * @returns {ExtSecretKey}\n    */\n    child(index) {\n        var ptr0 = passStringToWasm0(index, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.extsecretkey_child(this.ptr, ptr0, len0);\n        return ExtSecretKey.__wrap(ret);\n    }\n    /**\n    * Derive a new extended secret key from the derivation path\n    * @param {DerivationPath} path\n    * @returns {ExtSecretKey}\n    */\n    derive(path) {\n        _assertClass(path, DerivationPath);\n        var ptr0 = path.ptr;\n        path.ptr = 0;\n        var ret = wasm.extsecretkey_derive(this.ptr, ptr0);\n        return ExtSecretKey.__wrap(ret);\n    }\n    /**\n    * The bytes of the associated secret key\n    * @returns {Uint8Array}\n    */\n    secret_key_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.extsecretkey_secret_key_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * The extended public key associated with this secret key\n    * @returns {ExtPubKey}\n    */\n    public_key() {\n        var ret = wasm.extsecretkey_public_key(this.ptr);\n        return ExtPubKey.__wrap(ret);\n    }\n    /**\n    * Derivation path associated with the ext secret key\n    * @returns {DerivationPath}\n    */\n    path() {\n        var ret = wasm.extsecretkey_path(this.ptr);\n        return DerivationPath.__wrap(ret);\n    }\n}\n/**\n* Wrapper for i64 for JS/TS\n*/\nexport class I64 {\n\n    static __wrap(ptr) {\n        const obj = Object.create(I64.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_i64_free(ptr);\n    }\n    /**\n    * Create from a standard rust string representation\n    * @param {string} string\n    * @returns {I64}\n    */\n    static from_str(string) {\n        var ptr0 = passStringToWasm0(string, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.i64_from_str(ptr0, len0);\n        return I64.__wrap(ret);\n    }\n    /**\n    * String representation of the value for use from environments that don't support i64\n    * @returns {string}\n    */\n    to_str() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.i64_to_str(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * Get the value as JS number (64-bit float)\n    * @returns {number}\n    */\n    as_num() {\n        var ret = wasm.i64_as_num(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * Addition with overflow check\n    * @param {I64} other\n    * @returns {I64}\n    */\n    checked_add(other) {\n        _assertClass(other, I64);\n        var ret = wasm.i64_checked_add(this.ptr, other.ptr);\n        return I64.__wrap(ret);\n    }\n}\n/**\n* Signed inputs used in signed transactions\n*/\nexport class Input {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Input.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_input_free(ptr);\n    }\n    /**\n    * Get box id\n    * @returns {BoxId}\n    */\n    box_id() {\n        var ret = wasm.input_box_id(this.ptr);\n        return BoxId.__wrap(ret);\n    }\n    /**\n    * Get the spending proof\n    * @returns {ProverResult}\n    */\n    spending_proof() {\n        var ret = wasm.input_spending_proof(this.ptr);\n        return ProverResult.__wrap(ret);\n    }\n}\n/**\n* Collection of signed inputs\n*/\nexport class Inputs {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Inputs.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_inputs_free(ptr);\n    }\n    /**\n    * Create empty Inputs\n    */\n    constructor() {\n        var ret = wasm.inputs_new();\n        return Inputs.__wrap(ret);\n    }\n    /**\n    * Returns the number of elements in the collection\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.inputs_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Returns the element of the collection with a given index\n    * @param {number} index\n    * @returns {Input}\n    */\n    get(index) {\n        var ret = wasm.inputs_get(this.ptr, index);\n        return Input.__wrap(ret);\n    }\n}\n/**\n* A level node in a merkle proof\n*/\nexport class LevelNode {\n\n    static __wrap(ptr) {\n        const obj = Object.create(LevelNode.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_levelnode_free(ptr);\n    }\n    /**\n    * Creates a new LevelNode from a 32 byte hash and side that the node belongs on in the tree. Fails if the digest is not 32 bytes\n    * @param {Uint8Array} hash\n    * @param {number} side\n    * @returns {LevelNode}\n    */\n    static new(hash, side) {\n        var ptr0 = passArray8ToWasm0(hash, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.levelnode_new(ptr0, len0, side);\n        return LevelNode.__wrap(ret);\n    }\n    /**\n    * Returns the associated digest (hash) with this node\n    * @returns {Uint8Array}\n    */\n    get digest() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.levelnode_digest(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Returns the associated side with this node (0 = Left, 1 = Right)\n    * @returns {number}\n    */\n    get side() {\n        var ret = wasm.levelnode_side(this.ptr);\n        return ret;\n    }\n}\n/**\n* A MerkleProof type. Given leaf data and levels (bottom-upwards), the root hash can be computed and validated\n*/\nexport class MerkleProof {\n\n    static __wrap(ptr) {\n        const obj = Object.create(MerkleProof.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_merkleproof_free(ptr);\n    }\n    /**\n    * Creates a new merkle proof with given leaf data and level data (bottom-upwards)\n    * You can verify it against a Blakeb256 root hash by using [`Self::valid()`]\n    * Add a node by using [`Self::add_node()`]\n    * Each digest on the level must be exactly 32 bytes\n    * @param {Uint8Array} leaf_data\n    * @returns {MerkleProof}\n    */\n    static new(leaf_data) {\n        var ptr0 = passArray8ToWasm0(leaf_data, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.merkleproof_new(ptr0, len0);\n        return MerkleProof.__wrap(ret);\n    }\n    /**\n    * Adds a new node to the MerkleProof above the current nodes\n    * @param {LevelNode} level\n    */\n    add_node(level) {\n        _assertClass(level, LevelNode);\n        wasm.merkleproof_add_node(this.ptr, level.ptr);\n    }\n    /**\n    * Validates the Merkle proof against the root hash\n    * @param {Uint8Array} expected_root\n    * @returns {boolean}\n    */\n    valid(expected_root) {\n        var ptr0 = passArray8ToWasm0(expected_root, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.merkleproof_valid(this.ptr, ptr0, len0);\n        return ret !== 0;\n    }\n}\n/**\n* helper methods to get the fee address for various networks\n*/\nexport class MinerAddress {\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_mineraddress_free(ptr);\n    }\n    /**\n    * address to use in mainnet for the fee\n    * @returns {string}\n    */\n    static mainnet_fee_address() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.mineraddress_mainnet_fee_address(retptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * address to use in testnet for the fee\n    * @returns {string}\n    */\n    static testnet_fee_address() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.mineraddress_testnet_fee_address(retptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n}\n/**\n* Mnemonic\n*/\nexport class Mnemonic {\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_mnemonic_free(ptr);\n    }\n    /**\n    * Convert a mnemonic phrase into a mnemonic seed\n    * mnemonic_pass is optional and is used to salt the seed\n    * @param {string} mnemonic_phrase\n    * @param {string} mnemonic_pass\n    * @returns {Uint8Array}\n    */\n    static to_seed(mnemonic_phrase, mnemonic_pass) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(mnemonic_phrase, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            var ptr1 = passStringToWasm0(mnemonic_pass, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len1 = WASM_VECTOR_LEN;\n            wasm.mnemonic_to_seed(retptr, ptr0, len0, ptr1, len1);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v2 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v2;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n* Combination of an Address with a network\n* These two combined together form a base58 encoding\n*/\nexport class NetworkAddress {\n\n    static __wrap(ptr) {\n        const obj = Object.create(NetworkAddress.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_networkaddress_free(ptr);\n    }\n    /**\n    * create a new NetworkAddress(address + network prefix) for a given network type\n    * @param {number} network\n    * @param {Address} address\n    * @returns {NetworkAddress}\n    */\n    static new(network, address) {\n        _assertClass(address, Address);\n        var ret = wasm.networkaddress_new(network, address.ptr);\n        return NetworkAddress.__wrap(ret);\n    }\n    /**\n    * Decode (base58) a NetworkAddress (address + network prefix) from string\n    * @param {string} s\n    * @returns {NetworkAddress}\n    */\n    static from_base58(s) {\n        var ptr0 = passStringToWasm0(s, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.networkaddress_from_base58(ptr0, len0);\n        return NetworkAddress.__wrap(ret);\n    }\n    /**\n    * Encode (base58) address\n    * @returns {string}\n    */\n    to_base58() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.networkaddress_to_base58(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * Decode from a serialized address\n    * @param {Uint8Array} data\n    * @returns {NetworkAddress}\n    */\n    static from_bytes(data) {\n        var ptr0 = passArray8ToWasm0(data, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.networkaddress_from_bytes(ptr0, len0);\n        return NetworkAddress.__wrap(ret);\n    }\n    /**\n    * Encode address as serialized bytes\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.networkaddress_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Network for the address\n    * @returns {number}\n    */\n    network() {\n        var ret = wasm.networkaddress_network(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Get address without network information\n    * @returns {Address}\n    */\n    address() {\n        var ret = wasm.networkaddress_address(this.ptr);\n        return Address.__wrap(ret);\n    }\n}\n/**\n* Node configuration\n*/\nexport class NodeConf {\n\n    static __wrap(ptr) {\n        const obj = Object.create(NodeConf.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_nodeconf_free(ptr);\n    }\n    /**\n    * Create a node configuration\n    * addr - a string in a format 'ip_address:port'\n    * @param {string} addr\n    */\n    constructor(addr) {\n        var ptr0 = passStringToWasm0(addr, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.nodeconf_new(ptr0, len0);\n        return NodeConf.__wrap(ret);\n    }\n}\n/**\n* Block header with the current `spendingTransaction`, that can be predicted\n* by a miner before it's formation\n*/\nexport class PreHeader {\n\n    static __wrap(ptr) {\n        const obj = Object.create(PreHeader.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_preheader_free(ptr);\n    }\n    /**\n    * Create using data from block header\n    * @param {BlockHeader} block_header\n    * @returns {PreHeader}\n    */\n    static from_block_header(block_header) {\n        _assertClass(block_header, BlockHeader);\n        var ptr0 = block_header.ptr;\n        block_header.ptr = 0;\n        var ret = wasm.preheader_from_block_header(ptr0);\n        return PreHeader.__wrap(ret);\n    }\n}\n/**\n* Proof of correctness of tx spending\n*/\nexport class ProverResult {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ProverResult.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_proverresult_free(ptr);\n    }\n    /**\n    * Get proof\n    * @returns {Uint8Array}\n    */\n    proof() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.proverresult_proof(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Get extension\n    * @returns {ContextExtension}\n    */\n    extension() {\n        var ret = wasm.proverresult_extension(this.ptr);\n        return ContextExtension.__wrap(ret);\n    }\n    /**\n    * JSON representation as text (compatible with Ergo Node/Explorer API, numbers are encoded as numbers)\n    * @returns {string}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.proverresult_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n}\n/**\n* Represent `reduced` transaction, i.e. unsigned transaction where each unsigned input\n* is augmented with ReducedInput which contains a script reduction result.\n* After an unsigned transaction is reduced it can be signed without context.\n* Thus, it can be serialized and transferred for example to Cold Wallet and signed\n* in an environment where secrets are known.\n* see EIP-19 for more details -\n* <https://github.com/ergoplatform/eips/blob/f280890a4163f2f2e988a0091c078e36912fc531/eip-0019.md>\n*/\nexport class ReducedTransaction {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ReducedTransaction.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_reducedtransaction_free(ptr);\n    }\n    /**\n    * Returns `reduced` transaction, i.e. unsigned transaction where each unsigned input\n    * is augmented with ReducedInput which contains a script reduction result.\n    * @param {UnsignedTransaction} unsigned_tx\n    * @param {ErgoBoxes} boxes_to_spend\n    * @param {ErgoBoxes} data_boxes\n    * @param {ErgoStateContext} state_context\n    * @returns {ReducedTransaction}\n    */\n    static from_unsigned_tx(unsigned_tx, boxes_to_spend, data_boxes, state_context) {\n        _assertClass(unsigned_tx, UnsignedTransaction);\n        _assertClass(boxes_to_spend, ErgoBoxes);\n        _assertClass(data_boxes, ErgoBoxes);\n        _assertClass(state_context, ErgoStateContext);\n        var ret = wasm.reducedtransaction_from_unsigned_tx(unsigned_tx.ptr, boxes_to_spend.ptr, data_boxes.ptr, state_context.ptr);\n        return ReducedTransaction.__wrap(ret);\n    }\n    /**\n    * Returns serialized bytes or fails with error if cannot be serialized\n    * @returns {Uint8Array}\n    */\n    sigma_serialize_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.reducedtransaction_sigma_serialize_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Parses ReducedTransaction or fails with error\n    * @param {Uint8Array} data\n    * @returns {ReducedTransaction}\n    */\n    static sigma_parse_bytes(data) {\n        var ptr0 = passArray8ToWasm0(data, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.reducedtransaction_sigma_parse_bytes(ptr0, len0);\n        return ReducedTransaction.__wrap(ret);\n    }\n    /**\n    * Returns the unsigned transation\n    * @returns {UnsignedTransaction}\n    */\n    unsigned_tx() {\n        var ret = wasm.reducedtransaction_unsigned_tx(this.ptr);\n        return UnsignedTransaction.__wrap(ret);\n    }\n}\n/**\n* Secret key for the prover\n*/\nexport class SecretKey {\n\n    static __wrap(ptr) {\n        const obj = Object.create(SecretKey.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_secretkey_free(ptr);\n    }\n    /**\n    * generate random key\n    * @returns {SecretKey}\n    */\n    static random_dlog() {\n        var ret = wasm.secretkey_random_dlog();\n        return SecretKey.__wrap(ret);\n    }\n    /**\n    * Parse dlog secret key from bytes (SEC-1-encoded scalar)\n    * @param {Uint8Array} bytes\n    * @returns {SecretKey}\n    */\n    static dlog_from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.secretkey_dlog_from_bytes(ptr0, len0);\n        return SecretKey.__wrap(ret);\n    }\n    /**\n    * Address (encoded public image)\n    * @returns {Address}\n    */\n    get_address() {\n        var ret = wasm.secretkey_get_address(this.ptr);\n        return Address.__wrap(ret);\n    }\n    /**\n    * Encode from a serialized key\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.secretkey_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n* SecretKey collection\n*/\nexport class SecretKeys {\n\n    static __wrap(ptr) {\n        const obj = Object.create(SecretKeys.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_secretkeys_free(ptr);\n    }\n    /**\n    * Create empty SecretKeys\n    */\n    constructor() {\n        var ret = wasm.secretkeys_new();\n        return SecretKeys.__wrap(ret);\n    }\n    /**\n    * Returns the number of elements in the collection\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.secretkeys_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Returns the element of the collection with a given index\n    * @param {number} index\n    * @returns {SecretKey}\n    */\n    get(index) {\n        var ret = wasm.secretkeys_get(this.ptr, index);\n        return SecretKey.__wrap(ret);\n    }\n    /**\n    * Adds an elements to the collection\n    * @param {SecretKey} elem\n    */\n    add(elem) {\n        _assertClass(elem, SecretKey);\n        wasm.secretkeys_add(this.ptr, elem.ptr);\n    }\n}\n/**\n* Naive box selector, collects inputs until target balance is reached\n*/\nexport class SimpleBoxSelector {\n\n    static __wrap(ptr) {\n        const obj = Object.create(SimpleBoxSelector.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_simpleboxselector_free(ptr);\n    }\n    /**\n    * Create empty SimpleBoxSelector\n    */\n    constructor() {\n        var ret = wasm.simpleboxselector_new();\n        return SimpleBoxSelector.__wrap(ret);\n    }\n    /**\n    * Selects inputs to satisfy target balance and tokens.\n    * `inputs` - available inputs (returns an error, if empty),\n    * `target_balance` - coins (in nanoERGs) needed,\n    * `target_tokens` - amount of tokens needed.\n    * Returns selected inputs and box assets(value+tokens) with change.\n    * @param {ErgoBoxes} inputs\n    * @param {BoxValue} target_balance\n    * @param {Tokens} target_tokens\n    * @returns {BoxSelection}\n    */\n    select(inputs, target_balance, target_tokens) {\n        _assertClass(inputs, ErgoBoxes);\n        _assertClass(target_balance, BoxValue);\n        _assertClass(target_tokens, Tokens);\n        var ret = wasm.simpleboxselector_select(this.ptr, inputs.ptr, target_balance.ptr, target_tokens.ptr);\n        return BoxSelection.__wrap(ret);\n    }\n}\n/**\n* Token represented with token id paired with it's amount\n*/\nexport class Token {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Token.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_token_free(ptr);\n    }\n    /**\n    * Create a token with given token id and amount\n    * @param {TokenId} token_id\n    * @param {TokenAmount} amount\n    */\n    constructor(token_id, amount) {\n        _assertClass(token_id, TokenId);\n        _assertClass(amount, TokenAmount);\n        var ret = wasm.token_new(token_id.ptr, amount.ptr);\n        return Token.__wrap(ret);\n    }\n    /**\n    * Get token id\n    * @returns {TokenId}\n    */\n    id() {\n        var ret = wasm.token_id(this.ptr);\n        return TokenId.__wrap(ret);\n    }\n    /**\n    * Get token amount\n    * @returns {TokenAmount}\n    */\n    amount() {\n        var ret = wasm.token_amount(this.ptr);\n        return TokenAmount.__wrap(ret);\n    }\n    /**\n    * JSON representation as text (compatible with Ergo Node/Explorer API, numbers are encoded as numbers)\n    * @returns {string}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.token_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * JSON representation according to EIP-12 <https://github.com/ergoplatform/eips/pull/23>\n    * (similar to [`Self::to_json`], but as JS object with token amount encoding as string)\n    * @returns {any}\n    */\n    to_js_eip12() {\n        var ret = wasm.token_to_js_eip12(this.ptr);\n        return takeObject(ret);\n    }\n}\n/**\n* Token amount with bound checks\n*/\nexport class TokenAmount {\n\n    static __wrap(ptr) {\n        const obj = Object.create(TokenAmount.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_tokenamount_free(ptr);\n    }\n    /**\n    * Create from i64 with bounds check\n    * @param {I64} v\n    * @returns {TokenAmount}\n    */\n    static from_i64(v) {\n        _assertClass(v, I64);\n        var ret = wasm.tokenamount_from_i64(v.ptr);\n        return TokenAmount.__wrap(ret);\n    }\n    /**\n    * Get value as signed 64-bit long (I64)\n    * @returns {I64}\n    */\n    as_i64() {\n        var ret = wasm.tokenamount_as_i64(this.ptr);\n        return I64.__wrap(ret);\n    }\n    /**\n    * big-endian byte array representation\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.tokenamount_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n* Token id (32 byte digest)\n*/\nexport class TokenId {\n\n    static __wrap(ptr) {\n        const obj = Object.create(TokenId.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_tokenid_free(ptr);\n    }\n    /**\n    * Create token id from ergo box id (32 byte digest)\n    * @param {BoxId} box_id\n    * @returns {TokenId}\n    */\n    static from_box_id(box_id) {\n        _assertClass(box_id, BoxId);\n        var ret = wasm.tokenid_from_box_id(box_id.ptr);\n        return TokenId.__wrap(ret);\n    }\n    /**\n    * Parse token id (32 byte digest) from base16-encoded string\n    * @param {string} str\n    * @returns {TokenId}\n    */\n    static from_str(str) {\n        var ptr0 = passStringToWasm0(str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.tokenid_from_str(ptr0, len0);\n        return TokenId.__wrap(ret);\n    }\n    /**\n    * Base16 encoded string\n    * @returns {string}\n    */\n    to_str() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.tokenid_to_str(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * Returns byte array (32 bytes)\n    * @returns {Uint8Array}\n    */\n    as_bytes() {\n        var ret = wasm.tokenid_as_bytes(this.ptr);\n        return takeObject(ret);\n    }\n}\n/**\n* Array of tokens\n*/\nexport class Tokens {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Tokens.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_tokens_free(ptr);\n    }\n    /**\n    * Create empty Tokens\n    */\n    constructor() {\n        var ret = wasm.tokens_new();\n        return Tokens.__wrap(ret);\n    }\n    /**\n    * Returns the number of elements in the collection\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.tokens_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Returns the element of the collection with a given index\n    * @param {number} index\n    * @returns {Token}\n    */\n    get(index) {\n        var ret = wasm.tokens_get(this.ptr, index);\n        return Token.__wrap(ret);\n    }\n    /**\n    * Adds an elements to the collection\n    * @param {Token} elem\n    */\n    add(elem) {\n        _assertClass(elem, Token);\n        wasm.tokens_add(this.ptr, elem.ptr);\n    }\n}\n/**\n*\n* * ErgoTransaction is an atomic state transition operation. It destroys Boxes from the state\n* * and creates new ones. If transaction is spending boxes protected by some non-trivial scripts,\n* * its inputs should also contain proof of spending correctness - context extension (user-defined\n* * key-value map) and data inputs (links to existing boxes in the state) that may be used during\n* * script reduction to crypto, signatures that satisfies the remaining cryptographic protection\n* * of the script.\n* * Transactions are not encrypted, so it is possible to browse and view every transaction ever\n* * collected into a block.\n*\n*/\nexport class Transaction {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Transaction.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transaction_free(ptr);\n    }\n    /**\n    * Create Transaction from UnsignedTransaction and an array of proofs in the same order as\n    * UnsignedTransaction.inputs with empty proof indicated with empty byte array\n    * @param {UnsignedTransaction} unsigned_tx\n    * @param {(Uint8Array)[]} proofs\n    * @returns {Transaction}\n    */\n    static from_unsigned_tx(unsigned_tx, proofs) {\n        _assertClass(unsigned_tx, UnsignedTransaction);\n        var ptr0 = unsigned_tx.ptr;\n        unsigned_tx.ptr = 0;\n        var ptr1 = passArrayJsValueToWasm0(proofs, wasm.__wbindgen_malloc);\n        var len1 = WASM_VECTOR_LEN;\n        var ret = wasm.transaction_from_unsigned_tx(ptr0, ptr1, len1);\n        return Transaction.__wrap(ret);\n    }\n    /**\n    * Get id for transaction\n    * @returns {TxId}\n    */\n    id() {\n        var ret = wasm.transaction_id(this.ptr);\n        return TxId.__wrap(ret);\n    }\n    /**\n    * JSON representation as text (compatible with Ergo Node/Explorer API, numbers are encoded as numbers)\n    * @returns {string}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transaction_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * JSON representation according to EIP-12 <https://github.com/ergoplatform/eips/pull/23>\n    * (similar to [`Self::to_json`], but as JS object with box value and token amount encoding as strings)\n    * @returns {any}\n    */\n    to_js_eip12() {\n        var ret = wasm.transaction_to_js_eip12(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * parse from JSON\n    * supports Ergo Node/Explorer API and box values and token amount encoded as strings\n    * @param {string} json\n    * @returns {Transaction}\n    */\n    static from_json(json) {\n        var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.transaction_from_json(ptr0, len0);\n        return Transaction.__wrap(ret);\n    }\n    /**\n    * Inputs for transaction\n    * @returns {Inputs}\n    */\n    inputs() {\n        var ret = wasm.transaction_inputs(this.ptr);\n        return Inputs.__wrap(ret);\n    }\n    /**\n    * Data inputs for transaction\n    * @returns {DataInputs}\n    */\n    data_inputs() {\n        var ret = wasm.transaction_data_inputs(this.ptr);\n        return DataInputs.__wrap(ret);\n    }\n    /**\n    * Output candidates for transaction\n    * @returns {ErgoBoxCandidates}\n    */\n    output_candidates() {\n        var ret = wasm.transaction_output_candidates(this.ptr);\n        return ErgoBoxCandidates.__wrap(ret);\n    }\n    /**\n    * Returns ErgoBox's created from ErgoBoxCandidate's with tx id and indices\n    * @returns {ErgoBoxes}\n    */\n    outputs() {\n        var ret = wasm.transaction_outputs(this.ptr);\n        return ErgoBoxes.__wrap(ret);\n    }\n    /**\n    * Returns serialized bytes or fails with error if cannot be serialized\n    * @returns {Uint8Array}\n    */\n    sigma_serialize_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transaction_sigma_serialize_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Parses Transaction or fails with error\n    * @param {Uint8Array} data\n    * @returns {Transaction}\n    */\n    static sigma_parse_bytes(data) {\n        var ptr0 = passArray8ToWasm0(data, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.transaction_sigma_parse_bytes(ptr0, len0);\n        return Transaction.__wrap(ret);\n    }\n}\n/**\n* Unsigned transaction builder\n*/\nexport class TxBuilder {\n\n    static __wrap(ptr) {\n        const obj = Object.create(TxBuilder.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_txbuilder_free(ptr);\n    }\n    /**\n    * Suggested transaction fee (semi-default value used across wallets and dApps as of Oct 2020)\n    * @returns {BoxValue}\n    */\n    static SUGGESTED_TX_FEE() {\n        var ret = wasm.txbuilder_SUGGESTED_TX_FEE();\n        return BoxValue.__wrap(ret);\n    }\n    /**\n    * Creates new TxBuilder\n    * `box_selection` - selected input boxes (via [`super::box_selector`])\n    * `output_candidates` - output boxes to be \"created\" in this transaction,\n    * `current_height` - chain height that will be used in additionally created boxes (change, miner's fee, etc.),\n    * `fee_amount` - miner's fee,\n    * `change_address` - change (inputs - outputs) will be sent to this address,\n    * `min_change_value` - minimal value of the change to be sent to `change_address`, value less than that\n    * will be given to miners,\n    * @param {BoxSelection} box_selection\n    * @param {ErgoBoxCandidates} output_candidates\n    * @param {number} current_height\n    * @param {BoxValue} fee_amount\n    * @param {Address} change_address\n    * @param {BoxValue} min_change_value\n    * @returns {TxBuilder}\n    */\n    static new(box_selection, output_candidates, current_height, fee_amount, change_address, min_change_value) {\n        _assertClass(box_selection, BoxSelection);\n        _assertClass(output_candidates, ErgoBoxCandidates);\n        _assertClass(fee_amount, BoxValue);\n        _assertClass(change_address, Address);\n        _assertClass(min_change_value, BoxValue);\n        var ret = wasm.txbuilder_new(box_selection.ptr, output_candidates.ptr, current_height, fee_amount.ptr, change_address.ptr, min_change_value.ptr);\n        return TxBuilder.__wrap(ret);\n    }\n    /**\n    * Set transaction's data inputs\n    * @param {DataInputs} data_inputs\n    */\n    set_data_inputs(data_inputs) {\n        _assertClass(data_inputs, DataInputs);\n        wasm.txbuilder_set_data_inputs(this.ptr, data_inputs.ptr);\n    }\n    /**\n    * Build the unsigned transaction\n    * @returns {UnsignedTransaction}\n    */\n    build() {\n        var ret = wasm.txbuilder_build(this.ptr);\n        return UnsignedTransaction.__wrap(ret);\n    }\n    /**\n    * Get box selection\n    * @returns {BoxSelection}\n    */\n    box_selection() {\n        var ret = wasm.txbuilder_box_selection(this.ptr);\n        return BoxSelection.__wrap(ret);\n    }\n    /**\n    * Get data inputs\n    * @returns {DataInputs}\n    */\n    data_inputs() {\n        var ret = wasm.txbuilder_data_inputs(this.ptr);\n        return DataInputs.__wrap(ret);\n    }\n    /**\n    * Get outputs EXCLUDING fee and change\n    * @returns {ErgoBoxCandidates}\n    */\n    output_candidates() {\n        var ret = wasm.txbuilder_output_candidates(this.ptr);\n        return ErgoBoxCandidates.__wrap(ret);\n    }\n    /**\n    * Get current height\n    * @returns {number}\n    */\n    current_height() {\n        var ret = wasm.txbuilder_current_height(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Get fee amount\n    * @returns {BoxValue}\n    */\n    fee_amount() {\n        var ret = wasm.txbuilder_fee_amount(this.ptr);\n        return BoxValue.__wrap(ret);\n    }\n    /**\n    * Get change address\n    * @returns {Address}\n    */\n    change_address() {\n        var ret = wasm.txbuilder_change_address(this.ptr);\n        return Address.__wrap(ret);\n    }\n    /**\n    * Get min change value\n    * @returns {BoxValue}\n    */\n    min_change_value() {\n        var ret = wasm.txbuilder_min_change_value(this.ptr);\n        return BoxValue.__wrap(ret);\n    }\n}\n/**\n* Transaction id\n*/\nexport class TxId {\n\n    static __wrap(ptr) {\n        const obj = Object.create(TxId.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_txid_free(ptr);\n    }\n    /**\n    * Zero (empty) transaction id (to use as dummy value in tests)\n    * @returns {TxId}\n    */\n    static zero() {\n        var ret = wasm.txid_zero();\n        return TxId.__wrap(ret);\n    }\n    /**\n    * get the tx id as bytes\n    * @returns {string}\n    */\n    to_str() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.txid_to_str(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * convert a hex string into a TxId\n    * @param {string} s\n    * @returns {TxId}\n    */\n    static from_str(s) {\n        var ptr0 = passStringToWasm0(s, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.txid_from_str(ptr0, len0);\n        return TxId.__wrap(ret);\n    }\n}\n/**\n* Unsigned inputs used in constructing unsigned transactions\n*/\nexport class UnsignedInput {\n\n    static __wrap(ptr) {\n        const obj = Object.create(UnsignedInput.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_unsignedinput_free(ptr);\n    }\n    /**\n    * Create new unsigned input instance from box id and extension\n    * @param {BoxId} box_id\n    * @param {ContextExtension} ext\n    */\n    constructor(box_id, ext) {\n        _assertClass(box_id, BoxId);\n        _assertClass(ext, ContextExtension);\n        var ret = wasm.unsignedinput_new(box_id.ptr, ext.ptr);\n        return UnsignedInput.__wrap(ret);\n    }\n    /**\n    * Create a new unsigned input from the provided box id\n    * using an empty context extension\n    * @param {BoxId} box_id\n    * @returns {UnsignedInput}\n    */\n    static from_box_id(box_id) {\n        _assertClass(box_id, BoxId);\n        var ret = wasm.unsignedinput_from_box_id(box_id.ptr);\n        return UnsignedInput.__wrap(ret);\n    }\n    /**\n    * Get box id\n    * @returns {BoxId}\n    */\n    box_id() {\n        var ret = wasm.unsignedinput_box_id(this.ptr);\n        return BoxId.__wrap(ret);\n    }\n    /**\n    * Get extension\n    * @returns {ContextExtension}\n    */\n    extension() {\n        var ret = wasm.unsignedinput_extension(this.ptr);\n        return ContextExtension.__wrap(ret);\n    }\n}\n/**\n* Collection of unsigned signed inputs\n*/\nexport class UnsignedInputs {\n\n    static __wrap(ptr) {\n        const obj = Object.create(UnsignedInputs.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_unsignedinputs_free(ptr);\n    }\n    /**\n    * Create empty UnsignedInputs\n    */\n    constructor() {\n        var ret = wasm.unsignedinputs_new();\n        return UnsignedInputs.__wrap(ret);\n    }\n    /**\n    * Returns the number of elements in the collection\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.unsignedinputs_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Returns the element of the collection with a given index\n    * @param {number} index\n    * @returns {UnsignedInput}\n    */\n    get(index) {\n        var ret = wasm.unsignedinputs_get(this.ptr, index);\n        return UnsignedInput.__wrap(ret);\n    }\n    /**\n    * Add an element to the collection\n    * @param {UnsignedInput} b\n    */\n    add(b) {\n        _assertClass(b, UnsignedInput);\n        wasm.unsignedinputs_add(this.ptr, b.ptr);\n    }\n}\n/**\n* Unsigned (inputs without proofs) transaction\n*/\nexport class UnsignedTransaction {\n\n    static __wrap(ptr) {\n        const obj = Object.create(UnsignedTransaction.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_unsignedtransaction_free(ptr);\n    }\n    /**\n    * Create a new unsigned transaction\n    * @param {UnsignedInputs} inputs\n    * @param {DataInputs} data_inputs\n    * @param {ErgoBoxCandidates} output_candidates\n    */\n    constructor(inputs, data_inputs, output_candidates) {\n        _assertClass(inputs, UnsignedInputs);\n        _assertClass(data_inputs, DataInputs);\n        _assertClass(output_candidates, ErgoBoxCandidates);\n        var ret = wasm.unsignedtransaction_new(inputs.ptr, data_inputs.ptr, output_candidates.ptr);\n        return UnsignedTransaction.__wrap(ret);\n    }\n    /**\n    * Consumes the calling UnsignedTransaction and returns a new UnsignedTransaction containing\n    * the ContextExtension in the provided input box id or returns an error if the input box cannot be found.\n    * After the call the calling UnsignedTransaction will be null.\n    * @param {BoxId} input_id\n    * @param {ContextExtension} ext\n    * @returns {UnsignedTransaction}\n    */\n    with_input_context_ext(input_id, ext) {\n        const ptr = this.__destroy_into_raw();\n        _assertClass(input_id, BoxId);\n        _assertClass(ext, ContextExtension);\n        var ret = wasm.unsignedtransaction_with_input_context_ext(ptr, input_id.ptr, ext.ptr);\n        return UnsignedTransaction.__wrap(ret);\n    }\n    /**\n    * Get id for transaction\n    * @returns {TxId}\n    */\n    id() {\n        var ret = wasm.unsignedtransaction_id(this.ptr);\n        return TxId.__wrap(ret);\n    }\n    /**\n    * Inputs for transaction\n    * @returns {UnsignedInputs}\n    */\n    inputs() {\n        var ret = wasm.unsignedtransaction_inputs(this.ptr);\n        return UnsignedInputs.__wrap(ret);\n    }\n    /**\n    * Data inputs for transaction\n    * @returns {DataInputs}\n    */\n    data_inputs() {\n        var ret = wasm.unsignedtransaction_data_inputs(this.ptr);\n        return DataInputs.__wrap(ret);\n    }\n    /**\n    * Output candidates for transaction\n    * @returns {ErgoBoxCandidates}\n    */\n    output_candidates() {\n        var ret = wasm.unsignedtransaction_output_candidates(this.ptr);\n        return ErgoBoxCandidates.__wrap(ret);\n    }\n    /**\n    * JSON representation as text (compatible with Ergo Node/Explorer API, numbers are encoded as numbers)\n    * @returns {string}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.unsignedtransaction_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * JSON representation according to EIP-12 <https://github.com/ergoplatform/eips/pull/23>\n    * (similar to [`Self::to_json`], but as JS object with box value and token amount encoding as strings)\n    * @returns {any}\n    */\n    to_js_eip12() {\n        var ret = wasm.unsignedtransaction_to_js_eip12(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * parse from JSON\n    * supports Ergo Node/Explorer API and box values and token amount encoded as strings\n    * @param {string} json\n    * @returns {UnsignedTransaction}\n    */\n    static from_json(json) {\n        var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.unsignedtransaction_from_json(ptr0, len0);\n        return UnsignedTransaction.__wrap(ret);\n    }\n    /**\n    * Returns distinct token id from output_candidates as array of byte arrays\n    * @returns {(Uint8Array)[]}\n    */\n    distinct_token_ids() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.unsignedtransaction_distinct_token_ids(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 4);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n* A collection of secret keys. This simplified signing by matching the secret keys to the correct inputs automatically.\n*/\nexport class Wallet {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Wallet.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_wallet_free(ptr);\n    }\n    /**\n    * Create wallet instance loading secret key from mnemonic\n    * Returns None if a DlogSecretKey cannot be parsed from the provided phrase\n    * @param {string} mnemonic_phrase\n    * @param {string} mnemonic_pass\n    * @returns {Wallet | undefined}\n    */\n    static from_mnemonic(mnemonic_phrase, mnemonic_pass) {\n        var ptr0 = passStringToWasm0(mnemonic_phrase, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ptr1 = passStringToWasm0(mnemonic_pass, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len1 = WASM_VECTOR_LEN;\n        var ret = wasm.wallet_from_mnemonic(ptr0, len0, ptr1, len1);\n        return ret === 0 ? undefined : Wallet.__wrap(ret);\n    }\n    /**\n    * Create wallet using provided secret key\n    * @param {SecretKeys} secret\n    * @returns {Wallet}\n    */\n    static from_secrets(secret) {\n        _assertClass(secret, SecretKeys);\n        var ret = wasm.wallet_from_secrets(secret.ptr);\n        return Wallet.__wrap(ret);\n    }\n    /**\n    * Add a secret to the wallets prover\n    * @param {SecretKey} secret\n    */\n    add_secret(secret) {\n        _assertClass(secret, SecretKey);\n        wasm.wallet_add_secret(this.ptr, secret.ptr);\n    }\n    /**\n    * Sign a transaction:\n    * `tx` - transaction to sign\n    * `boxes_to_spend` - boxes corresponding to [`UnsignedTransaction::inputs`]\n    * `data_boxes` - boxes corresponding to [`UnsignedTransaction::data_inputs`]\n    * @param {ErgoStateContext} _state_context\n    * @param {UnsignedTransaction} tx\n    * @param {ErgoBoxes} boxes_to_spend\n    * @param {ErgoBoxes} data_boxes\n    * @returns {Transaction}\n    */\n    sign_transaction(_state_context, tx, boxes_to_spend, data_boxes) {\n        _assertClass(_state_context, ErgoStateContext);\n        _assertClass(tx, UnsignedTransaction);\n        _assertClass(boxes_to_spend, ErgoBoxes);\n        _assertClass(data_boxes, ErgoBoxes);\n        var ret = wasm.wallet_sign_transaction(this.ptr, _state_context.ptr, tx.ptr, boxes_to_spend.ptr, data_boxes.ptr);\n        return Transaction.__wrap(ret);\n    }\n    /**\n    * Sign a transaction:\n    * `reduced_tx` - reduced transaction, i.e. unsigned transaction where for each unsigned input\n    * added a script reduction result.\n    * @param {ReducedTransaction} reduced_tx\n    * @returns {Transaction}\n    */\n    sign_reduced_transaction(reduced_tx) {\n        _assertClass(reduced_tx, ReducedTransaction);\n        var ret = wasm.wallet_sign_reduced_transaction(this.ptr, reduced_tx.ptr);\n        return Transaction.__wrap(ret);\n    }\n}\n\nexport function __wbindgen_object_drop_ref(arg0) {\n    takeObject(arg0);\n};\n\nexport function __wbindgen_string_new(arg0, arg1) {\n    var ret = getStringFromWasm0(arg0, arg1);\n    return addHeapObject(ret);\n};\n\nexport function __wbindgen_is_string(arg0) {\n    var ret = typeof(getObject(arg0)) === 'string';\n    return ret;\n};\n\nexport function __wbindgen_string_get(arg0, arg1) {\n    const obj = getObject(arg1);\n    var ret = typeof(obj) === 'string' ? obj : undefined;\n    var ptr0 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    var len0 = WASM_VECTOR_LEN;\n    getInt32Memory0()[arg0 / 4 + 1] = len0;\n    getInt32Memory0()[arg0 / 4 + 0] = ptr0;\n};\n\nexport function __wbindgen_json_parse(arg0, arg1) {\n    var ret = JSON.parse(getStringFromWasm0(arg0, arg1));\n    return addHeapObject(ret);\n};\n\nexport function __wbindgen_json_serialize(arg0, arg1) {\n    const obj = getObject(arg1);\n    var ret = JSON.stringify(obj === undefined ? null : obj);\n    var ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    var len0 = WASM_VECTOR_LEN;\n    getInt32Memory0()[arg0 / 4 + 1] = len0;\n    getInt32Memory0()[arg0 / 4 + 0] = ptr0;\n};\n\nexport function __wbindgen_number_new(arg0) {\n    var ret = arg0;\n    return addHeapObject(ret);\n};\n\nexport function __wbindgen_object_clone_ref(arg0) {\n    var ret = getObject(arg0);\n    return addHeapObject(ret);\n};\n\nexport function __wbg_fetch_fb26f738d9707b16(arg0) {\n    var ret = fetch(getObject(arg0));\n    return addHeapObject(ret);\n};\n\nexport function __wbindgen_cb_drop(arg0) {\n    const obj = takeObject(arg0).original;\n    if (obj.cnt-- == 1) {\n        obj.a = 0;\n        return true;\n    }\n    var ret = false;\n    return ret;\n};\n\nexport function __wbg_fetch_b4e81012e07ff95a(arg0, arg1) {\n    var ret = getObject(arg0).fetch(getObject(arg1));\n    return addHeapObject(ret);\n};\n\nexport function __wbg_new_9c35e8e8b09fb4a3() { return handleError(function () {\n    var ret = new Headers();\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_append_fb85316567f7a798() { return handleError(function (arg0, arg1, arg2, arg3, arg4) {\n    getObject(arg0).append(getStringFromWasm0(arg1, arg2), getStringFromWasm0(arg3, arg4));\n}, arguments) };\n\nexport function __wbg_instanceof_Response_e1b11afbefa5b563(arg0) {\n    var ret = getObject(arg0) instanceof Response;\n    return ret;\n};\n\nexport function __wbg_url_50e0bdb6051741be(arg0, arg1) {\n    var ret = getObject(arg1).url;\n    var ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    var len0 = WASM_VECTOR_LEN;\n    getInt32Memory0()[arg0 / 4 + 1] = len0;\n    getInt32Memory0()[arg0 / 4 + 0] = ptr0;\n};\n\nexport function __wbg_status_6d8bb444ddc5a7b2(arg0) {\n    var ret = getObject(arg0).status;\n    return ret;\n};\n\nexport function __wbg_headers_5ffa990806e04cfc(arg0) {\n    var ret = getObject(arg0).headers;\n    return addHeapObject(ret);\n};\n\nexport function __wbg_arrayBuffer_b8937ed04beb0d36() { return handleError(function (arg0) {\n    var ret = getObject(arg0).arrayBuffer();\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_newwithstrandinit_9b0fa00478c37287() { return handleError(function (arg0, arg1, arg2) {\n    var ret = new Request(getStringFromWasm0(arg0, arg1), getObject(arg2));\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_getRandomValues_98117e9a7e993920() { return handleError(function (arg0, arg1) {\n    getObject(arg0).getRandomValues(getObject(arg1));\n}, arguments) };\n\nexport function __wbg_randomFillSync_64cc7d048f228ca8() { return handleError(function (arg0, arg1, arg2) {\n    getObject(arg0).randomFillSync(getArrayU8FromWasm0(arg1, arg2));\n}, arguments) };\n\nexport function __wbg_process_2f24d6544ea7b200(arg0) {\n    var ret = getObject(arg0).process;\n    return addHeapObject(ret);\n};\n\nexport function __wbindgen_is_object(arg0) {\n    const val = getObject(arg0);\n    var ret = typeof(val) === 'object' && val !== null;\n    return ret;\n};\n\nexport function __wbg_versions_6164651e75405d4a(arg0) {\n    var ret = getObject(arg0).versions;\n    return addHeapObject(ret);\n};\n\nexport function __wbg_node_4b517d861cbcb3bc(arg0) {\n    var ret = getObject(arg0).node;\n    return addHeapObject(ret);\n};\n\nexport function __wbg_modulerequire_3440a4bcf44437db() { return handleError(function (arg0, arg1) {\n    var ret = module.require(getStringFromWasm0(arg0, arg1));\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_crypto_98fc271021c7d2ad(arg0) {\n    var ret = getObject(arg0).crypto;\n    return addHeapObject(ret);\n};\n\nexport function __wbg_msCrypto_a2cdb043d2bfe57f(arg0) {\n    var ret = getObject(arg0).msCrypto;\n    return addHeapObject(ret);\n};\n\nexport function __wbindgen_is_function(arg0) {\n    var ret = typeof(getObject(arg0)) === 'function';\n    return ret;\n};\n\nexport function __wbg_newnoargs_be86524d73f67598(arg0, arg1) {\n    var ret = new Function(getStringFromWasm0(arg0, arg1));\n    return addHeapObject(ret);\n};\n\nexport function __wbg_next_c4151d46d5fa7097(arg0) {\n    var ret = getObject(arg0).next;\n    return addHeapObject(ret);\n};\n\nexport function __wbg_next_7720502039b96d00() { return handleError(function (arg0) {\n    var ret = getObject(arg0).next();\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_done_b06cf0578e89ff68(arg0) {\n    var ret = getObject(arg0).done;\n    return ret;\n};\n\nexport function __wbg_value_e74a542443d92451(arg0) {\n    var ret = getObject(arg0).value;\n    return addHeapObject(ret);\n};\n\nexport function __wbg_iterator_4fc4ce93e6b92958() {\n    var ret = Symbol.iterator;\n    return addHeapObject(ret);\n};\n\nexport function __wbg_get_4d0f21c2f823742e() { return handleError(function (arg0, arg1) {\n    var ret = Reflect.get(getObject(arg0), getObject(arg1));\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_call_888d259a5fefc347() { return handleError(function (arg0, arg1) {\n    var ret = getObject(arg0).call(getObject(arg1));\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_new_0b83d3df67ecb33e() {\n    var ret = new Object();\n    return addHeapObject(ret);\n};\n\nexport function __wbg_new_342a24ca698edd87(arg0, arg1) {\n    var ret = new Error(getStringFromWasm0(arg0, arg1));\n    return addHeapObject(ret);\n};\n\nexport function __wbg_call_346669c262382ad7() { return handleError(function (arg0, arg1, arg2) {\n    var ret = getObject(arg0).call(getObject(arg1), getObject(arg2));\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_new_b1d61b5687f5e73a(arg0, arg1) {\n    try {\n        var state0 = {a: arg0, b: arg1};\n        var cb0 = (arg0, arg1) => {\n            const a = state0.a;\n            state0.a = 0;\n            try {\n                return __wbg_adapter_347(a, state0.b, arg0, arg1);\n            } finally {\n                state0.a = a;\n            }\n        };\n        var ret = new Promise(cb0);\n        return addHeapObject(ret);\n    } finally {\n        state0.a = state0.b = 0;\n    }\n};\n\nexport function __wbg_resolve_d23068002f584f22(arg0) {\n    var ret = Promise.resolve(getObject(arg0));\n    return addHeapObject(ret);\n};\n\nexport function __wbg_then_2fcac196782070cc(arg0, arg1) {\n    var ret = getObject(arg0).then(getObject(arg1));\n    return addHeapObject(ret);\n};\n\nexport function __wbg_then_8c2d62e8ae5978f7(arg0, arg1, arg2) {\n    var ret = getObject(arg0).then(getObject(arg1), getObject(arg2));\n    return addHeapObject(ret);\n};\n\nexport function __wbg_self_c6fbdfc2918d5e58() { return handleError(function () {\n    var ret = self.self;\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_window_baec038b5ab35c54() { return handleError(function () {\n    var ret = window.window;\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_globalThis_3f735a5746d41fbd() { return handleError(function () {\n    var ret = globalThis.globalThis;\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_global_1bc0b39582740e95() { return handleError(function () {\n    var ret = global.global;\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbindgen_is_undefined(arg0) {\n    var ret = getObject(arg0) === undefined;\n    return ret;\n};\n\nexport function __wbg_buffer_397eaa4d72ee94dd(arg0) {\n    var ret = getObject(arg0).buffer;\n    return addHeapObject(ret);\n};\n\nexport function __wbg_newwithbyteoffsetandlength_4b9b8c4e3f5adbff(arg0, arg1, arg2) {\n    var ret = new Uint8Array(getObject(arg0), arg1 >>> 0, arg2 >>> 0);\n    return addHeapObject(ret);\n};\n\nexport function __wbg_new_a7ce447f15ff496f(arg0) {\n    var ret = new Uint8Array(getObject(arg0));\n    return addHeapObject(ret);\n};\n\nexport function __wbg_set_969ad0a60e51d320(arg0, arg1, arg2) {\n    getObject(arg0).set(getObject(arg1), arg2 >>> 0);\n};\n\nexport function __wbg_length_1eb8fc608a0d4cdb(arg0) {\n    var ret = getObject(arg0).length;\n    return ret;\n};\n\nexport function __wbg_newwithlength_929232475839a482(arg0) {\n    var ret = new Uint8Array(arg0 >>> 0);\n    return addHeapObject(ret);\n};\n\nexport function __wbg_subarray_8b658422a224f479(arg0, arg1, arg2) {\n    var ret = getObject(arg0).subarray(arg1 >>> 0, arg2 >>> 0);\n    return addHeapObject(ret);\n};\n\nexport function __wbg_has_1275b5eec3dc7a7a() { return handleError(function (arg0, arg1) {\n    var ret = Reflect.has(getObject(arg0), getObject(arg1));\n    return ret;\n}, arguments) };\n\nexport function __wbg_set_82a4e8a85e31ac42() { return handleError(function (arg0, arg1, arg2) {\n    var ret = Reflect.set(getObject(arg0), getObject(arg1), getObject(arg2));\n    return ret;\n}, arguments) };\n\nexport function __wbg_stringify_d4507a59932eed0c() { return handleError(function (arg0) {\n    var ret = JSON.stringify(getObject(arg0));\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbindgen_debug_string(arg0, arg1) {\n    var ret = debugString(getObject(arg1));\n    var ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    var len0 = WASM_VECTOR_LEN;\n    getInt32Memory0()[arg0 / 4 + 1] = len0;\n    getInt32Memory0()[arg0 / 4 + 0] = ptr0;\n};\n\nexport function __wbindgen_throw(arg0, arg1) {\n    throw new Error(getStringFromWasm0(arg0, arg1));\n};\n\nexport function __wbindgen_rethrow(arg0) {\n    throw takeObject(arg0);\n};\n\nexport function __wbindgen_memory() {\n    var ret = wasm.memory;\n    return addHeapObject(ret);\n};\n\nexport function __wbindgen_closure_wrapper7258(arg0, arg1, arg2) {\n    var ret = makeMutClosure(arg0, arg1, 1531, __wbg_adapter_34);\n    return addHeapObject(ret);\n};\n\n","module.exports = function(originalModule) {\n\tif (!originalModule.webpackPolyfill) {\n\t\tvar module = Object.create(originalModule);\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"exports\", {\n\t\t\tenumerable: true\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n"],"sourceRoot":""}