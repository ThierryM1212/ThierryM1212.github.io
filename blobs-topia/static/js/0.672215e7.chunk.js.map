{"version":3,"sources":["../node_modules/ergo-lib-wasm-browser/ergo_lib_wasm_bg.js","../node_modules/ergo-lib-wasm-browser/ergo_lib_wasm.js"],"names":["heap","Array","fill","undefined","getObject","idx","push","heap_next","length","takeObject","ret","dropObject","cachedTextDecoder","TextDecoder","module","require","ignoreBOM","fatal","decode","cachegetUint8Memory0","getUint8Memory0","buffer","wasm","Uint8Array","getStringFromWasm0","ptr","len","subarray","addHeapObject","obj","WASM_VECTOR_LEN","cachedTextEncoder","TextEncoder","encodeString","encodeInto","arg","view","buf","encode","set","read","written","passStringToWasm0","malloc","realloc","mem","offset","code","charCodeAt","slice","isLikeNone","x","cachegetInt32Memory0","getInt32Memory0","Int32Array","debugString","val","type","description","name","isArray","debug","i","className","builtInMatches","exec","toString","call","JSON","stringify","_","Error","message","stack","__wbg_adapter_34","arg0","arg1","makeMutClosure","dtor","f","state","a","b","cnt","real","args","get","original","__wbg_adapter_37","__wbg_adapter_40","arg2","cachegetUint32Memory0","getUint32Memory0","Uint32Array","passArrayJsValueToWasm0","array","_assertClass","instance","klass","getArrayU8FromWasm0","passArray8ToWasm0","get_info","node","NodeConf","ptr0","get_nipopow_proof_by_header_id","min_chain_length","suffix_len","header_id","BlockId","ptr1","peer_discovery","seeds","max_parallel_requests","timeout_sec","len0","extract_hints","signed_transaction","state_context","boxes_to_spend","data_boxes","real_propositions","simulated_propositions","retptr","Transaction","ErgoStateContext","ErgoBoxes","Propositions","ptr2","r0","r1","TransactionHintsBag","__wrap","getArrayJsValueFromWasm0","result","base16_decode","data","r2","v1","stack_pointer","verify_signature","address","signature","Address","len1","passArray32ToWasm0","handleError","apply","this","e","NonMandatoryRegisterId","Object","freeze","R4","R5","R6","R7","R8","R9","NetworkPrefix","Mainnet","Testnet","AddressTypePrefix","P2Pk","Pay2Sh","Pay2S","__destroy_into_raw","network_prefix","v0","ErgoTree","create","prototype","ergo_tree","bytes","s","BatchMerkleProof","expected_root","json","addBorrowedObject","BlockHeader","BlockHeaders","json_vals","index","BoxId","box_id_str","BoxSelection","boxes","change","ErgoBoxAssetsDataList","BoxValue","I64","v","CommitmentHint","Constant","r3","ErgoBox","base16_bytes_str","num","arr","bytes1","bytes2","l1","l2","ContextExtension","id","value","key","Contract","recipient","source","DataInput","box_id","DataInputs","elem","DerivationPath","acc","address_indices","path","creation_height","contract","tx_id","tokens","TxId","Tokens","register_id","ErgoBoxAssetsData","ErgoBoxCandidate","fee_amount","ErgoBoxCandidateBuilder","new_min_value_per_byte","new_value","token","token_name","token_desc","num_decimals","Token","token_id","amount","TokenId","TokenAmount","ErgoBoxCandidates","box_candidate","pre_header","headers","PreHeader","constant","ExtPubKey","public_key_bytes","chain_code","derivation_path","ExtSecretKey","secret_key_bytes","seed_bytes","HintsBag","hint","other","string","Input","ProverResult","Inputs","LevelNode","hash","side","MerkleProof","level","leaf_data","MinerAddress","Mnemonic","mnemonic_phrase","mnemonic_pass","v2","NetworkAddress","network","NipopowProof","NipopowVerifier","addr","PeerUrls","PoPowHeader","block_header","proposition","ReducedTransaction","UnsignedTransaction","unsigned_tx","SecretKey","SecretKeys","SimpleBoxSelector","inputs","target_balance","target_tokens","str","proofs","hints_bag","TxBuilder","data_inputs","context_extension","box_selection","output_candidates","current_height","change_address","min_change_value","UnsignedInput","ext","UnsignedInputs","input_id","Wallet","secret","_state_context","tx","tx_hints","reduced_tx","__wbindgen_object_drop_ref","__wbindgen_string_new","__wbg_peerurls_new","__wbg_nipopowproof_new","__wbindgen_is_string","__wbindgen_string_get","__wbindgen_object_clone_ref","__wbindgen_json_parse","parse","__wbindgen_json_serialize","__wbindgen_error_new","__wbindgen_number_new","__wbg_fetch_bf9c65a3164e36df","fetch","__wbindgen_cb_drop","__wbg_instanceof_Window_434ce1849eb4e0fc","Window","__wbg_performance_bbca4ccfaef860b2","performance","__wbg_setTimeout_1c75092906446b91","setTimeout","arguments","__wbg_fetch_fe54824ee845f6b4","__wbg_new_226d109446575877","Headers","__wbg_append_4d85f35672cbffa7","arg3","arg4","append","__wbg_signal_259ba662a5555524","signal","__wbg_new_7456dc18cc110e9c","AbortController","__wbg_abort_3c64506fb0036132","abort","__wbg_instanceof_Response_ea36d565358a42f7","Response","__wbg_url_6e564c9e212456f8","url","__wbg_status_3a55bb50e744b834","status","__wbg_headers_e4204c6775f7b3b4","__wbg_arrayBuffer_0e2a43f68a8b3e49","arrayBuffer","__wbg_new_4473c9af1cac368b","URL","__wbg_newwithstrandinit_c07f0662ece15bc6","Request","__wbg_now_5fa0ca001e042f8a","now","__wbg_process_f2b73829dbd321da","process","__wbindgen_is_object","__wbg_versions_cd82f79c98672a9f","versions","__wbg_node_ee3f6da4130bd35f","__wbg_modulerequire_0a83c0c31d12d2c7","__wbg_crypto_9e3521ed42436d35","crypto","__wbg_msCrypto_c429c3f8f7a70bb5","msCrypto","__wbg_getRandomValues_3e46aa268da0fed1","getRandomValues","__wbg_randomFillSync_59fcc2add91fe7b3","randomFillSync","__wbindgen_is_function","__wbg_newnoargs_f579424187aa1717","Function","__wbg_next_c7a2a6b012059a5e","next","__wbg_next_dd1a890d37e38d73","__wbg_done_982b1c7ac0cbc69d","done","__wbg_value_2def2d1fb38b02cd","__wbg_iterator_4b9cedbeda0c0e30","Symbol","iterator","__wbg_get_8bbb82393651dd9c","Reflect","__wbg_call_89558c3e96703ca1","__wbg_new_d3138911a89329b0","__wbg_self_e23d74ae45fb17d1","self","__wbg_window_b4be7f48b24ac56e","window","__wbg_globalThis_d61b1f48a57191ae","globalThis","__wbg_global_e7669da72fd7f239","global","__wbindgen_is_undefined","__wbg_new_55259b13834a484c","__wbg_call_94697a95cb7e239c","__wbg_toString_9b85345d84562096","__wbg_new_4beacc9c71572250","state0","Promise","__wbg_adapter_413","__wbg_resolve_4f8f547f26b30b27","resolve","__wbg_then_a6860c82b90816ca","then","__wbg_then_58a04e42527f52c6","__wbg_buffer_5e74a88a1424a2e0","__wbg_newwithbyteoffsetandlength_278ec7532799393a","__wbg_new_e3b800e570795b3c","__wbg_set_5b8081e9d002f0df","__wbg_length_30803400a8f15c59","__wbg_newwithlength_5f4ce114a24dfe1e","__wbg_subarray_a68f835ca2af506f","__wbg_has_3850edde6df9191b","has","__wbg_set_c42875065132a932","__wbg_stringify_f8bfc9e2d1e8b6a0","__wbindgen_debug_string","__wbindgen_throw","__wbindgen_memory","__wbindgen_closure_wrapper1289","makeClosure","__wbindgen_closure_wrapper6956","__wbindgen_closure_wrapper7044"],"mappings":"gsKAEMA,EAAO,IAAIC,MAAM,IAAIC,UAAKC,GAIhC,SAASC,EAAUC,GAAO,OAAOL,EAAKK,GAFtCL,EAAKM,UAAKH,EAAW,MAAM,GAAM,GAIjC,IAAII,EAAYP,EAAKQ,OAQrB,SAASC,EAAWJ,GAChB,IAAMK,EAAMN,EAAUC,GAEtB,OATJ,SAAoBA,GACZA,EAAM,KACVL,EAAKK,GAAOE,EACZA,EAAYF,GAKZM,CAAWN,GACJK,EAGX,IAEIE,EAAoB,IAFoB,qBAAhBC,aAA8B,EAAIC,EAAOC,SAAS,QAAQF,YAAcA,aAE3D,QAAS,CAAEG,WAAW,EAAMC,OAAO,IAE5EL,EAAkBM,SAElB,IAAIC,EAAuB,KAC3B,SAASC,IAIL,OAH6B,OAAzBD,GAAiCA,EAAqBE,SAAWC,KAAYD,SAC7EF,EAAuB,IAAII,WAAWD,KAAYD,SAE/CF,EAGX,SAASK,EAAmBC,EAAKC,GAC7B,OAAOd,EAAkBM,OAAOE,IAAkBO,SAASF,EAAKA,EAAMC,IAG1E,SAASE,EAAcC,GACftB,IAAcP,EAAKQ,QAAQR,EAAKM,KAAKN,EAAKQ,OAAS,GACvD,IAAMH,EAAME,EAIZ,OAHAA,EAAYP,EAAKK,GAEjBL,EAAKK,GAAOwB,EACLxB,EAGX,IAAIyB,EAAkB,EAIlBC,EAAoB,IAFoB,qBAAhBC,aAA8B,EAAIlB,EAAOC,SAAS,QAAQiB,YAAcA,aAE3D,SAEnCC,EAAwD,oBAAjCF,EAAkBG,WACzC,SAAUC,EAAKC,GACjB,OAAOL,EAAkBG,WAAWC,EAAKC,IAEvC,SAAUD,EAAKC,GACjB,IAAMC,EAAMN,EAAkBO,OAAOH,GAErC,OADAC,EAAKG,IAAIF,GACF,CACHG,KAAML,EAAI3B,OACViC,QAASJ,EAAI7B,SAIrB,SAASkC,EAAkBP,EAAKQ,EAAQC,GAEpC,QAAgBzC,IAAZyC,EAAuB,CACvB,IAAMP,EAAMN,EAAkBO,OAAOH,GAC/BV,EAAMkB,EAAON,EAAI7B,QAGvB,OAFAY,IAAkBO,SAASF,EAAKA,EAAMY,EAAI7B,QAAQ+B,IAAIF,GACtDP,EAAkBO,EAAI7B,OACfiB,EAUX,IAPA,IAAIC,EAAMS,EAAI3B,OACViB,EAAMkB,EAAOjB,GAEXmB,EAAMzB,IAER0B,EAAS,EAENA,EAASpB,EAAKoB,IAAU,CAC3B,IAAMC,EAAOZ,EAAIa,WAAWF,GAC5B,GAAIC,EAAO,IAAM,MACjBF,EAAIpB,EAAMqB,GAAUC,EAGxB,GAAID,IAAWpB,EAAK,CACD,IAAXoB,IACAX,EAAMA,EAAIc,MAAMH,IAEpBrB,EAAMmB,EAAQnB,EAAKC,EAAKA,EAAMoB,EAAsB,EAAbX,EAAI3B,QAC3C,IAAM4B,EAAOhB,IAAkBO,SAASF,EAAMqB,EAAQrB,EAAMC,GAG5DoB,GAFYb,EAAaE,EAAKC,GAEhBK,QAIlB,OADAX,EAAkBgB,EACXrB,EAGX,SAASyB,EAAWC,GAChB,YAAahD,IAANgD,GAAyB,OAANA,EAG9B,IAAIC,EAAuB,KAC3B,SAASC,IAIL,OAH6B,OAAzBD,GAAiCA,EAAqB/B,SAAWC,KAAYD,SAC7E+B,EAAuB,IAAIE,WAAWhC,KAAYD,SAE/C+B,EAGX,SAASG,EAAYC,GAEjB,IAAMC,SAAcD,EACpB,GAAY,UAARC,GAA4B,WAARA,GAA4B,MAAPD,EACzC,gBAAWA,GAEf,GAAY,UAARC,EACA,iBAAWD,EAAX,KAEJ,GAAY,UAARC,EAAkB,CAClB,IAAMC,EAAcF,EAAIE,YACxB,OAAmB,MAAfA,EACO,SAEP,iBAAiBA,EAAjB,KAGR,GAAY,YAARD,EAAoB,CACpB,IAAME,EAAOH,EAAIG,KACjB,MAAmB,iBAARA,GAAoBA,EAAKnD,OAAS,EACzC,mBAAmBmD,EAAnB,KAEO,WAIf,GAAI1D,MAAM2D,QAAQJ,GAAM,CACpB,IAAMhD,EAASgD,EAAIhD,OACfqD,EAAQ,IACRrD,EAAS,IACTqD,GAASN,EAAYC,EAAI,KAE7B,IAAI,IAAIM,EAAI,EAAGA,EAAItD,EAAQsD,IACvBD,GAAS,KAAON,EAAYC,EAAIM,IAGpC,OADAD,GAAS,IAIb,IACIE,EADEC,EAAiB,sBAAsBC,KAAKC,SAASC,KAAKX,IAEhE,KAAIQ,EAAexD,OAAS,GAIxB,OAAO0D,SAASC,KAAKX,GAEzB,GAAiB,WALbO,EAAYC,EAAe,IAS3B,IACI,MAAO,UAAYI,KAAKC,UAAUb,GAAO,IAC3C,MAAOc,GACL,MAAO,SAIf,OAAId,aAAee,MACf,UAAUf,EAAIG,KAAd,aAAuBH,EAAIgB,QAA3B,aAAuChB,EAAIiB,OAGxCV,EAwBX,SAASW,EAAiBC,EAAMC,GAC5BtD,KAA6HqD,EAAMC,GAGvI,SAASC,EAAeF,EAAMC,EAAME,EAAMC,GACtC,IAAMC,EAAQ,CAAEC,EAAGN,EAAMO,EAAGN,EAAMO,IAAK,EAAGL,QACpCM,EAAO,WAITJ,EAAMG,MACN,IAAMF,EAAID,EAAMC,EAChBD,EAAMC,EAAI,EACV,IAAI,2BAPSI,EAOT,yBAPSA,EAOT,gBACA,OAAON,EAAC,WAAD,GAAEE,EAAGD,EAAME,GAAX,OAAiBG,IAD5B,QAGwB,MAAdL,EAAMG,IACR7D,KAAyBgE,IAAIN,EAAMF,KAAnCxD,CAAyC2D,EAAGD,EAAME,GAGlDF,EAAMC,EAAIA,IAMtB,OAFAG,EAAKG,SAAWP,EAETI,EAEX,SAASI,EAAiBb,EAAMC,GAC5BtD,KAAgIqD,EAAMC,GAG1I,SAASa,EAAiBd,EAAMC,EAAMc,GAClCpE,KAAkIqD,EAAMC,EAAMhD,EAAc8D,IAGhK,IAAIC,EAAwB,KAC5B,SAASC,IAIL,OAH8B,OAA1BD,GAAkCA,EAAsBtE,SAAWC,KAAYD,SAC/EsE,EAAwB,IAAIE,YAAYvE,KAAYD,SAEjDsE,EAGX,SAASG,EAAwBC,EAAOpD,GAGpC,IAFA,IAAMlB,EAAMkB,EAAsB,EAAfoD,EAAMvF,QACnBqC,EAAM+C,IACH9B,EAAI,EAAGA,EAAIiC,EAAMvF,OAAQsD,IAC9BjB,EAAIpB,EAAM,EAAIqC,GAAKlC,EAAcmE,EAAMjC,IAG3C,OADAhC,EAAkBiE,EAAMvF,OACjBiB,EAGX,SAASuE,EAAaC,EAAUC,GAC5B,KAAMD,aAAoBC,GACtB,MAAM,IAAI3B,MAAJ,+BAAkC2B,EAAMvC,OAElD,OAAOsC,EAASxE,IAGpB,SAAS0E,EAAoB1E,EAAKC,GAC9B,OAAON,IAAkBO,SAASF,EAAM,EAAGA,EAAM,EAAIC,GAGzD,SAAS0E,EAAkBjE,EAAKQ,GAC5B,IAAMlB,EAAMkB,EAAoB,EAAbR,EAAI3B,QAGvB,OAFAY,IAAkBmB,IAAIJ,EAAKV,EAAM,GACjCK,EAAkBK,EAAI3B,OACfiB,EAOJ,SAAS4E,EAASC,GACrBN,EAAaM,EAAMC,IACnB,IAAIC,EAAOF,EAAK7E,IAGhB,OAFA6E,EAAK7E,IAAM,EAEJhB,EADGa,KAAckF,IAYrB,SAASC,EAA+BH,EAAMI,EAAkBC,EAAYC,GAC/EZ,EAAaM,EAAMC,IACnB,IAAIC,EAAOF,EAAK7E,IAChB6E,EAAK7E,IAAM,EACXuE,EAAaY,EAAWC,GACxB,IAAIC,EAAOF,EAAUnF,IAGrB,OAFAmF,EAAUnF,IAAM,EAEThB,EADGa,KAAoCkF,EAAME,EAAkBC,EAAYG,IAiB/E,SAASC,EAAeC,EAAOC,EAAuBC,GACzD,IAAIV,EAAOV,EAAwBkB,EAAO1F,MACtC6F,EAAOrF,EAEX,OAAOrB,EADGa,KAAoBkF,EAAMW,EAAMF,EAAuBC,IAc9D,SAASE,EAAcC,EAAoBC,EAAeC,EAAgBC,EAAYC,EAAmBC,GAC5G,IACI,IAAMC,EAASrG,MAAsC,IACrD0E,EAAaqB,EAAoBO,IACjC,IAAIpB,EAAOa,EAAmB5F,IAC9B4F,EAAmB5F,IAAM,EACzBuE,EAAasB,EAAeO,IAC5B7B,EAAauB,EAAgBO,IAC7B9B,EAAawB,EAAYM,IACzB9B,EAAayB,EAAmBM,IAChC,IAAIjB,EAAOW,EAAkBhG,IAC7BgG,EAAkBhG,IAAM,EACxBuE,EAAa0B,EAAwBK,IACrC,IAAIC,EAAON,EAAuBjG,IAClCiG,EAAuBjG,IAAM,EAC7BH,KAAmBqG,EAAQnB,EAAMc,EAAc7F,IAAK8F,EAAe9F,IAAK+F,EAAW/F,IAAKqF,EAAMkB,GAC9F,IAAIC,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWyH,GAErB,OAAOC,GAAoBC,OAAOH,GArBtC,QAuBI3G,KAAqC,KAI7C,SAAS+G,EAAyB5G,EAAKC,GAInC,IAHA,IACMuB,EADM2C,IACMjE,SAASF,EAAM,EAAGA,EAAM,EAAIC,GACxC4G,EAAS,GACNxE,EAAI,EAAGA,EAAIb,EAAMzC,OAAQsD,IAC9BwE,EAAOhI,KAAKG,EAAWwC,EAAMa,KAEjC,OAAOwE,EAOJ,SAASC,EAAcC,GAC1B,IACI,IAAMb,EAASrG,MAAsC,IACjDkF,EAAO9D,EAAkB8F,EAAMlH,KAAwBA,MACvD6F,EAAOrF,EACXR,KAAmBqG,EAAQnB,EAAMW,GACjC,IAAIc,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GACpCc,EAAKpF,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWgI,GAErB,IAAIC,EAAKvC,EAAoB8B,EAAIC,GAAIjF,QAErC,OADA3B,KAAqB2G,EAAS,EAALC,GAClBQ,EAdX,QAgBIpH,KAAqC,KAI7C,IAAIqH,EAAgB,GAcb,SAASC,EAAiBC,EAASrE,EAASsE,GAC/C,IACI,IAAMnB,EAASrG,MAAsC,IACrD0E,EAAa6C,EAASE,GACtB,IAAIvC,EAAOJ,EAAkB5B,EAASlD,MAClC6F,EAAOrF,EACPgF,EAAOV,EAAkB0C,EAAWxH,MACpC0H,EAAOlH,EACXR,KAAsBqG,EAAQkB,EAAQpH,IAAK+E,EAAMW,EAAML,EAAMkC,GAC7D,IAAIf,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWyH,GAErB,OAAc,IAAPD,EAdX,QAgBI3G,KAAqC,KAI7C,SAAS2H,EAAmB9G,EAAKQ,GAC7B,IAAMlB,EAAMkB,EAAoB,EAAbR,EAAI3B,QAGvB,OAFAoF,IAAmBrD,IAAIJ,EAAKV,EAAM,GAClCK,EAAkBK,EAAI3B,OACfiB,EAOX,SAASyH,EAAYnE,EAAGM,GACpB,IACI,OAAON,EAAEoE,MAAMC,KAAM/D,GACvB,MAAOgE,GACL/H,KAA0BM,EAAcyH,KAUzC,IAAMC,EAAyBC,OAAOC,OAAO,CAIpDC,GAAG,EAAE,EAAI,KAITC,GAAG,EAAE,EAAI,KAITC,GAAG,EAAE,EAAI,KAITC,GAAG,EAAE,EAAI,KAITC,GAAG,EAAE,EAAI,KAITC,GAAG,EAAE,EAAI,OAIIC,EAAgBR,OAAOC,OAAO,CAI3CQ,QAAQ,EAAE,EAAI,UAIdC,QAAQ,GAAG,GAAK,YAIHC,EAAoBX,OAAOC,OAAO,CAI/CW,KAAK,EAAE,EAAI,OAIXC,OAAO,EAAE,EAAI,SAIbC,MAAM,EAAE,EAAI,UA8CCtB,EAAb,6GAUQ,IAAMtH,EAAM2H,KAAK3H,IAGjB,OAFA2H,KAAK3H,IAAM,EAEJA,IAbf,6BAiBQ,IAAMA,EAAM2H,KAAKkB,qBACjBhJ,IAAwBG,KAlBhC,gCA0Ic8I,GACN,IACI,IAAM5C,EAASrG,MAAsC,IACrDA,KAAuBqG,EAAQyB,KAAK3H,IAAK8I,GACzC,IAAItC,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GACxC,OAAOnG,EAAmByG,EAAIC,GALlC,QAOI5G,KAAqC,IACrCA,KAAqB2G,EAAIC,MAnJrC,+BAiLaqC,GACL,IACI,IAAM5C,EAASrG,MAAsC,IACrDA,KAAsBqG,EAAQyB,KAAK3H,IAAK8I,GACxC,IAAItC,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GACpC6C,EAAKrE,EAAoB8B,EAAIC,GAAIjF,QAErC,OADA3B,KAAqB2G,EAAS,EAALC,GAClBsC,EAPX,QASIlJ,KAAqC,OA3LjD,4CAoMQ,OADUA,KAAiC8H,KAAK3H,OACjC,IApMvB,qCAiOQ,IACI,IAAMkG,EAASrG,MAAsC,IACrDA,KAA0BqG,EAAQyB,KAAK3H,KACvC,IAAIwG,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWyH,GAErB,OAAOuC,GAASrC,OAAOH,GAT3B,QAWI3G,KAAqC,QA5OjD,8BAEkBG,GACV,IAAMI,EAAM0H,OAAOmB,OAAO3B,EAAQ4B,WAGlC,OAFA9I,EAAIJ,IAAMA,EAEHI,IANf,8CA6BmC+I,GAC3B,IACI,IAAMjD,EAASrG,MAAsC,IACrD0E,EAAa4E,EAAWH,IACxBnJ,KAAqCqG,EAAQiD,EAAUnJ,KACvD,IAAIwG,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWyH,GAErB,OAAOa,EAAQX,OAAOH,GAV1B,QAYI3G,KAAqC,OA1CjD,yCAkD8BuJ,GACtB,IACI,IAAMlD,EAASrG,MAAsC,IACjDkF,EAAOJ,EAAkByE,EAAOvJ,MAChC6F,EAAOrF,EACXR,KAAgCqG,EAAQnB,EAAMW,GAC9C,IAAIc,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWyH,GAErB,OAAOa,EAAQX,OAAOH,GAX1B,QAaI3G,KAAqC,OAhEjD,uCAwE4BwJ,GACpB,IACI,IAAMnD,EAASrG,MAAsC,IACjDkF,EAAO9D,EAAkBoI,EAAGxJ,KAAwBA,MACpD6F,EAAOrF,EACXR,KAA8BqG,EAAQnB,EAAMW,GAC5C,IAAIc,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWyH,GAErB,OAAOa,EAAQX,OAAOH,GAX1B,QAaI3G,KAAqC,OAtFjD,uCA8F4BwJ,GACpB,IACI,IAAMnD,EAASrG,MAAsC,IACjDkF,EAAO9D,EAAkBoI,EAAGxJ,KAAwBA,MACpD6F,EAAOrF,EACXR,KAA8BqG,EAAQnB,EAAMW,GAC5C,IAAIc,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWyH,GAErB,OAAOa,EAAQX,OAAOH,GAX1B,QAaI3G,KAAqC,OA5GjD,kCAoHuBwJ,GACf,IACI,IAAMnD,EAASrG,MAAsC,IACjDkF,EAAO9D,EAAkBoI,EAAGxJ,KAAwBA,MACpD6F,EAAOrF,EACXR,KAAyBqG,EAAQnB,EAAMW,GACvC,IAAIc,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWyH,GAErB,OAAOa,EAAQX,OAAOH,GAX1B,QAaI3G,KAAqC,OAlIjD,iCA2JsBkH,GACd,IACI,IAAMb,EAASrG,MAAsC,IACjDkF,EAAOJ,EAAkBoC,EAAMlH,MAC/B6F,EAAOrF,EACXR,KAAwBqG,EAAQnB,EAAMW,GACtC,IAAIc,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWyH,GAErB,OAAOa,EAAQX,OAAOH,GAX1B,QAaI3G,KAAqC,OAzKjD,sCA2M2BuJ,GACnB,IACI,IAAMlD,EAASrG,MAAsC,IACjDkF,EAAOJ,EAAkByE,EAAOvJ,MAChC6F,EAAOrF,EACXR,KAA6BqG,EAAQnB,EAAMW,GAC3C,IAAIc,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWyH,GAErB,OAAOa,EAAQX,OAAOH,GAX1B,QAaI3G,KAAqC,SAzNjD,KAmPayJ,EAAb,6GAUQ,IAAMtJ,EAAM2H,KAAK3H,IAGjB,OAFA2H,KAAK3H,IAAM,EAEJA,IAbf,6BAiBQ,IAAMA,EAAM2H,KAAKkB,qBACjBhJ,IAAiCG,KAlBzC,gCA8CQ,IACI,IAAMkG,EAASrG,MAAsC,IACrDA,KAA8BqG,EAAQyB,KAAK3H,KAC3C,IAAIwG,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWyH,GAErB,OAAOzH,EAAWwH,GATtB,QAWI3G,KAAqC,OAzDjD,4BAiEU0J,GACF,IAAIxE,EAAOJ,EAAkB4E,EAAe1J,MACxC6F,EAAOrF,EAEX,OAAe,IADLR,KAA4B8H,KAAK3H,IAAK+E,EAAMW,MApE9D,8BAEkB1F,GACV,IAAMI,EAAM0H,OAAOmB,OAAOK,EAAiBJ,WAG3C,OAFA9I,EAAIJ,IAAMA,EAEHI,IANf,gCAyBqBoJ,GACb,IACI,IAAMtD,EAASrG,MAAsC,IACrDA,KAAgCqG,EA3a5C,SAA2B9F,GACvB,GAAqB,GAAjB8G,EAAoB,MAAM,IAAIpE,MAAM,mBAExC,OADAvE,IAAO2I,GAAiB9G,EACjB8G,EAwayCuC,CAAkBD,IAC1D,IAAIhD,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWyH,GAErB,OAAO6C,EAAiB3C,OAAOH,GATnC,QAWI3G,KAAqC,IACrCtB,EAAK2I,UAAmBxI,OAtCpC,KA2EagL,EAAb,6GAUQ,IAAM1J,EAAM2H,KAAK3H,IAGjB,OAFA2H,KAAK3H,IAAM,EAEJA,IAbf,6BAiBQ,IAAMA,EAAM2H,KAAKkB,qBACjBhJ,IAA4BG,KAlBpC,2BA+CQ,IAAIf,EAAMY,KAAoB8H,KAAK3H,KACnC,OAAOoF,EAAQuB,OAAO1H,MAhD9B,8BAEkBe,GACV,IAAMI,EAAM0H,OAAOmB,OAAOS,EAAYR,WAGtC,OAFA9I,EAAIJ,IAAMA,EAEHI,IANf,gCAyBqBoJ,GACb,IACI,IAAMtD,EAASrG,MAAsC,IACjDkF,EAAO9D,EAAkBuI,EAAM3J,KAAwBA,MACvD6F,EAAOrF,EACXR,KAA2BqG,EAAQnB,EAAMW,GACzC,IAAIc,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWyH,GAErB,OAAOiD,EAAY/C,OAAOH,GAX9B,QAaI3G,KAAqC,SAvCjD,KAsDa8J,EAAb,WA8CI,WAAYlG,GAAG,oBACXc,EAAad,EAAGiG,GAChB,IAAIzK,EAAMY,KAAsB4D,EAAEzD,KAClC,OAAO2J,EAAahD,OAAO1H,GAjDnC,iEAUQ,IAAMe,EAAM2H,KAAK3H,IAGjB,OAFA2H,KAAK3H,IAAM,EAEJA,IAbf,6BAiBQ,IAAMA,EAAM2H,KAAKkB,qBACjBhJ,IAA6BG,MAlBrC,8BAEkBA,GACV,IAAMI,EAAM0H,OAAOmB,OAAOU,EAAaT,WAGvC,OAFA9I,EAAIJ,IAAMA,EAEHI,IANf,gCAyBqBwJ,GACb,IACI,IAAM1D,EAASrG,MAAsC,IACjDkF,EAAOV,EAAwBuF,EAAW/J,MAC1C6F,EAAOrF,EACXR,KAA4BqG,EAAQnB,EAAMW,GAC1C,IAAIc,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWyH,GAErB,OAAOkD,EAAahD,OAAOH,GAX/B,QAaI3G,KAAqC,SAvCjD,2CAyDQ,OADUA,KAAsB8H,KAAK3H,OACtB,IAzDvB,0BA+DQyD,GACAc,EAAad,EAAGiG,GAChB7J,KAAsB8H,KAAK3H,IAAKyD,EAAEzD,OAjE1C,0BAwEQ6J,GACA,IAAI5K,EAAMY,KAAsB8H,KAAK3H,IAAK6J,GAC1C,OAAOH,EAAY/C,OAAO1H,OA1ElC,KAgFamG,EAAb,6GAUQ,IAAMpF,EAAM2H,KAAK3H,IAGjB,OAFA2H,KAAK3H,IAAM,EAEJA,IAbf,6BAiBQ,IAAMA,EAAM2H,KAAKkB,qBACjBhJ,IAAwBG,MAlBhC,8BAEkBA,GACV,IAAMI,EAAM0H,OAAOmB,OAAO7D,EAAQ8D,WAGlC,OAFA9I,EAAIJ,IAAMA,EAEHI,MANf,KAwBa0J,EAAb,6GAUQ,IAAM9J,EAAM2H,KAAK3H,IAGjB,OAFA2H,KAAK3H,IAAM,EAEJA,IAbf,6BAiBQ,IAAMA,EAAM2H,KAAKkB,qBACjBhJ,IAAsBG,KAlB9B,+BA+CQ,IACI,IAAMkG,EAASrG,MAAsC,IACrDA,KAAkBqG,EAAQyB,KAAK3H,KAC/B,IAAIwG,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GACxC,OAAOnG,EAAmByG,EAAIC,GALlC,QAOI5G,KAAqC,IACrCA,KAAqB2G,EAAIC,MAvDrC,iCAgEQ,OAAOzH,EADGa,KAAoB8H,KAAK3H,SA/D3C,8BAEkBA,GACV,IAAMI,EAAM0H,OAAOmB,OAAOa,EAAMZ,WAGhC,OAFA9I,EAAIJ,IAAMA,EAEHI,IANf,+BAyBoB2J,GACZ,IACI,IAAM7D,EAASrG,MAAsC,IACjDkF,EAAO9D,EAAkB8I,EAAYlK,KAAwBA,MAC7D6F,EAAOrF,EACXR,KAAoBqG,EAAQnB,EAAMW,GAClC,IAAIc,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWyH,GAErB,OAAOqD,EAAMnD,OAAOH,GAXxB,QAaI3G,KAAqC,SAvCjD,KAsEamK,EAAb,WAyBI,WAAYC,EAAOC,GAAQ,oBACvB,IACI,IAAMhE,EAASrG,MAAsC,IACrD0E,EAAa0F,EAAO5D,IACpB9B,EAAa2F,EAAQC,IACrBtK,KAAsBqG,EAAQ+D,EAAMjK,IAAKkK,EAAOlK,KAChD,IAAIwG,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWyH,GAErB,OAAOuD,EAAarD,OAAOH,GAX/B,QAaI3G,KAAqC,KAvCjD,iEAUQ,IAAMG,EAAM2H,KAAK3H,IAGjB,OAFA2H,KAAK3H,IAAM,EAEJA,IAbf,6BAiBQ,IAAMA,EAAM2H,KAAKkB,qBACjBhJ,IAA6BG,MAlBrC,8BAEkBA,GACV,IAAMI,EAAM0H,OAAOmB,OAAOe,EAAad,WAGvC,OAFA9I,EAAIJ,IAAMA,EAEHI,MANf,6CA+CQ,IAAInB,EAAMY,KAAwB8H,KAAK3H,KACvC,OAAOqG,GAAUM,OAAO1H,KAhDhC,+BAuDQ,IAAIA,EAAMY,KAAyB8H,KAAK3H,KACxC,OAAOmK,GAAsBxD,OAAO1H,OAxD5C,KA8DamL,GAAb,6GAUQ,IAAMpK,EAAM2H,KAAK3H,IAGjB,OAFA2H,KAAK3H,IAAM,EAEJA,IAbf,6BAiBQ,IAAMA,EAAM2H,KAAKkB,qBACjBhJ,IAAyBG,KAlBjC,+BA+DQ,IAAIf,EAAMY,KAAqB8H,KAAK3H,KACpC,OAAOqK,GAAI1D,OAAO1H,KAhE1B,iCAuEQ,IACI,IAAMiH,EAASrG,MAAsC,IACrDA,KAAuBqG,EAAQyB,KAAK3H,KACpC,IAAIwG,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GACpC6C,EAAKrE,EAAoB8B,EAAIC,GAAIjF,QAErC,OADA3B,KAAqB2G,EAAS,EAALC,GAClBsC,EAPX,QASIlJ,KAAqC,QAhFjD,8BAEkBG,GACV,IAAMI,EAAM0H,OAAOmB,OAAOmB,EAASlB,WAGnC,OAFA9I,EAAIJ,IAAMA,EAEHI,IANf,sCA0BQ,IAAInB,EAAMY,OACV,OAAOuK,EAASzD,OAAO1H,KA3B/B,uCAkCQ,IAAIA,EAAMY,OACV,OAAOwK,GAAI1D,OAAO1H,KAnC1B,+BA0CoBqL,GACZ,IACI,IAAMpE,EAASrG,MAAsC,IACrD0E,EAAa+F,EAAGD,IAChBxK,KAAuBqG,EAAQoE,EAAEtK,KACjC,IAAIwG,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWyH,GAErB,OAAO2D,EAASzD,OAAOH,GAV3B,QAYI3G,KAAqC,SAvDjD,KAuFa0K,GAAb,6GAUQ,IAAMvK,EAAM2H,KAAK3H,IAGjB,OAFA2H,KAAK3H,IAAM,EAEJA,IAbf,6BAiBQ,IAAMA,EAAM2H,KAAKkB,qBACjBhJ,IAA+BG,MAlBvC,8BAEkBA,GACV,IAAMI,EAAM0H,OAAOmB,OAAOsB,EAAerB,WAGzC,OAFA9I,EAAIJ,IAAMA,EAEHI,MANf,KAwBaoK,GAAb,6GAUQ,IAAMxK,EAAM2H,KAAK3H,IAGjB,OAFA2H,KAAK3H,IAAM,EAEJA,IAbf,6BAiBQ,IAAMA,EAAM2H,KAAKkB,qBACjBhJ,IAAyBG,KAlBjC,yCAgDQ,IACI,IAAMkG,EAASrG,MAAsC,IACrDA,KAA+BqG,EAAQyB,KAAK3H,KAC5C,IAAIwG,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GACpCc,EAAKpF,IAAkBsE,EAAS,EAAI,GACpCuE,EAAK7I,IAAkBsE,EAAS,EAAI,GACpCnB,EAAOyB,EACPd,EAAOe,EACX,GAAIgE,EAEA,MADA1F,EAAO,EAAGW,EAAO,EACX1G,EAAWgI,GAErB,OAAOjH,EAAmBgF,EAAMW,GAbpC,QAeI7F,KAAqC,IACrCA,KAAqBkF,EAAMW,MAhEvC,8CAwEQ,IACI,IAAMQ,EAASrG,MAAsC,IACrDA,KAAoCqG,EAAQyB,KAAK3H,KACjD,IAAIwG,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GACpCc,EAAKpF,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWgI,GAErB,IAAI+B,EAAKrE,EAAoB8B,EAAIC,GAAIjF,QAErC,OADA3B,KAAqB2G,EAAS,EAALC,GAClBsC,EAZX,QAcIlJ,KAAqC,OAtFjD,+BAuGQ,IACI,IAAMqG,EAASrG,MAAsC,IACrDA,KAAqBqG,EAAQyB,KAAK3H,KAClC,IAAIwG,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWyH,GAErB,OAAOD,EATX,QAWI3G,KAAqC,OAlHjD,+BAoIQ,IACI,IAAMqG,EAASrG,MAAsC,IACrDA,KAAqBqG,EAAQyB,KAAK3H,KAClC,IAAIwG,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWyH,GAErB,OAAO4D,GAAI1D,OAAOH,GATtB,QAWI3G,KAAqC,OA/IjD,sCAwLQ,IACI,IAAMqG,EAASrG,MAAsC,IACrDA,KAA4BqG,EAAQyB,KAAK3H,KACzC,IAAIwG,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWyH,GAErB,OAAOzH,EAAWwH,GATtB,QAWI3G,KAAqC,OAnMjD,qCAiOQ,IACI,IAAMqG,EAASrG,MAAsC,IACrDA,KAA2BqG,EAAQyB,KAAK3H,KACxC,IAAIwG,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GACpCc,EAAKpF,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWgI,GAErB,IAAI+B,GA9iCc/I,EA8iCYwG,EA9iCPvG,EA8iCWwG,EA7iCnC7E,IAAkB1B,SAASF,EAAM,EAAGA,EAAM,EAAIC,IA6iCPuB,QAEtC,OADA3B,KAAqB2G,EAAS,EAALC,GAClBsC,EAZX,QAcIlJ,KAAqC,IAljCjD,IAA8BG,EAAKC,IAm0BnC,yCA6QQ,IACI,IAAMiG,EAASrG,MAAsC,IACrDA,KAA+BqG,EAAQyB,KAAK3H,KAC5C,IAAIwG,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GACpCc,EAAKpF,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWgI,GAErB,IAAI+B,EAAKnC,EAAyBJ,EAAIC,GAAIjF,QAE1C,OADA3B,KAAqB2G,EAAS,EAALC,GAClBsC,EAZX,QAcIlJ,KAAqC,OA3RjD,0CAmSQ,IACI,IAAMqG,EAASrG,MAAsC,IACrDA,KAAgCqG,EAAQyB,KAAK3H,KAC7C,IAAIwG,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GACpCc,EAAKpF,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWgI,GAErB,IAAI+B,EAAKnC,EAAyBJ,EAAIC,GAAIjF,QAE1C,OADA3B,KAAqB2G,EAAS,EAALC,GAClBsC,EAZX,QAcIlJ,KAAqC,OAjTjD,4CA8XQ,IACI,IAAMqG,EAASrG,MAAsC,IACrDA,KAAkCqG,EAAQyB,KAAK3H,KAC/C,IAAIwG,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GACpCc,EAAKpF,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWgI,GAErB,IAAI+B,EAAKnC,EAAyBJ,EAAIC,GAAIjF,QAE1C,OADA3B,KAAqB2G,EAAS,EAALC,GAClBsC,EAZX,QAcIlJ,KAAqC,OA5YjD,qCAoZQ,IACI,IAAMqG,EAASrG,MAAsC,IACrDA,KAA2BqG,EAAQyB,KAAK3H,KACxC,IAAIwG,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GACpCc,EAAKpF,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWgI,GAErB,IAAI+B,EAAKnC,EAAyBJ,EAAIC,GAAIjF,QAE1C,OADA3B,KAAqB2G,EAAS,EAALC,GAClBsC,EAZX,QAcIlJ,KAAqC,OAlajD,qCAsbQ,IACI,IAAMqG,EAASrG,MAAsC,IACrDA,KAA2BqG,EAAQyB,KAAK3H,KACxC,IAAIwG,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GACpCc,EAAKpF,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWgI,GAErB,IAAI+B,EAAKnC,EAAyBJ,EAAIC,GAAIjF,QAE1C,OADA3B,KAAqB2G,EAAS,EAALC,GAClBsC,EAZX,QAcIlJ,KAAqC,OApcjD,oCAsdQ,IACI,IAAMqG,EAASrG,MAAsC,IACrDA,KAA0BqG,EAAQyB,KAAK3H,KACvC,IAAIwG,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWyH,GAErB,OAAOiE,GAAQ/D,OAAOH,GAT1B,QAWI3G,KAAqC,QAjejD,8BAEkBG,GACV,IAAMI,EAAM0H,OAAOmB,OAAOuB,EAAStB,WAGnC,OAFA9I,EAAIJ,IAAMA,EAEHI,IANf,yCAyB8BuK,GACtB,IACI,IAAMzE,EAASrG,MAAsC,IACjDkF,EAAO9D,EAAkB0J,EAAkB9K,KAAwBA,MACnE6F,EAAOrF,EACXR,KAAiCqG,EAAQnB,EAAMW,GAC/C,IAAIc,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWyH,GAErB,OAAO+D,EAAS7D,OAAOH,GAX3B,QAaI3G,KAAqC,OAvCjD,+BA8FoByK,GACZ,IAAIrL,EAAMY,KAAuByK,GACjC,OAAOE,EAAS7D,OAAO1H,KAhG/B,+BA0HoBqL,GACZ/F,EAAa+F,EAAGD,IAChB,IAAIpL,EAAMY,KAAuByK,EAAEtK,KACnC,OAAOwK,EAAS7D,OAAO1H,KA7H/B,kDAuJuC2L,GAC/B,IACI,IAAM1E,EAASrG,MAAsC,IACjDkF,EAAOJ,EAAkBiG,EAAK/K,MAC9B6F,EAAOrF,EACXR,KAA0CqG,EAAQnB,EAAMW,GACxD,IAAIc,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWyH,GAErB,OAAO+D,EAAS7D,OAAOH,GAX3B,QAaI3G,KAAqC,OArKjD,sCA6K2ByK,GACnB,IAAIvF,EAAOJ,EAAkB2F,EAAGzK,MAC5B6F,EAAOrF,EACPpB,EAAMY,KAA8BkF,EAAMW,GAC9C,OAAO8E,EAAS7D,OAAO1H,KAjL/B,qCA2M0B4L,GAClB,IACI,IAAM3E,EAASrG,MAAsC,IACjDkF,EAAOyC,EAAmBqD,EAAKhL,MAC/B6F,EAAOrF,EACXR,KAA6BqG,EAAQnB,EAAMW,GAC3C,IAAIc,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWyH,GAErB,OAAO+D,EAAS7D,OAAOH,GAX3B,QAaI3G,KAAqC,OAzNjD,yCAuP8BgL,GACtB,IACI,IAAM3E,EAASrG,MAAsC,IACjDkF,EAAOV,EAAwBwG,EAAKhL,MACpC6F,EAAOrF,EACXR,KAAiCqG,EAAQnB,EAAMW,GAC/C,IAAIc,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWyH,GAErB,OAAO+D,EAAS7D,OAAOH,GAX3B,QAaI3G,KAAqC,OArQjD,0CAyT+BgL,GACvB,IAAI9F,EAAOV,EAAwBwG,EAAKhL,MACpC6F,EAAOrF,EACPpB,EAAMY,KAAkCkF,EAAMW,GAClD,OAAO8E,EAAS7D,OAAO1H,KA7T/B,yCAoU8BmK,GACtB,IACI,IAAMlD,EAASrG,MAAsC,IACjDkF,EAAOJ,EAAkByE,EAAOvJ,MAChC6F,EAAOrF,EACXR,KAAiCqG,EAAQnB,EAAMW,GAC/C,IAAIc,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWyH,GAErB,OAAO+D,EAAS7D,OAAOH,GAX3B,QAaI3G,KAAqC,OAlVjD,uDA0V4CuJ,GACpC,IACI,IAAMlD,EAASrG,MAAsC,IACjDkF,EAAOJ,EAAkByE,EAAOvJ,MAChC6F,EAAOrF,EACXR,KAA+CqG,EAAQnB,EAAMW,GAC7D,IAAIc,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWyH,GAErB,OAAO+D,EAAS7D,OAAOH,GAX3B,QAaI3G,KAAqC,OAxWjD,4CAiXiCiL,EAAQC,GACjC,IAAIhG,EAAOJ,EAAkBmG,EAAQjL,MACjC6F,EAAOrF,EACPgF,EAAOV,EAAkBoG,EAAQlL,MACjC0H,EAAOlH,EACPpB,EAAMY,KAAoCkF,EAAMW,EAAML,EAAMkC,GAChE,OAAOiD,EAAS7D,OAAO1H,KAvX/B,qCA2a0B+L,EAAIC,GACtB1G,EAAayG,EAAIX,IACjB9F,EAAa0G,EAAIZ,IACjB,IAAIpL,EAAMY,KAA6BmL,EAAGhL,IAAKiL,EAAGjL,KAClD,OAAOwK,EAAS7D,OAAO1H,KA/a/B,oCA4cyBqL,GACjB/F,EAAa+F,EAAGI,IAChB,IAAIzL,EAAMY,KAA4ByK,EAAEtK,KACxC,OAAOwK,EAAS7D,OAAO1H,OA/c/B,KAweaiM,GAAb,WAuBI,aAAc,oBACV,IAAIjM,EAAMY,OACV,OAAOqL,EAAiBvE,OAAO1H,GAzBvC,iEAUQ,IAAMe,EAAM2H,KAAK3H,IAGjB,OAFA2H,KAAK3H,IAAM,EAEJA,IAbf,6BAiBQ,IAAMA,EAAM2H,KAAKkB,qBACjBhJ,IAAiCG,MAlBzC,8BAEkBA,GACV,IAAMI,EAAM0H,OAAOmB,OAAOiC,EAAiBhC,WAG3C,OAFA9I,EAAIJ,IAAMA,EAEHI,MANf,8CAgCa+K,EAAIC,GACT7G,EAAa6G,EAAOZ,IACpB3K,KAA+B8H,KAAK3H,IAAKmL,EAAIC,EAAMpL,OAlC3D,4BA0CQ,OADUH,KAA0B8H,KAAK3H,OAC1B,IA1CvB,0BAiDQqL,GACA,IACI,IAAMnF,EAASrG,MAAsC,IACrDA,KAA0BqG,EAAQyB,KAAK3H,IAAKqL,GAC5C,IAAI7E,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWyH,GAErB,OAAO+D,GAAS7D,OAAOH,GAT3B,QAWI3G,KAAqC,OA7DjD,6BAqEQ,IACI,IAAMqG,EAASrG,MAAsC,IACrDA,KAA2BqG,EAAQyB,KAAK3H,KACxC,IAAIwG,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GACpC6C,EAAKrE,EAAoB8B,EAAIC,GAAIjF,QAErC,OADA3B,KAAqB2G,EAAS,EAALC,GAClBsC,EAPX,QASIlJ,KAAqC,OA9EjD,8CAsFQ,IACI,IAAMqG,EAASrG,MAAsC,IACrDA,KAA4CqG,EAAQyB,KAAK3H,KACzD,IAAIwG,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GACpCc,EAAKpF,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWgI,GAErB,IAAI+B,EAAKrE,EAAoB8B,EAAIC,GAAIjF,QAErC,OADA3B,KAAqB2G,EAAS,EAALC,GAClBsC,EAZX,QAcIlJ,KAAqC,SApGjD,KA2GayL,GAAb,6GAUQ,IAAMtL,EAAM2H,KAAK3H,IAGjB,OAFA2H,KAAK3H,IAAM,EAEJA,IAbf,6BAiBQ,IAAMA,EAAM2H,KAAKkB,qBACjBhJ,IAAyBG,KAlBjC,kCAgFQ,IAAIf,EAAMY,KAAwB8H,KAAK3H,KACvC,OAAOgJ,GAASrC,OAAO1H,MAjF/B,8BAEkBe,GACV,IAAMI,EAAM0H,OAAOmB,OAAOqC,EAASpC,WAGnC,OAFA9I,EAAIJ,IAAMA,EAEHI,IANf,0BAyBe+I,GACP5E,EAAa4E,EAAWH,IACxB,IAAIjE,EAAOoE,EAAUnJ,IACrBmJ,EAAUnJ,IAAM,EAChB,IAAIf,EAAMY,KAAkBkF,GAC5B,OAAOuG,EAAS3E,OAAO1H,KA9B/B,qCAqC0BsM,GAClB,IACI,IAAMrF,EAASrG,MAAsC,IACrD0E,EAAagH,EAAWjE,GACxBzH,KAA6BqG,EAAQqF,EAAUvL,KAC/C,IAAIwG,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWyH,GAErB,OAAO6E,EAAS3E,OAAOH,GAV3B,QAYI3G,KAAqC,OAlDjD,8BA0DmB2L,GACX,IACI,IAAMtF,EAASrG,MAAsC,IACjDkF,EAAO9D,EAAkBuK,EAAQ3L,KAAwBA,MACzD6F,EAAOrF,EACXR,KAAsBqG,EAAQnB,EAAMW,GACpC,IAAIc,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWyH,GAErB,OAAO6E,EAAS3E,OAAOH,GAX3B,QAaI3G,KAAqC,SAxEjD,KAuFa4L,GAAb,WAwBI,WAAYC,GAAQ,oBAChBnH,EAAamH,EAAQ5B,GACrB,IAAI/E,EAAO2G,EAAO1L,IAClB0L,EAAO1L,IAAM,EACb,IAAIf,EAAMY,KAAmBkF,GAC7B,OAAO0G,EAAU9E,OAAO1H,GA7BhC,iEAUQ,IAAMe,EAAM2H,KAAK3H,IAGjB,OAFA2H,KAAK3H,IAAM,EAEJA,IAbf,6BAiBQ,IAAMA,EAAM2H,KAAKkB,qBACjBhJ,IAA0BG,MAlBlC,8BAEkBA,GACV,IAAMI,EAAM0H,OAAOmB,OAAOwC,EAAUvC,WAGpC,OAFA9I,EAAIJ,IAAMA,EAEHI,MANf,8CAoCQ,IAAInB,EAAMY,KAAsB8H,KAAK3H,KACrC,OAAO8J,EAAMnD,OAAO1H,OArC5B,KA2Ca0M,GAAb,WAuBI,aAAc,oBACV,IAAI1M,EAAMY,OACV,OAAO8L,EAAWhF,OAAO1H,GAzBjC,iEAUQ,IAAMe,EAAM2H,KAAK3H,IAGjB,OAFA2H,KAAK3H,IAAM,EAEJA,IAbf,6BAiBQ,IAAMA,EAAM2H,KAAKkB,qBACjBhJ,IAA2BG,MAlBnC,8BAEkBA,GACV,IAAMI,EAAM0H,OAAOmB,OAAO0C,EAAWzC,WAGrC,OAFA9I,EAAIJ,IAAMA,EAEHI,MANf,2CAiCQ,OADUP,KAAoB8H,KAAK3H,OACpB,IAjCvB,0BAwCQ6J,GACA,IAAI5K,EAAMY,KAAoB8H,KAAK3H,IAAK6J,GACxC,OAAO4B,GAAU9E,OAAO1H,KA1ChC,0BAgDQ2M,GACArH,EAAaqH,EAAMH,IACnB5L,KAAoB8H,KAAK3H,IAAK4L,EAAK5L,SAlD3C,KA0Da6L,GAAb,6GAUQ,IAAM7L,EAAM2H,KAAK3H,IAGjB,OAFA2H,KAAK3H,IAAM,EAEJA,IAbf,6BAiBQ,IAAMA,EAAM2H,KAAKkB,qBACjBhJ,IAA+BG,KAlBvC,8BA6DQ,OADUH,KAA0B8H,KAAK3H,OAC1B,IA7DvB,6BAqEQ,IACI,IAAMkG,EAASrG,MAAsC,IACrDA,KAAyBqG,EAAQyB,KAAK3H,KACtC,IAAIwG,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWyH,GAErB,OAAOoF,EAAelF,OAAOH,GATjC,QAWI3G,KAAqC,OAhFjD,iCAyFQ,IACI,IAAMqG,EAASrG,MAAsC,IACrDA,KAA6BqG,EAAQyB,KAAK3H,KAC1C,IAAIwG,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GACxC,OAAOnG,EAAmByG,EAAIC,GALlC,QAOI5G,KAAqC,IACrCA,KAAqB2G,EAAIC,MAjGrC,qCA2JQ,IACI,IAAMP,EAASrG,MAAsC,IACrDA,KAAiCqG,EAAQyB,KAAK3H,KAC9C,IAAIwG,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GACpC6C,EAAKrE,EAAoB8B,EAAIC,GAAIjF,QAErC,OADA3B,KAAqB2G,EAAS,EAALC,GAClBsC,EAPX,QASIlJ,KAAqC,QApKjD,8BAEkBG,GACV,IAAMI,EAAM0H,OAAOmB,OAAO4C,EAAe3C,WAGzC,OAFA9I,EAAIJ,IAAMA,EAEHI,IANf,0BA8Be0L,EAAKC,GACZ,IACI,IAAM7F,EAASrG,MAAsC,IACjDkF,EAAOyC,EAAmBuE,EAAiBlM,MAC3C6F,EAAOrF,EACXR,KAAwBqG,EAAQ4F,EAAK/G,EAAMW,GAC3C,IAAIc,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWyH,GAErB,OAAOoF,EAAelF,OAAOH,GAXjC,QAaI3G,KAAqC,OA5CjD,oCAoDQ,IAAIZ,EAAMY,OACV,OAAOgM,EAAelF,OAAO1H,KArDrC,kCA0GuB+M,GACf,IACI,IAAM9F,EAASrG,MAAsC,IACjDkF,EAAO9D,EAAkB+K,EAAMnM,KAAwBA,MACvD6F,EAAOrF,EACXR,KAAgCqG,EAAQnB,EAAMW,GAC9C,IAAIc,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWyH,GAErB,OAAOoF,EAAelF,OAAOH,GAXjC,QAaI3G,KAAqC,SAxHjD,KA4Ka6K,GAAb,WAmCI,WAAYU,EAAOa,EAAiBC,EAAUC,EAAOtC,EAAOuC,GAAQ,oBAChE,IACI,IAAMlG,EAASrG,MAAsC,IACrD0E,EAAa6G,EAAOhB,IACpB7F,EAAa2H,EAAUZ,IACvB/G,EAAa4H,EAAOE,IACpB9H,EAAa6H,EAAQE,IACrBzM,KAAiBqG,EAAQkF,EAAMpL,IAAKiM,EAAiBC,EAASlM,IAAKmM,EAAMnM,IAAK6J,EAAOuC,EAAOpM,KAC5F,IAAIwG,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWyH,GAErB,OAAOiE,EAAQ/D,OAAOH,GAb1B,QAeI3G,KAAqC,KAnDjD,iEAUQ,IAAMG,EAAM2H,KAAK3H,IAGjB,OAFA2H,KAAK3H,IAAM,EAEJA,IAbf,6BAiBQ,IAAMA,EAAM2H,KAAKkB,qBACjBhJ,IAAwBG,MAlBhC,8BAEkBA,GACV,IAAMI,EAAM0H,OAAOmB,OAAOyB,EAAQxB,WAGlC,OAFA9I,EAAIJ,IAAMA,EAEHI,MANf,8CA2DQ,IAAInB,EAAMY,KAAoB8H,KAAK3H,KACnC,OAAO8J,EAAMnD,OAAO1H,KA5D5B,8BAmEQ,IAAIA,EAAMY,KAAmB8H,KAAK3H,KAClC,OAAOqM,GAAK1F,OAAO1H,KApE3B,8BA4EQ,OADUY,KAAmB8H,KAAK3H,OA3E1C,wCAoFQ,OADUH,KAA6B8H,KAAK3H,OAC7B,IApFvB,+BA2FQ,IAAIf,EAAMY,KAAoB8H,KAAK3H,KACnC,OAAOsM,GAAO3F,OAAO1H,KA5F7B,kCAmGQ,IAAIA,EAAMY,KAAuB8H,KAAK3H,KACtC,OAAOgJ,GAASrC,OAAO1H,KApG/B,8BA2GQ,IAAIA,EAAMY,KAAmB8H,KAAK3H,KAClC,OAAOoK,GAASzD,OAAO1H,KA5G/B,qCAmHmBsN,GACX,IAAItN,EAAMY,KAA4B8H,KAAK3H,IAAKuM,GAChD,OAAe,IAARtN,OAAYP,EAAY8L,GAAS7D,OAAO1H,KArHvD,gCA4HQ,IACI,IAAMiH,EAASrG,MAAsC,IACrDA,KAAqBqG,EAAQyB,KAAK3H,KAClC,IAAIwG,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GACpCc,EAAKpF,IAAkBsE,EAAS,EAAI,GACpCuE,EAAK7I,IAAkBsE,EAAS,EAAI,GACpCnB,EAAOyB,EACPd,EAAOe,EACX,GAAIgE,EAEA,MADA1F,EAAO,EAAGW,EAAO,EACX1G,EAAWgI,GAErB,OAAOjH,EAAmBgF,EAAMW,GAbpC,QAeI7F,KAAqC,IACrCA,KAAqBkF,EAAMW,MA5IvC,oCAqJQ,IACI,IAAMQ,EAASrG,MAAsC,IACrDA,KAAyBqG,EAAQyB,KAAK3H,KACtC,IAAIwG,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWyH,GAErB,OAAOzH,EAAWwH,GATtB,QAWI3G,KAAqC,OAhKjD,wDAgMQ,IACI,IAAMqG,EAASrG,MAAsC,IACrDA,KAA6CqG,EAAQyB,KAAK3H,KAC1D,IAAIwG,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GACpCc,EAAKpF,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWgI,GAErB,IAAI+B,EAAKrE,EAAoB8B,EAAIC,GAAIjF,QAErC,OADA3B,KAAqB2G,EAAS,EAALC,GAClBsC,EAZX,QAcIlJ,KAAqC,OA9MjD,8CAsNQ,IACI,IAAMqG,EAASrG,MAAsC,IACrDA,KAAmCqG,EAAQyB,KAAK3H,KAChD,IAAIwG,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GACpCc,EAAKpF,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWgI,GAErB,IAAI+B,EAAKrE,EAAoB8B,EAAIC,GAAIjF,QAErC,OADA3B,KAAqB2G,EAAS,EAALC,GAClBsC,EAZX,QAcIlJ,KAAqC,QApOjD,iCAyKqB2J,GACb,IACI,IAAMtD,EAASrG,MAAsC,IACjDkF,EAAO9D,EAAkBuI,EAAM3J,KAAwBA,MACvD6F,EAAOrF,EACXR,KAAuBqG,EAAQnB,EAAMW,GACrC,IAAIc,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWyH,GAErB,OAAOiE,EAAQ/D,OAAOH,GAX1B,QAaI3G,KAAqC,OAvLjD,wCA4O6BkH,GACrB,IACI,IAAMb,EAASrG,MAAsC,IACjDkF,EAAOJ,EAAkBoC,EAAMlH,MAC/B6F,EAAOrF,EACXR,KAA+BqG,EAAQnB,EAAMW,GAC7C,IAAIc,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWyH,GAErB,OAAOiE,EAAQ/D,OAAOH,GAX1B,QAaI3G,KAAqC,SA1PjD,KAiQa2M,GAAb,WAyBI,WAAYpB,EAAOgB,GAAQ,oBACvB7H,EAAa6G,EAAOhB,IACpB7F,EAAa6H,EAAQE,IACrB,IAAIrN,EAAMY,KAA2BuL,EAAMpL,IAAKoM,EAAOpM,KACvD,OAAOwM,EAAkB7F,OAAO1H,GA7BxC,iEAUQ,IAAMe,EAAM2H,KAAK3H,IAGjB,OAFA2H,KAAK3H,IAAM,EAEJA,IAbf,6BAiBQ,IAAMA,EAAM2H,KAAKkB,qBACjBhJ,IAAkCG,MAlB1C,8BAEkBA,GACV,IAAMI,EAAM0H,OAAOmB,OAAOuD,EAAkBtD,WAG5C,OAFA9I,EAAIJ,IAAMA,EAEHI,MANf,6CAoCQ,IAAInB,EAAMY,KAA6B8H,KAAK3H,KAC5C,OAAOoK,GAASzD,OAAO1H,KArC/B,+BA4CQ,IAAIA,EAAMY,KAA8B8H,KAAK3H,KAC7C,OAAOsM,GAAO3F,OAAO1H,OA7C7B,KAmDakL,GAAb,WAuBI,aAAc,oBACV,IAAIlL,EAAMY,OACV,OAAOsK,EAAsBxD,OAAO1H,GAzB5C,iEAUQ,IAAMe,EAAM2H,KAAK3H,IAGjB,OAFA2H,KAAK3H,IAAM,EAEJA,IAbf,6BAiBQ,IAAMA,EAAM2H,KAAKkB,qBACjBhJ,IAAsCG,MAlB9C,8BAEkBA,GACV,IAAMI,EAAM0H,OAAOmB,OAAOkB,EAAsBjB,WAGhD,OAFA9I,EAAIJ,IAAMA,EAEHI,MANf,2CAiCQ,OADUP,KAA+B8H,KAAK3H,OAC/B,IAjCvB,0BAwCQ6J,GACA,IAAI5K,EAAMY,KAA+B8H,KAAK3H,IAAK6J,GACnD,OAAO2C,GAAkB7F,OAAO1H,KA1CxC,0BAgDQ2M,GACArH,EAAaqH,EAAMY,IACnB3M,KAA+B8H,KAAK3H,IAAK4L,EAAK5L,SAlDtD,KAwDayM,GAAb,6GAUQ,IAAMzM,EAAM2H,KAAK3H,IAGjB,OAFA2H,KAAK3H,IAAM,EAEJA,IAbf,6BAiBQ,IAAMA,EAAM2H,KAAKkB,qBACjBhJ,IAAiCG,KAlBzC,qCA+CmBuM,GACX,IAAItN,EAAMY,KAAqC8H,KAAK3H,IAAKuM,GACzD,OAAe,IAARtN,OAAYP,EAAY8L,GAAS7D,OAAO1H,KAjDvD,wCAyDQ,OADUY,KAAsC8H,KAAK3H,OACtC,IAzDvB,+BAgEQ,IAAIf,EAAMY,KAA6B8H,KAAK3H,KAC5C,OAAOsM,GAAO3F,OAAO1H,KAjE7B,kCAwEQ,IAAIA,EAAMY,KAAgC8H,KAAK3H,KAC/C,OAAOgJ,GAASrC,OAAO1H,KAzE/B,8BAgFQ,IAAIA,EAAMY,KAA4B8H,KAAK3H,KAC3C,OAAOoK,GAASzD,OAAO1H,KAjF/B,wDAyFQ,IACI,IAAMiH,EAASrG,MAAsC,IACrDA,KAAsDqG,EAAQyB,KAAK3H,KACnE,IAAIwG,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GACpCc,EAAKpF,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWgI,GAErB,IAAI+B,EAAKrE,EAAoB8B,EAAIC,GAAIjF,QAErC,OADA3B,KAAqB2G,EAAS,EAALC,GAClBsC,EAZX,QAcIlJ,KAAqC,QAvGjD,8BAEkBG,GACV,IAAMI,EAAM0H,OAAOmB,OAAOwD,EAAiBvD,WAG3C,OAFA9I,EAAIJ,IAAMA,EAEHI,IANf,wCA0B6BsM,EAAYT,GACjC,IACI,IAAM/F,EAASrG,MAAsC,IACrD0E,EAAamI,EAAYtC,IACzBvK,KAAwCqG,EAAQwG,EAAW1M,IAAKiM,GAChE,IAAIzF,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWyH,GAErB,OAAOgG,EAAiB9F,OAAOH,GAVnC,QAYI3G,KAAqC,SAvCjD,KA8Ga8M,GAAb,WA+BI,WAAYvB,EAAOc,EAAUD,GAAiB,oBAC1C1H,EAAa6G,EAAOhB,IACpB7F,EAAa2H,EAAUZ,IACvB,IAAIrM,EAAMY,KAAiCuL,EAAMpL,IAAKkM,EAASlM,IAAKiM,GACpE,OAAOU,EAAwBhG,OAAO1H,GAnC9C,iEAUQ,IAAMe,EAAM2H,KAAK3H,IAGjB,OAFA2H,KAAK3H,IAAM,EAEJA,IAbf,6BAiBQ,IAAMA,EAAM2H,KAAKkB,qBACjBhJ,IAAwCG,MAlBhD,8BAEkBA,GACV,IAAMI,EAAM0H,OAAOmB,OAAO0D,EAAwBzD,WAGlD,OAFA9I,EAAIJ,IAAMA,EAEHI,MANf,gEAyC+BwM,GACvB/M,KAAwD8H,KAAK3H,IAAK4M,KA1C1E,+CAkDQ,OADU/M,KAAoD8H,KAAK3H,OACpD,IAlDvB,gCAwDc6M,GACNtI,EAAasI,EAAWzC,IACxB,IAAIrF,EAAO8H,EAAU7M,IACrB6M,EAAU7M,IAAM,EAChBH,KAAuC8H,KAAK3H,IAAK+E,KA5DzD,8BAmEQ,IAAI9F,EAAMY,KAAmC8H,KAAK3H,KAClD,OAAOoK,GAASzD,OAAO1H,KApE/B,4CA2EQ,IACI,IAAMiH,EAASrG,MAAsC,IACrDA,KAAiDqG,EAAQyB,KAAK3H,KAC9D,IAAIwG,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWyH,GAErB,OAAOD,IAAO,EATlB,QAWI3G,KAAqC,OAtFjD,2CA8FQ,IACI,IAAMqG,EAASrG,MAAsC,IACrDA,KAAgDqG,EAAQyB,KAAK3H,KAC7D,IAAIwG,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWyH,GAErB,OAAO2D,GAASzD,OAAOH,GAT3B,QAWI3G,KAAqC,OAzGjD,yCAiHuB0M,EAAanB,GAC5B7G,EAAa6G,EAAOZ,IACpB3K,KAAgD8H,KAAK3H,IAAKuM,EAAanB,EAAMpL,OAnHrF,qCA0HmBuM,GACX,IAAItN,EAAMY,KAA4C8H,KAAK3H,IAAKuM,GAChE,OAAe,IAARtN,OAAYP,EAAY8L,GAAS7D,OAAO1H,KA5HvD,4CAkI0BsN,GAClB1M,KAAmD8H,KAAK3H,IAAKuM,KAnIrE,iCAgJeO,EAAOC,EAAYC,EAAYC,GACtC1I,EAAauI,EAAOI,IACpB,IAAInI,EAAO9D,EAAkB8L,EAAYlN,KAAwBA,MAC7D6F,EAAOrF,EACPgF,EAAOpE,EAAkB+L,EAAYnN,KAAwBA,MAC7D0H,EAAOlH,EACXR,KAAwC8H,KAAK3H,IAAK8M,EAAM9M,IAAK+E,EAAMW,EAAML,EAAMkC,EAAM0F,KAtJ7F,gCA6JcE,EAAUC,GAChB7I,EAAa4I,EAAUE,IACvB9I,EAAa6I,EAAQE,IACrBzN,KAAuC8H,KAAK3H,IAAKmN,EAASnN,IAAKoN,EAAOpN,OAhK9E,8BAuKQ,IACI,IAAMkG,EAASrG,MAAsC,IACrDA,KAAmCqG,EAAQyB,KAAK3H,KAChD,IAAIwG,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWyH,GAErB,OAAOgG,GAAiB9F,OAAOH,GATnC,QAWI3G,KAAqC,SAlLjD,KAyLa0N,GAAb,WAwBI,WAAYC,GAAe,oBACvBjJ,EAAaiJ,EAAef,IAC5B,IAAIxN,EAAMY,KAA2B2N,EAAcxN,KACnD,OAAOuN,EAAkB5G,OAAO1H,GA3BxC,iEAUQ,IAAMe,EAAM2H,KAAK3H,IAGjB,OAFA2H,KAAK3H,IAAM,EAEJA,IAbf,6BAiBQ,IAAMA,EAAM2H,KAAKkB,qBACjBhJ,IAAkCG,MAlB1C,8BAEkBA,GACV,IAAMI,EAAM0H,OAAOmB,OAAOsE,EAAkBrE,WAG5C,OAFA9I,EAAIJ,IAAMA,EAEHI,MANf,2CA4CQ,OADUP,KAA2B8H,KAAK3H,OAC3B,IA5CvB,0BAmDQ6J,GACA,IAAI5K,EAAMY,KAA2B8H,KAAK3H,IAAK6J,GAC/C,OAAO4C,GAAiB9F,OAAO1H,KArDvC,0BA2DQwE,GACAc,EAAad,EAAGgJ,IAChB5M,KAA2B8H,KAAK3H,IAAKyD,EAAEzD,QA7D/C,+BAmCQ,IAAIf,EAAMY,OACV,OAAO0N,EAAkB5G,OAAO1H,OApCxC,KAmEaoH,GAAb,WA8CI,WAAY5C,GAAG,oBACXc,EAAad,EAAGiH,IAChB,IAAIzL,EAAMY,KAAmB4D,EAAEzD,KAC/B,OAAOqG,EAAUM,OAAO1H,GAjDhC,iEAUQ,IAAMe,EAAM2H,KAAK3H,IAGjB,OAFA2H,KAAK3H,IAAM,EAEJA,IAbf,6BAiBQ,IAAMA,EAAM2H,KAAKkB,qBACjBhJ,IAA0BG,MAlBlC,8BAEkBA,GACV,IAAMI,EAAM0H,OAAOmB,OAAO5C,EAAU6C,WAGpC,OAFA9I,EAAIJ,IAAMA,EAEHI,IANf,sCAyB2BwJ,GACnB,IACI,IAAM1D,EAASrG,MAAsC,IACjDkF,EAAOV,EAAwBuF,EAAW/J,MAC1C6F,EAAOrF,EACXR,KAA+BqG,EAAQnB,EAAMW,GAC7C,IAAIc,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWyH,GAErB,OAAOJ,EAAUM,OAAOH,GAX5B,QAaI3G,KAAqC,SAvCjD,2CAyDQ,OADUA,KAAmB8H,KAAK3H,OACnB,IAzDvB,0BA+DQyD,GACAc,EAAad,EAAGiH,IAChB7K,KAAmB8H,KAAK3H,IAAKyD,EAAEzD,OAjEvC,0BAwEQ6J,GACA,IAAI5K,EAAMY,KAAmB8H,KAAK3H,IAAK6J,GACvC,OAAOa,GAAQ/D,OAAO1H,MA1E9B,+BAiFQ,IAAIA,EAAMY,OACV,OAAOwG,EAAUM,OAAO1H,OAlFhC,KAwFamH,GAAb,WAyBI,WAAYqH,EAAYC,GAAS,oBAC7B,IACI,IAAMxH,EAASrG,MAAsC,IACrD0E,EAAakJ,EAAYE,IACzB,IAAI5I,EAAO0I,EAAWzN,IACtByN,EAAWzN,IAAM,EACjBuE,EAAamJ,EAAS/D,GACtB,IAAItE,EAAOqI,EAAQ1N,IACnB0N,EAAQ1N,IAAM,EACdH,KAA0BqG,EAAQnB,EAAMM,GACxC,IAAImB,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWyH,GAErB,OAAOL,EAAiBO,OAAOH,GAfnC,QAiBI3G,KAAqC,KA3CjD,iEAUQ,IAAMG,EAAM2H,KAAK3H,IAGjB,OAFA2H,KAAK3H,IAAM,EAEJA,IAbf,6BAiBQ,IAAMA,EAAM2H,KAAKkB,qBACjBhJ,IAAiCG,MAlBzC,8BAEkBA,GACV,IAAMI,EAAM0H,OAAOmB,OAAO7C,EAAiB8C,WAG3C,OAFA9I,EAAIJ,IAAMA,EAEHI,MANf,KAkDa4I,GAAb,6GAUQ,IAAMhJ,EAAM2H,KAAK3H,IAGjB,OAFA2H,KAAK3H,IAAM,EAEJA,IAbf,6BAiBQ,IAAMA,EAAM2H,KAAKkB,qBACjBhJ,IAAyBG,KAlBjC,8CAqEQ,IACI,IAAMkG,EAASrG,MAAsC,IACrDA,KAAoCqG,EAAQyB,KAAK3H,KACjD,IAAIwG,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GACpCc,EAAKpF,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWgI,GAErB,IAAI+B,EAAKrE,EAAoB8B,EAAIC,GAAIjF,QAErC,OADA3B,KAAqB2G,EAAS,EAALC,GAClBsC,EAZX,QAcIlJ,KAAqC,OAnFjD,wCA2FQ,IACI,IAAMqG,EAASrG,MAAsC,IACrDA,KAA8BqG,EAAQyB,KAAK3H,KAC3C,IAAIwG,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GACpCc,EAAKpF,IAAkBsE,EAAS,EAAI,GACpCuE,EAAK7I,IAAkBsE,EAAS,EAAI,GACpCnB,EAAOyB,EACPd,EAAOe,EACX,GAAIgE,EAEA,MADA1F,EAAO,EAAGW,EAAO,EACX1G,EAAWgI,GAErB,OAAOjH,EAAmBgF,EAAMW,GAbpC,QAeI7F,KAAqC,IACrCA,KAAqBkF,EAAMW,MA3GvC,sCAoHQ,IACI,IAAMQ,EAASrG,MAAsC,IACrDA,KAA4BqG,EAAQyB,KAAK3H,KACzC,IAAIwG,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWyH,GAErB,OAAOD,IAAO,EATlB,QAWI3G,KAAqC,OA/HjD,mCAyIiBgK,GACT,IACI,IAAM3D,EAASrG,MAAsC,IACrDA,KAA2BqG,EAAQyB,KAAK3H,IAAK6J,GAC7C,IAAIrD,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWyH,GAErB,OAAc,IAAPD,OAAW9H,EAAY8L,GAAS7D,OAAOH,GATlD,QAWI3G,KAAqC,OArJjD,oCAgKkBgK,EAAO+D,GACjB,IACI,IAAM5N,EAAM2H,KAAKkB,qBACX3C,EAASrG,MAAsC,IACrD0E,EAAaqJ,EAAUpD,IACvB3K,KAA4BqG,EAAQlG,EAAK6J,EAAO+D,EAAS5N,KACzD,IAAIwG,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWyH,GAErB,OAAOuC,EAASrC,OAAOH,GAX3B,QAaI3G,KAAqC,OA9KjD,uCAuLQ,IACI,IAAMqG,EAASrG,MAAsC,IACrDA,KAA6BqG,EAAQyB,KAAK3H,KAC1C,IAAIwG,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GACpCc,EAAKpF,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWgI,GAErB,IAAI+B,EAAKrE,EAAoB8B,EAAIC,GAAIjF,QAErC,OADA3B,KAAqB2G,EAAS,EAALC,GAClBsC,EAZX,QAcIlJ,KAAqC,QArMjD,8BAEkBG,GACV,IAAMI,EAAM0H,OAAOmB,OAAOD,EAASE,WAGnC,OAFA9I,EAAIJ,IAAMA,EAEHI,IANf,wCAyB6BiJ,GACrB,IACI,IAAMnD,EAASrG,MAAsC,IACjDkF,EAAO9D,EAAkBoI,EAAGxJ,KAAwBA,MACpD6F,EAAOrF,EACXR,KAAgCqG,EAAQnB,EAAMW,GAC9C,IAAIc,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWyH,GAErB,OAAOuC,EAASrC,OAAOH,GAX3B,QAaI3G,KAAqC,OAvCjD,iCA+CsBkH,GACd,IACI,IAAMb,EAASrG,MAAsC,IACjDkF,EAAOJ,EAAkBoC,EAAMlH,MAC/B6F,EAAOrF,EACXR,KAAyBqG,EAAQnB,EAAMW,GACvC,IAAIc,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWyH,GAErB,OAAOuC,EAASrC,OAAOH,GAX3B,QAaI3G,KAAqC,SA7DjD,KA4MagO,GAAb,6GAUQ,IAAM7N,EAAM2H,KAAK3H,IAGjB,OAFA2H,KAAK3H,IAAM,EAEJA,IAbf,6BAiBQ,IAAMA,EAAM2H,KAAKkB,qBACjBhJ,IAA0BG,KAlBlC,4BAsDU6J,GACF,IACI,IAAM3D,EAASrG,MAAsC,IACrDA,KAAqBqG,EAAQyB,KAAK3H,IAAK6J,GACvC,IAAIrD,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWyH,GAErB,OAAOoH,EAAUlH,OAAOH,GAT5B,QAWI3G,KAAqC,OAlEjD,6BA0EWmM,GACH,IACI,IAAM9F,EAASrG,MAAsC,IACrD0E,EAAayH,EAAMH,IACnB,IAAI9G,EAAOiH,EAAKhM,IAChBgM,EAAKhM,IAAM,EACXH,KAAsBqG,EAAQyB,KAAK3H,IAAK+E,GACxC,IAAIyB,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWyH,GAErB,OAAOoH,EAAUlH,OAAOH,GAZ5B,QAcI3G,KAAqC,OAzFjD,mCAiGQ,IAAIZ,EAAMY,KAA0B8H,KAAK3H,KACzC,OAAOsH,EAAQX,OAAO1H,KAlG9B,mCAyGQ,IACI,IAAMiH,EAASrG,MAAsC,IACrDA,KAA0BqG,EAAQyB,KAAK3H,KACvC,IAAIwG,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GACpC6C,EAAKrE,EAAoB8B,EAAIC,GAAIjF,QAErC,OADA3B,KAAqB2G,EAAS,EAALC,GAClBsC,EAPX,QASIlJ,KAAqC,OAlHjD,sCA0HQ,IACI,IAAMqG,EAASrG,MAAsC,IACrDA,KAA6BqG,EAAQyB,KAAK3H,KAC1C,IAAIwG,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GACpC6C,EAAKrE,EAAoB8B,EAAIC,GAAIjF,QAErC,OADA3B,KAAqB2G,EAAS,EAALC,GAClBsC,EAPX,QASIlJ,KAAqC,QAnIjD,8BAEkBG,GACV,IAAMI,EAAM0H,OAAOmB,OAAO4E,EAAU3E,WAGpC,OAFA9I,EAAIJ,IAAMA,EAEHI,IANf,0BA4Be0N,EAAkBC,EAAYC,GACrC,IACI,IAAM9H,EAASrG,MAAsC,IACjDkF,EAAOJ,EAAkBmJ,EAAkBjO,MAC3C6F,EAAOrF,EACPgF,EAAOV,EAAkBoJ,EAAYlO,MACrC0H,EAAOlH,EACXkE,EAAayJ,EAAiBnC,IAC9BhM,KAAmBqG,EAAQnB,EAAMW,EAAML,EAAMkC,EAAMyG,EAAgBhO,KACnE,IAAIwG,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWyH,GAErB,OAAOoH,EAAUlH,OAAOH,GAd5B,QAgBI3G,KAAqC,SA7CjD,KA0IaoO,GAAb,6GAUQ,IAAMjO,EAAM2H,KAAK3H,IAGjB,OAFA2H,KAAK3H,IAAM,EAEJA,IAbf,6BAiBQ,IAAMA,EAAM2H,KAAKkB,qBACjBhJ,IAA6BG,KAlBrC,4BA4EU6J,GACF,IACI,IAAM3D,EAASrG,MAAsC,IACjDkF,EAAO9D,EAAkB4I,EAAOhK,KAAwBA,MACxD6F,EAAOrF,EACXR,KAAwBqG,EAAQyB,KAAK3H,IAAK+E,EAAMW,GAChD,IAAIc,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWyH,GAErB,OAAOwH,EAAatH,OAAOH,GAX/B,QAaI3G,KAAqC,OA1FjD,6BAkGWmM,GACH,IACI,IAAM9F,EAASrG,MAAsC,IACrD0E,EAAayH,EAAMH,IACnB,IAAI9G,EAAOiH,EAAKhM,IAChBgM,EAAKhM,IAAM,EACXH,KAAyBqG,EAAQyB,KAAK3H,IAAK+E,GAC3C,IAAIyB,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWyH,GAErB,OAAOwH,EAAatH,OAAOH,GAZ/B,QAcI3G,KAAqC,OAjHjD,yCAyHQ,IACI,IAAMqG,EAASrG,MAAsC,IACrDA,KAAmCqG,EAAQyB,KAAK3H,KAChD,IAAIwG,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GACpCc,EAAKpF,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWgI,GAErB,IAAI+B,EAAKrE,EAAoB8B,EAAIC,GAAIjF,QAErC,OADA3B,KAAqB2G,EAAS,EAALC,GAClBsC,EAZX,QAcIlJ,KAAqC,OAvIjD,mCA+IQ,IACI,IAAMqG,EAASrG,MAAsC,IACrDA,KAA6BqG,EAAQyB,KAAK3H,KAC1C,IAAIwG,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWyH,GAErB,OAAOoH,GAAUlH,OAAOH,GAT5B,QAWI3G,KAAqC,OA1JjD,6BAkKQ,IAAIZ,EAAMY,KAAuB8H,KAAK3H,KACtC,OAAO6L,GAAelF,OAAO1H,MAnKrC,8BAEkBe,GACV,IAAMI,EAAM0H,OAAOmB,OAAOgF,EAAa/E,WAGvC,OAFA9I,EAAIJ,IAAMA,EAEHI,IANf,0BA2Be8N,EAAkBH,EAAYC,GACrC,IACI,IAAM9H,EAASrG,MAAsC,IACjDkF,EAAOJ,EAAkBuJ,EAAkBrO,MAC3C6F,EAAOrF,EACPgF,EAAOV,EAAkBoJ,EAAYlO,MACrC0H,EAAOlH,EACXkE,EAAayJ,EAAiBnC,IAC9BhM,KAAsBqG,EAAQnB,EAAMW,EAAML,EAAMkC,EAAMyG,EAAgBhO,KACtE,IAAIwG,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWyH,GAErB,OAAOwH,EAAatH,OAAOH,GAd/B,QAgBI3G,KAAqC,OA5CjD,oCAoDyBsO,GACjB,IACI,IAAMjI,EAASrG,MAAsC,IACjDkF,EAAOJ,EAAkBwJ,EAAYtO,MACrC6F,EAAOrF,EACXR,KAAgCqG,EAAQnB,EAAMW,GAC9C,IAAIc,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWyH,GAErB,OAAOwH,EAAatH,OAAOH,GAX/B,QAaI3G,KAAqC,SAlEjD,KAyKauO,GAAb,6GAUQ,IAAMpO,EAAM2H,KAAK3H,IAGjB,OAFA2H,KAAK3H,IAAM,EAEJA,IAbf,6BAiBQ,IAAMA,EAAM2H,KAAKkB,qBACjBhJ,IAAyBG,KAlBjC,qCAgCmBqO,GACX9J,EAAa8J,EAAM9D,IACnB,IAAIxF,EAAOsJ,EAAKrO,IAChBqO,EAAKrO,IAAM,EACXH,KAA6B8H,KAAK3H,IAAK+E,KApC/C,4BA4CQ,OADUlF,KAAkB8H,KAAK3H,OAClB,IA5CvB,0BAmDQ6J,GACA,IACI,IAAM3D,EAASrG,MAAsC,IACrDA,KAAkBqG,EAAQyB,KAAK3H,IAAK6J,GACpC,IAAIrD,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWyH,GAErB,OAAO8D,GAAe5D,OAAOH,GATjC,QAWI3G,KAAqC,QA/DjD,8BAEkBG,GACV,IAAMI,EAAM0H,OAAOmB,OAAOmF,EAASlF,WAGnC,OAFA9I,EAAIJ,IAAMA,EAEHI,IANf,8BAyBQ,IAAInB,EAAMY,OACV,OAAOuO,EAASzH,OAAO1H,OA1B/B,KAsEaoL,GAAb,6GAUQ,IAAMrK,EAAM2H,KAAK3H,IAGjB,OAFA2H,KAAK3H,IAAM,EAEJA,IAbf,6BAiBQ,IAAMA,EAAM2H,KAAKkB,qBACjBhJ,IAAoBG,KAlB5B,+BA+CQ,IACI,IAAMkG,EAASrG,MAAsC,IACrDA,KAAgBqG,EAAQyB,KAAK3H,KAC7B,IAAIwG,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GACxC,OAAOnG,EAAmByG,EAAIC,GALlC,QAOI5G,KAAqC,IACrCA,KAAqB2G,EAAIC,MAvDrC,+BAgEQ,OAAOzH,EADGa,KAAgB8H,KAAK3H,QA/DvC,kCAuEgBsO,GACR,IACI,IAAMpI,EAASrG,MAAsC,IACrD0E,EAAa+J,EAAOjE,GACpBxK,KAAqBqG,EAAQyB,KAAK3H,IAAKsO,EAAMtO,KAC7C,IAAIwG,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWyH,GAErB,OAAO4D,EAAI1D,OAAOH,GAVtB,QAYI3G,KAAqC,QApFjD,8BAEkBG,GACV,IAAMI,EAAM0H,OAAOmB,OAAOoB,EAAInB,WAG9B,OAFA9I,EAAIJ,IAAMA,EAEHI,IANf,+BAyBoBmO,GACZ,IACI,IAAMrI,EAASrG,MAAsC,IACjDkF,EAAO9D,EAAkBsN,EAAQ1O,KAAwBA,MACzD6F,EAAOrF,EACXR,KAAkBqG,EAAQnB,EAAMW,GAChC,IAAIc,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWyH,GAErB,OAAO4D,EAAI1D,OAAOH,GAXtB,QAaI3G,KAAqC,SAvCjD,KA2Fa2O,GAAb,6GAUQ,IAAMxO,EAAM2H,KAAK3H,IAGjB,OAFA2H,KAAK3H,IAAM,EAEJA,IAbf,6BAiBQ,IAAMA,EAAM2H,KAAKkB,qBACjBhJ,IAAsBG,KAlB9B,+BAyBQ,IAAIf,EAAMY,KAAkB8H,KAAK3H,KACjC,OAAO8J,EAAMnD,OAAO1H,KA1B5B,uCAiCQ,IAAIA,EAAMY,KAA0B8H,KAAK3H,KACzC,OAAOyO,GAAa9H,OAAO1H,MAlCnC,8BAEkBe,GACV,IAAMI,EAAM0H,OAAOmB,OAAOuF,EAAMtF,WAGhC,OAFA9I,EAAIJ,IAAMA,EAEHI,MANf,KAwCasO,GAAb,WAuBI,aAAc,oBACV,IAAIzP,EAAMY,OACV,OAAO6O,EAAO/H,OAAO1H,GAzB7B,iEAUQ,IAAMe,EAAM2H,KAAK3H,IAGjB,OAFA2H,KAAK3H,IAAM,EAEJA,IAbf,6BAiBQ,IAAMA,EAAM2H,KAAKkB,qBACjBhJ,IAAuBG,MAlB/B,8BAEkBA,GACV,IAAMI,EAAM0H,OAAOmB,OAAOyF,EAAOxF,WAGjC,OAFA9I,EAAIJ,IAAMA,EAEHI,MANf,2CAiCQ,OADUP,KAAgB8H,KAAK3H,OAChB,IAjCvB,0BAwCQ6J,GACA,IAAI5K,EAAMY,KAAgB8H,KAAK3H,IAAK6J,GACpC,OAAO2E,GAAM7H,OAAO1H,OA1C5B,KAgDa0P,GAAb,6GAUQ,IAAM3O,EAAM2H,KAAK3H,IAGjB,OAFA2H,KAAK3H,IAAM,EAEJA,IAbf,6BAiBQ,IAAMA,EAAM2H,KAAKkB,qBACjBhJ,IAA0BG,KAlBlC,6BAgDQ,IACI,IAAMkG,EAASrG,MAAsC,IACrDA,KAAsBqG,EAAQyB,KAAK3H,KACnC,IAAIwG,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GACpC6C,EAAKrE,EAAoB8B,EAAIC,GAAIjF,QAErC,OADA3B,KAAqB2G,EAAS,EAALC,GAClBsC,EAPX,QASIlJ,KAAqC,OAzDjD,2BAkEQ,OADUA,KAAoB8H,KAAK3H,QAjE3C,8BAEkBA,GACV,IAAMI,EAAM0H,OAAOmB,OAAO0F,EAAUzF,WAGpC,OAFA9I,EAAIJ,IAAMA,EAEHI,IANf,0BA0BewO,EAAMC,GACb,IACI,IAAM3I,EAASrG,MAAsC,IACjDkF,EAAOJ,EAAkBiK,EAAM/O,MAC/B6F,EAAOrF,EACXR,KAAmBqG,EAAQnB,EAAMW,EAAMmJ,GACvC,IAAIrI,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWyH,GAErB,OAAOkI,EAAUhI,OAAOH,GAX5B,QAaI3G,KAAqC,SAxCjD,KAwEaiP,GAAb,6GAUQ,IAAM9O,EAAM2H,KAAK3H,IAGjB,OAFA2H,KAAK3H,IAAM,EAEJA,IAbf,6BAiBQ,IAAMA,EAAM2H,KAAKkB,qBACjBhJ,IAA4BG,KAlBpC,+BAsCa+O,GACLxK,EAAawK,EAAOJ,IACpB9O,KAA0B8H,KAAK3H,IAAK+O,EAAM/O,OAxClD,4BA+CUuJ,GACF,IAAIxE,EAAOJ,EAAkB4E,EAAe1J,MACxC6F,EAAOrF,EAEX,OAAe,IADLR,KAAuB8H,KAAK3H,IAAK+E,EAAMW,MAlDzD,8BAEkB1F,GACV,IAAMI,EAAM0H,OAAOmB,OAAO6F,EAAY5F,WAGtC,OAFA9I,EAAIJ,IAAMA,EAEHI,IANf,0BA4Be4O,GACP,IAAIjK,EAAOJ,EAAkBqK,EAAWnP,MACpC6F,EAAOrF,EACPpB,EAAMY,KAAqBkF,EAAMW,GACrC,OAAOoJ,EAAYnI,OAAO1H,OAhClC,KAyDagQ,GAAb,6GAGQ,IAAMjP,EAAM2H,KAAK3H,IAGjB,OAFA2H,KAAK3H,IAAM,EAEJA,IANf,6BAUQ,IAAMA,EAAM2H,KAAKkB,qBACjBhJ,IAA6BG,MAXrC,6CAkBQ,IACI,IAAMkG,EAASrG,MAAsC,IACrDA,KAAsCqG,GACtC,IAAIM,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GACxC,OAAOnG,EAAmByG,EAAIC,GALlC,QAOI5G,KAAqC,IACrCA,KAAqB2G,EAAIC,MA1BrC,4CAkCQ,IACI,IAAMP,EAASrG,MAAsC,IACrDA,KAAsCqG,GACtC,IAAIM,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GACxC,OAAOnG,EAAmByG,EAAIC,GALlC,QAOI5G,KAAqC,IACrCA,KAAqB2G,EAAIC,QA1CrC,KAiDayI,GAAb,6GAGQ,IAAMlP,EAAM2H,KAAK3H,IAGjB,OAFA2H,KAAK3H,IAAM,EAEJA,IANf,6BAUQ,IAAMA,EAAM2H,KAAKkB,qBACjBhJ,IAAyBG,MAXjC,+BAoBmBmP,EAAiBC,GAC5B,IACI,IAAMlJ,EAASrG,MAAsC,IACjDkF,EAAO9D,EAAkBkO,EAAiBtP,KAAwBA,MAClE6F,EAAOrF,EACPgF,EAAOpE,EAAkBmO,EAAevP,KAAwBA,MAChE0H,EAAOlH,EACXR,KAAsBqG,EAAQnB,EAAMW,EAAML,EAAMkC,GAChD,IAAIf,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GACpCmJ,EAAK3K,EAAoB8B,EAAIC,GAAIjF,QAErC,OADA3B,KAAqB2G,EAAS,EAALC,GAClB4I,EAXX,QAaIxP,KAAqC,SAlCjD,KA0CayP,GAAb,6GAUQ,IAAMtP,EAAM2H,KAAK3H,IAGjB,OAFA2H,KAAK3H,IAAM,EAEJA,IAbf,6BAiBQ,IAAMA,EAAM2H,KAAKkB,qBACjBhJ,IAA+BG,KAlBvC,kCA0DQ,IACI,IAAMkG,EAASrG,MAAsC,IACrDA,KAA8BqG,EAAQyB,KAAK3H,KAC3C,IAAIwG,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GACxC,OAAOnG,EAAmByG,EAAIC,GALlC,QAOI5G,KAAqC,IACrCA,KAAqB2G,EAAIC,MAlErC,iCAgGQ,IACI,IAAMP,EAASrG,MAAsC,IACrDA,KAA6BqG,EAAQyB,KAAK3H,KAC1C,IAAIwG,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GACpC6C,EAAKrE,EAAoB8B,EAAIC,GAAIjF,QAErC,OADA3B,KAAqB2G,EAAS,EAALC,GAClBsC,EAPX,QASIlJ,KAAqC,OAzGjD,gCAkHQ,OADUA,KAA4B8H,KAAK3H,OAC5B,IAlHvB,gCAyHQ,IAAIf,EAAMY,KAA4B8H,KAAK3H,KAC3C,OAAOsH,EAAQX,OAAO1H,MA1H9B,8BAEkBe,GACV,IAAMI,EAAM0H,OAAOmB,OAAOqG,EAAepG,WAGzC,OAFA9I,EAAIJ,IAAMA,EAEHI,IANf,0BA0BemP,EAASnI,GAChB7C,EAAa6C,EAASE,GACtB,IAAIrI,EAAMY,KAAwB0P,EAASnI,EAAQpH,KACnD,OAAOsP,EAAe3I,OAAO1H,KA7BrC,kCAoCuBoK,GACf,IACI,IAAMnD,EAASrG,MAAsC,IACjDkF,EAAO9D,EAAkBoI,EAAGxJ,KAAwBA,MACpD6F,EAAOrF,EACXR,KAAgCqG,EAAQnB,EAAMW,GAC9C,IAAIc,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWyH,GAErB,OAAO6I,EAAe3I,OAAOH,GAXjC,QAaI3G,KAAqC,OAlDjD,iCA0EsBkH,GACd,IACI,IAAMb,EAASrG,MAAsC,IACjDkF,EAAOJ,EAAkBoC,EAAMlH,MAC/B6F,EAAOrF,EACXR,KAA+BqG,EAAQnB,EAAMW,GAC7C,IAAIc,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWyH,GAErB,OAAO6I,EAAe3I,OAAOH,GAXjC,QAaI3G,KAAqC,SAxFjD,KAgIa2P,GAAb,6GAUQ,IAAMxP,EAAM2H,KAAK3H,IAGjB,OAFA2H,KAAK3H,IAAM,EAEJA,IAbf,6BAiBQ,IAAMA,EAAM2H,KAAKkB,qBACjBhJ,IAA6BG,MAlBrC,8BAEkBA,GACV,IAAMI,EAAM0H,OAAOmB,OAAOuG,EAAatG,WAGvC,OAFA9I,EAAIJ,IAAMA,EAEHI,MANf,KAyBaqP,GAAb,6GAGQ,IAAMzP,EAAM2H,KAAK3H,IAGjB,OAFA2H,KAAK3H,IAAM,EAEJA,IANf,6BAUQ,IAAMA,EAAM2H,KAAKkB,qBACjBhJ,IAAgCG,OAXxC,KAiBa8E,GAAb,WAyBI,WAAY4K,GAAM,oBACd,IACI,IAAMxJ,EAASrG,MAAsC,IACjDkF,EAAO9D,EAAkByO,EAAM7P,KAAwBA,MACvD6F,EAAOrF,EACXR,KAAkBqG,EAAQnB,EAAMW,GAChC,IAAIc,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWyH,GAErB,OAAO3B,EAAS6B,OAAOH,GAX3B,QAaI3G,KAAqC,KAvCjD,iEAUQ,IAAMG,EAAM2H,KAAK3H,IAGjB,OAFA2H,KAAK3H,IAAM,EAEJA,IAbf,6BAiBQ,IAAMA,EAAM2H,KAAKkB,qBACjBhJ,IAAyBG,MAlBjC,8BAEkBA,GACV,IAAMI,EAAM0H,OAAOmB,OAAOnE,EAASoE,WAGnC,OAFA9I,EAAIJ,IAAMA,EAEHI,MANf,KAiDauP,GAAb,6GAUQ,IAAM3P,EAAM2H,KAAK3H,IAGjB,OAFA2H,KAAK3H,IAAM,EAEJA,IAbf,6BAiBQ,IAAMA,EAAM2H,KAAKkB,qBACjBhJ,IAAyBG,KAlBjC,4BA0BQ,OADUH,KAAkB8H,KAAK3H,OAClB,IA1BvB,0BAiCQ6J,GAEA,OAAO7K,EADGa,KAAkB8H,KAAK3H,IAAK6J,OAlC9C,8BAEkB7J,GACV,IAAMI,EAAM0H,OAAOmB,OAAO0G,EAASzG,WAGnC,OAFA9I,EAAIJ,IAAMA,EAEHI,MANf,KAyCawP,GAAb,6GAGQ,IAAM5P,EAAM2H,KAAK3H,IAGjB,OAFA2H,KAAK3H,IAAM,EAEJA,IANf,6BAUQ,IAAMA,EAAM2H,KAAKkB,qBACjBhJ,IAA4BG,KAXpC,+BAkBQ,IAAIf,EAAMY,KAAwB8H,KAAK3H,KACvC,OAAO0J,EAAY/C,OAAO1H,KAnBlC,mCA0BQ,IACI,IAAMiH,EAASrG,MAAsC,IACrDA,KAA4BqG,EAAQyB,KAAK3H,KACzC,IAAIwG,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWyH,GAErB,OAAOzH,EAAWwH,GATtB,QAWI3G,KAAqC,OArCjD,yCA6CQ,IAAIZ,EAAMY,KAAkC8H,KAAK3H,KACjD,OAAOsJ,EAAiB3C,OAAO1H,KA9CvC,+CAsDQ,OAAe,IADLY,KAAwC8H,KAAK3H,OArD/D,+BA8DQ,OADUH,KAAwB8H,KAAK3H,OACxB,IA9DvB,2BAqEQ,IAAIf,EAAMY,KAAoB8H,KAAK3H,KACnC,OAAOoF,EAAQuB,OAAO1H,OAtE9B,KA6Ea0O,GAAb,6GAUQ,IAAM3N,EAAM2H,KAAK3H,IAGjB,OAFA2H,KAAK3H,IAAM,EAEJA,IAbf,6BAiBQ,IAAMA,EAAM2H,KAAKkB,qBACjBhJ,IAA0BG,MAlBlC,8BAEkBA,GACV,IAAMI,EAAM0H,OAAOmB,OAAO0E,EAAUzE,WAGpC,OAFA9I,EAAIJ,IAAMA,EAEHI,IANf,wCAyB6ByP,GACrBtL,EAAasL,EAAcnG,GAC3B,IAAI3E,EAAO8K,EAAa7P,IACxB6P,EAAa7P,IAAM,EACnB,IAAIf,EAAMY,KAAiCkF,GAC3C,OAAO4I,EAAUhH,OAAO1H,OA9BhC,KAoCaqH,GAAb,WAuBI,aAAc,oBACV,IAAIrH,EAAMY,OACV,OAAOyG,EAAaK,OAAO1H,GAzBnC,iEAUQ,IAAMe,EAAM2H,KAAK3H,IAGjB,OAFA2H,KAAK3H,IAAM,EAEJA,IAbf,6BAiBQ,IAAMA,EAAM2H,KAAKkB,qBACjBhJ,IAA6BG,MAlBrC,8BAEkBA,GACV,IAAMI,EAAM0H,OAAOmB,OAAO3C,EAAa4C,WAGvC,OAFA9I,EAAIJ,IAAMA,EAEHI,MANf,+DA+B8B0P,GACtB,IACI,IAAM5J,EAASrG,MAAsC,IACjDkF,EAAOJ,EAAkBmL,EAAajQ,MACtC6F,EAAOrF,EACXR,KAA4CqG,EAAQyB,KAAK3H,IAAK+E,EAAMW,GACpE,IAAIc,EAAK5E,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWwH,GARzB,QAWI3G,KAAqC,SA3CjD,KAkDa4O,GAAb,6GAUQ,IAAMzO,EAAM2H,KAAK3H,IAGjB,OAFA2H,KAAK3H,IAAM,EAEJA,IAbf,6BAiBQ,IAAMA,EAAM2H,KAAKkB,qBACjBhJ,IAA6BG,KAlBrC,8BAyBQ,IACI,IAAMkG,EAASrG,MAAsC,IACrDA,KAAwBqG,EAAQyB,KAAK3H,KACrC,IAAIwG,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GACpC6C,EAAKrE,EAAoB8B,EAAIC,GAAIjF,QAErC,OADA3B,KAAqB2G,EAAS,EAALC,GAClBsC,EAPX,QASIlJ,KAAqC,OAlCjD,kCA0CQ,IAAIZ,EAAMY,KAA4B8H,KAAK3H,KAC3C,OAAOkL,GAAiBvE,OAAO1H,KA3CvC,gCAkDQ,IACI,IAAMiH,EAASrG,MAAsC,IACrDA,KAA0BqG,EAAQyB,KAAK3H,KACvC,IAAIwG,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GACpCc,EAAKpF,IAAkBsE,EAAS,EAAI,GACpCuE,EAAK7I,IAAkBsE,EAAS,EAAI,GACpCnB,EAAOyB,EACPd,EAAOe,EACX,GAAIgE,EAEA,MADA1F,EAAO,EAAGW,EAAO,EACX1G,EAAWgI,GAErB,OAAOjH,EAAmBgF,EAAMW,GAbpC,QAeI7F,KAAqC,IACrCA,KAAqBkF,EAAMW,OAlEvC,8BAEkB1F,GACV,IAAMI,EAAM0H,OAAOmB,OAAOwF,EAAavF,WAGvC,OAFA9I,EAAIJ,IAAMA,EAEHI,MANf,KA+Ea2P,GAAb,6GAUQ,IAAM/P,EAAM2H,KAAK3H,IAGjB,OAFA2H,KAAK3H,IAAM,EAEJA,IAbf,6BAiBQ,IAAMA,EAAM2H,KAAKkB,qBACjBhJ,IAAmCG,KAlB3C,8CAqDQ,IACI,IAAMkG,EAASrG,MAAsC,IACrDA,KAA8CqG,EAAQyB,KAAK3H,KAC3D,IAAIwG,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GACpCc,EAAKpF,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWgI,GAErB,IAAI+B,EAAKrE,EAAoB8B,EAAIC,GAAIjF,QAErC,OADA3B,KAAqB2G,EAAS,EAALC,GAClBsC,EAZX,QAcIlJ,KAAqC,OAnEjD,oCAiGQ,IAAIZ,EAAMY,KAAoC8H,KAAK3H,KACnD,OAAOgQ,GAAoBrJ,OAAO1H,MAlG1C,8BAEkBe,GACV,IAAMI,EAAM0H,OAAOmB,OAAO8G,EAAmB7G,WAG7C,OAFA9I,EAAIJ,IAAMA,EAEHI,IANf,uCA6B4B6P,EAAanK,EAAgBC,EAAYF,GAC7D,IACI,IAAMK,EAASrG,MAAsC,IACrD0E,EAAa0L,EAAaD,IAC1BzL,EAAauB,EAAgBO,IAC7B9B,EAAawB,EAAYM,IACzB9B,EAAasB,EAAeO,IAC5BvG,KAAyCqG,EAAQ+J,EAAYjQ,IAAK8F,EAAe9F,IAAK+F,EAAW/F,IAAK6F,EAAc7F,KACpH,IAAIwG,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWyH,GAErB,OAAOsJ,EAAmBpJ,OAAOH,GAbrC,QAeI3G,KAAqC,OA7CjD,wCA2E6BkH,GACrB,IACI,IAAMb,EAASrG,MAAsC,IACjDkF,EAAOJ,EAAkBoC,EAAMlH,MAC/B6F,EAAOrF,EACXR,KAA0CqG,EAAQnB,EAAMW,GACxD,IAAIc,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWyH,GAErB,OAAOsJ,EAAmBpJ,OAAOH,GAXrC,QAaI3G,KAAqC,SAzFjD,KAwGaqQ,GAAb,6GAUQ,IAAMlQ,EAAM2H,KAAK3H,IAGjB,OAFA2H,KAAK3H,IAAM,EAEJA,IAbf,6BAiBQ,IAAMA,EAAM2H,KAAKkB,qBACjBhJ,IAA0BG,KAlBlC,oCAuDQ,IAAIf,EAAMY,KAA2B8H,KAAK3H,KAC1C,OAAOsH,EAAQX,OAAO1H,KAxD9B,iCA+DQ,IACI,IAAMiH,EAASrG,MAAsC,IACrDA,KAAwBqG,EAAQyB,KAAK3H,KACrC,IAAIwG,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GACpC6C,EAAKrE,EAAoB8B,EAAIC,GAAIjF,QAErC,OADA3B,KAAqB2G,EAAS,EAALC,GAClBsC,EAPX,QASIlJ,KAAqC,QAxEjD,8BAEkBG,GACV,IAAMI,EAAM0H,OAAOmB,OAAOiH,EAAUhH,WAGpC,OAFA9I,EAAIJ,IAAMA,EAEHI,IANf,oCAyBQ,IAAInB,EAAMY,OACV,OAAOqQ,EAAUvJ,OAAO1H,KA1BhC,sCAiC2BmK,GACnB,IACI,IAAMlD,EAASrG,MAAsC,IACjDkF,EAAOJ,EAAkByE,EAAOvJ,MAChC6F,EAAOrF,EACXR,KAA+BqG,EAAQnB,EAAMW,GAC7C,IAAIc,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWyH,GAErB,OAAOyJ,EAAUvJ,OAAOH,GAX5B,QAaI3G,KAAqC,SA/CjD,KA+EasQ,GAAb,WAuBI,aAAc,oBACV,IAAIlR,EAAMY,OACV,OAAOsQ,EAAWxJ,OAAO1H,GAzBjC,iEAUQ,IAAMe,EAAM2H,KAAK3H,IAGjB,OAFA2H,KAAK3H,IAAM,EAEJA,IAbf,6BAiBQ,IAAMA,EAAM2H,KAAKkB,qBACjBhJ,IAA2BG,MAlBnC,8BAEkBA,GACV,IAAMI,EAAM0H,OAAOmB,OAAOkH,EAAWjH,WAGrC,OAFA9I,EAAIJ,IAAMA,EAEHI,MANf,2CAiCQ,OADUP,KAAoB8H,KAAK3H,OACpB,IAjCvB,0BAwCQ6J,GACA,IAAI5K,EAAMY,KAAoB8H,KAAK3H,IAAK6J,GACxC,OAAOqG,GAAUvJ,OAAO1H,KA1ChC,0BAgDQ2M,GACArH,EAAaqH,EAAMsE,IACnBrQ,KAAoB8H,KAAK3H,IAAK4L,EAAK5L,SAlD3C,KAwDaoQ,GAAb,WAuBI,aAAc,oBACV,IAAInR,EAAMY,OACV,OAAOuQ,EAAkBzJ,OAAO1H,GAzBxC,iEAUQ,IAAMe,EAAM2H,KAAK3H,IAGjB,OAFA2H,KAAK3H,IAAM,EAEJA,IAbf,6BAiBQ,IAAMA,EAAM2H,KAAKkB,qBACjBhJ,IAAkCG,MAlB1C,8BAEkBA,GACV,IAAMI,EAAM0H,OAAOmB,OAAOmH,EAAkBlH,WAG5C,OAFA9I,EAAIJ,IAAMA,EAEHI,MANf,4CAsCWiQ,EAAQC,EAAgBC,GAC3B,IACI,IAAMrK,EAASrG,MAAsC,IACrD0E,EAAa8L,EAAQhK,IACrB9B,EAAa+L,EAAgBlG,IAC7B7F,EAAagM,EAAejE,IAC5BzM,KAA8BqG,EAAQyB,KAAK3H,IAAKqQ,EAAOrQ,IAAKsQ,EAAetQ,IAAKuQ,EAAcvQ,KAC9F,IAAIwG,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWyH,GAErB,OAAOuD,EAAarD,OAAOH,GAZ/B,QAcI3G,KAAqC,SArDjD,KA4DaqN,GAAb,WAyBI,WAAYC,EAAUC,GAAQ,oBAC1B7I,EAAa4I,EAAUE,IACvB9I,EAAa6I,EAAQE,IACrB,IAAIrO,EAAMY,KAAesN,EAASnN,IAAKoN,EAAOpN,KAC9C,OAAOkN,EAAMvG,OAAO1H,GA7B5B,iEAUQ,IAAMe,EAAM2H,KAAK3H,IAGjB,OAFA2H,KAAK3H,IAAM,EAEJA,IAbf,6BAiBQ,IAAMA,EAAM2H,KAAKkB,qBACjBhJ,IAAsBG,MAlB9B,8BAEkBA,GACV,IAAMI,EAAM0H,OAAOmB,OAAOiE,EAAMhE,WAGhC,OAFA9I,EAAIJ,IAAMA,EAEHI,MANf,0CAoCQ,IAAInB,EAAMY,KAAc8H,KAAK3H,KAC7B,OAAOqN,GAAQ1G,OAAO1H,KArC9B,+BA4CQ,IAAIA,EAAMY,KAAkB8H,KAAK3H,KACjC,OAAOsN,GAAY3G,OAAO1H,KA7ClC,gCAoDQ,IACI,IAAMiH,EAASrG,MAAsC,IACrDA,KAAmBqG,EAAQyB,KAAK3H,KAChC,IAAIwG,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GACpCc,EAAKpF,IAAkBsE,EAAS,EAAI,GACpCuE,EAAK7I,IAAkBsE,EAAS,EAAI,GACpCnB,EAAOyB,EACPd,EAAOe,EACX,GAAIgE,EAEA,MADA1F,EAAO,EAAGW,EAAO,EACX1G,EAAWgI,GAErB,OAAOjH,EAAmBgF,EAAMW,GAbpC,QAeI7F,KAAqC,IACrCA,KAAqBkF,EAAMW,MApEvC,oCA6EQ,IACI,IAAMQ,EAASrG,MAAsC,IACrDA,KAAuBqG,EAAQyB,KAAK3H,KACpC,IAAIwG,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWyH,GAErB,OAAOzH,EAAWwH,GATtB,QAWI3G,KAAqC,SAxFjD,KA+FayN,GAAb,6GAUQ,IAAMtN,EAAM2H,KAAK3H,IAGjB,OAFA2H,KAAK3H,IAAM,EAEJA,IAbf,6BAiBQ,IAAMA,EAAM2H,KAAKkB,qBACjBhJ,IAA4BG,KAlBpC,+BA8CQ,IAAIf,EAAMY,KAAwB8H,KAAK3H,KACvC,OAAOqK,GAAI1D,OAAO1H,KA/C1B,iCAsDQ,IACI,IAAMiH,EAASrG,MAAsC,IACrDA,KAA0BqG,EAAQyB,KAAK3H,KACvC,IAAIwG,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GACpC6C,EAAKrE,EAAoB8B,EAAIC,GAAIjF,QAErC,OADA3B,KAAqB2G,EAAS,EAALC,GAClBsC,EAPX,QASIlJ,KAAqC,QA/DjD,8BAEkBG,GACV,IAAMI,EAAM0H,OAAOmB,OAAOqE,EAAYpE,WAGtC,OAFA9I,EAAIJ,IAAMA,EAEHI,IANf,+BAyBoBkK,GACZ,IACI,IAAMpE,EAASrG,MAAsC,IACrD0E,EAAa+F,EAAGD,IAChBxK,KAA0BqG,EAAQoE,EAAEtK,KACpC,IAAIwG,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWyH,GAErB,OAAO6G,EAAY3G,OAAOH,GAV9B,QAYI3G,KAAqC,SAtCjD,KAsEawN,GAAb,6GAUQ,IAAMrN,EAAM2H,KAAK3H,IAGjB,OAFA2H,KAAK3H,IAAM,EAEJA,IAbf,6BAiBQ,IAAMA,EAAM2H,KAAKkB,qBACjBhJ,IAAwBG,KAlBhC,+BAyDQ,IACI,IAAMkG,EAASrG,MAAsC,IACrDA,KAAoBqG,EAAQyB,KAAK3H,KACjC,IAAIwG,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GACxC,OAAOnG,EAAmByG,EAAIC,GALlC,QAOI5G,KAAqC,IACrCA,KAAqB2G,EAAIC,MAjErC,iCA0EQ,OAAOzH,EADGa,KAAsB8H,KAAK3H,SAzE7C,8BAEkBA,GACV,IAAMI,EAAM0H,OAAOmB,OAAOoE,EAAQnE,WAGlC,OAFA9I,EAAIJ,IAAMA,EAEHI,IANf,kCAyBuBsL,GACfnH,EAAamH,EAAQ5B,GACrB,IAAI7K,EAAMY,KAAyB6L,EAAO1L,KAC1C,OAAOqN,EAAQ1G,OAAO1H,KA5B9B,+BAmCoBuR,GACZ,IACI,IAAMtK,EAASrG,MAAsC,IACjDkF,EAAO9D,EAAkBuP,EAAK3Q,KAAwBA,MACtD6F,EAAOrF,EACXR,KAAsBqG,EAAQnB,EAAMW,GACpC,IAAIc,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWyH,GAErB,OAAO4G,EAAQ1G,OAAOH,GAX1B,QAaI3G,KAAqC,SAjDjD,KAgFayM,GAAb,WAuBI,aAAc,oBACV,IAAIrN,EAAMY,OACV,OAAOyM,EAAO3F,OAAO1H,GAzB7B,iEAUQ,IAAMe,EAAM2H,KAAK3H,IAGjB,OAFA2H,KAAK3H,IAAM,EAEJA,IAbf,6BAiBQ,IAAMA,EAAM2H,KAAKkB,qBACjBhJ,IAAuBG,MAlB/B,8BAEkBA,GACV,IAAMI,EAAM0H,OAAOmB,OAAOqD,EAAOpD,WAGjC,OAFA9I,EAAIJ,IAAMA,EAEHI,MANf,2CAiCQ,OADUP,KAAgB8H,KAAK3H,OAChB,IAjCvB,0BAwCQ6J,GACA,IACI,IAAM3D,EAASrG,MAAsC,IACrDA,KAAgBqG,EAAQyB,KAAK3H,IAAK6J,GAClC,IAAIrD,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWyH,GAErB,OAAOyG,GAAMvG,OAAOH,GATxB,QAWI3G,KAAqC,OApDjD,0BA2DQ+L,GACA,IACI,IAAM1F,EAASrG,MAAsC,IACrD0E,EAAaqH,EAAMsB,IACnBrN,KAAgBqG,EAAQyB,KAAK3H,IAAK4L,EAAK5L,KACvC,IAAIwG,EAAK5E,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWwH,GAPzB,QAUI3G,KAAqC,SAtEjD,KAsFasG,GAAb,6GAUQ,IAAMnG,EAAM2H,KAAK3H,IAGjB,OAFA2H,KAAK3H,IAAM,EAEJA,IAbf,6BAiBQ,IAAMA,EAAM2H,KAAKkB,qBACjBhJ,IAA4BG,KAlBpC,2BAoDQ,IAAIf,EAAMY,KAAoB8H,KAAK3H,KACnC,OAAOqM,GAAK1F,OAAO1H,KArD3B,gCA4DQ,IACI,IAAMiH,EAASrG,MAAsC,IACrDA,KAAyBqG,EAAQyB,KAAK3H,KACtC,IAAIwG,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GACpCc,EAAKpF,IAAkBsE,EAAS,EAAI,GACpCuE,EAAK7I,IAAkBsE,EAAS,EAAI,GACpCnB,EAAOyB,EACPd,EAAOe,EACX,GAAIgE,EAEA,MADA1F,EAAO,EAAGW,EAAO,EACX1G,EAAWgI,GAErB,OAAOjH,EAAmBgF,EAAMW,GAbpC,QAeI7F,KAAqC,IACrCA,KAAqBkF,EAAMW,MA5EvC,oCAqFQ,IACI,IAAMQ,EAASrG,MAAsC,IACrDA,KAA6BqG,EAAQyB,KAAK3H,KAC1C,IAAIwG,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWyH,GAErB,OAAOzH,EAAWwH,GATtB,QAWI3G,KAAqC,OAhGjD,+BA+HQ,IAAIZ,EAAMY,KAAwB8H,KAAK3H,KACvC,OAAO0O,GAAO/H,OAAO1H,KAhI7B,oCAuIQ,IAAIA,EAAMY,KAA6B8H,KAAK3H,KAC5C,OAAO2L,GAAWhF,OAAO1H,KAxIjC,0CA+IQ,IAAIA,EAAMY,KAAmC8H,KAAK3H,KAClD,OAAOuN,GAAkB5G,OAAO1H,KAhJxC,gCAuJQ,IAAIA,EAAMY,KAAyB8H,KAAK3H,KACxC,OAAOqG,GAAUM,OAAO1H,KAxJhC,8CA+JQ,IACI,IAAMiH,EAASrG,MAAsC,IACrDA,KAAuCqG,EAAQyB,KAAK3H,KACpD,IAAIwG,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GACpCc,EAAKpF,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWgI,GAErB,IAAI+B,EAAKrE,EAAoB8B,EAAIC,GAAIjF,QAErC,OADA3B,KAAqB2G,EAAS,EAALC,GAClBsC,EAZX,QAcIlJ,KAAqC,QA7KjD,8BAEkBG,GACV,IAAMI,EAAM0H,OAAOmB,OAAO9C,EAAY+C,WAGtC,OAFA9I,EAAIJ,IAAMA,EAEHI,IANf,uCA2B4B6P,EAAaQ,GACjC,IACI,IAAMvK,EAASrG,MAAsC,IACrD0E,EAAa0L,EAAaD,IAC1B,IAAIjL,EAAOkL,EAAYjQ,IACvBiQ,EAAYjQ,IAAM,EAClB,IAAIqF,EAAOhB,EAAwBoM,EAAQ5Q,MACvC0H,EAAOlH,EACXR,KAAkCqG,EAAQnB,EAAMM,EAAMkC,GACtD,IAAIf,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWyH,GAErB,OAAON,EAAYQ,OAAOH,GAd9B,QAgBI3G,KAAqC,OA5CjD,gCAyGqB2J,GACb,IACI,IAAMtD,EAASrG,MAAsC,IACjDkF,EAAO9D,EAAkBuI,EAAM3J,KAAwBA,MACvD6F,EAAOrF,EACXR,KAA2BqG,EAAQnB,EAAMW,GACzC,IAAIc,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWyH,GAErB,OAAON,EAAYQ,OAAOH,GAX9B,QAaI3G,KAAqC,OAvHjD,wCAqL6BkH,GACrB,IACI,IAAMb,EAASrG,MAAsC,IACjDkF,EAAOJ,EAAkBoC,EAAMlH,MAC/B6F,EAAOrF,EACXR,KAAmCqG,EAAQnB,EAAMW,GACjD,IAAIc,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWyH,GAErB,OAAON,EAAYQ,OAAOH,GAX9B,QAaI3G,KAAqC,SAnMjD,KA0Ma6G,GAAb,6GAUQ,IAAM1G,EAAM2H,KAAK3H,IAGjB,OAFA2H,KAAK3H,IAAM,EAEJA,IAbf,6BAiBQ,IAAMA,EAAM2H,KAAKkB,qBACjBhJ,KAAoCG,KAlB5C,0CAiCwB6J,EAAO6G,GACvBnM,EAAamM,EAAWtC,IACxBvO,KAA6C8H,KAAK3H,IAAK6J,EAAO6G,EAAU1Q,OAnChF,0CA0CwB6J,GAChB,IAAI5K,EAAMY,KAA6C8H,KAAK3H,IAAK6J,GACjE,OAAOuE,GAASzH,OAAO1H,KA5C/B,gCAmDQ,IACI,IAAMiH,EAASrG,MAAsC,IACrDA,KAAiCqG,EAAQyB,KAAK3H,KAC9C,IAAIwG,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWyH,GAErB,OAAOzH,EAAWwH,GATtB,QAWI3G,KAAqC,QA9DjD,8BAEkBG,GACV,IAAMI,EAAM0H,OAAOmB,OAAOvC,EAAoBwC,WAG9C,OAFA9I,EAAIJ,IAAMA,EAEHI,IANf,8BAyBQ,IAAInB,EAAMY,OACV,OAAO6G,EAAoBC,OAAO1H,KA1B1C,gCAsEqBuK,GACb,IACI,IAAMtD,EAASrG,MAAsC,IACjDkF,EAAO9D,EAAkBuI,EAAM3J,KAAwBA,MACvD6F,EAAOrF,EACXR,KAAmCqG,EAAQnB,EAAMW,GACjD,IAAIc,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWyH,GAErB,OAAOC,EAAoBC,OAAOH,GAXtC,QAaI3G,KAAqC,SApFjD,KA2Fa8Q,GAAb,6GAUQ,IAAM3Q,EAAM2H,KAAK3H,IAGjB,OAFA2H,KAAK3H,IAAM,EAEJA,IAbf,6BAiBQ,IAAMA,EAAM2H,KAAKkB,qBACjBhJ,KAA0BG,KAlBlC,sCA0DoB4Q,GACZrM,EAAaqM,EAAajF,IAC1B9L,KAA+B8H,KAAK3H,IAAK4Q,EAAY5Q,OA5D7D,4CAmE0B0L,EAAQmF,GAC1BtM,EAAamH,EAAQ5B,GACrBvF,EAAasM,EAAmB3F,IAChCrL,KAAqC8H,KAAK3H,IAAK0L,EAAO1L,IAAK6Q,EAAkB7Q,OAtErF,8BA6EQ,IACI,IAAMkG,EAASrG,MAAsC,IACrDA,KAAqBqG,EAAQyB,KAAK3H,KAClC,IAAIwG,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWyH,GAErB,OAAOuJ,GAAoBrJ,OAAOH,GATtC,QAWI3G,KAAqC,OAxFjD,sCAgGQ,IAAIZ,EAAMY,KAA6B8H,KAAK3H,KAC5C,OAAOgK,EAAarD,OAAO1H,KAjGnC,oCAwGQ,IAAIA,EAAMY,KAA2B8H,KAAK3H,KAC1C,OAAO2L,GAAWhF,OAAO1H,KAzGjC,0CAgHQ,IAAIA,EAAMY,KAAiC8H,KAAK3H,KAChD,OAAOuN,GAAkB5G,OAAO1H,KAjHxC,uCAyHQ,OADUY,KAA8B8H,KAAK3H,OAC9B,IAzHvB,mCAgIQ,IAAIf,EAAMY,KAA0B8H,KAAK3H,KACzC,OAAOoK,GAASzD,OAAO1H,KAjI/B,uCAwIQ,IAAIA,EAAMY,KAA8B8H,KAAK3H,KAC7C,OAAOsH,EAAQX,OAAO1H,KAzI9B,yCAgJQ,IAAIA,EAAMY,KAAgC8H,KAAK3H,KAC/C,OAAOoK,GAASzD,OAAO1H,MAjJ/B,8BAEkBe,GACV,IAAMI,EAAM0H,OAAOmB,OAAO0H,EAAUzH,WAGpC,OAFA9I,EAAIJ,IAAMA,EAEHI,IANf,yCAyBQ,IAAInB,EAAMY,OACV,OAAOuK,GAASzD,OAAO1H,KA1B/B,0BA6Ce6R,EAAeC,EAAmBC,EAAgBtE,EAAYuE,EAAgBC,GACrF3M,EAAauM,EAAe9G,GAC5BzF,EAAawM,EAAmBxD,IAChChJ,EAAamI,EAAYtC,IACzB7F,EAAa0M,EAAgB3J,GAC7B/C,EAAa2M,EAAkB9G,IAC/B,IAAInL,EAAMY,KAAmBiR,EAAc9Q,IAAK+Q,EAAkB/Q,IAAKgR,EAAgBtE,EAAW1M,IAAKiR,EAAejR,IAAKkR,EAAiBlR,KAC5I,OAAO2Q,EAAUhK,OAAO1H,OApDhC,KAuJaoN,GAAb,6GAUQ,IAAMrM,EAAM2H,KAAK3H,IAGjB,OAFA2H,KAAK3H,IAAM,EAEJA,IAbf,6BAiBQ,IAAMA,EAAM2H,KAAKkB,qBACjBhJ,KAAqBG,KAlB7B,+BAiCQ,IACI,IAAMkG,EAASrG,MAAsC,IACrDA,KAAiBqG,EAAQyB,KAAK3H,KAC9B,IAAIwG,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GACxC,OAAOnG,EAAmByG,EAAIC,GALlC,QAOI5G,KAAqC,IACrCA,KAAqB2G,EAAIC,OAzCrC,8BAEkBzG,GACV,IAAMI,EAAM0H,OAAOmB,OAAOoD,EAAKnD,WAG/B,OAFA9I,EAAIJ,IAAMA,EAEHI,IANf,6BAyBQ,IAAInB,EAAMY,OACV,OAAOwM,EAAK1F,OAAO1H,KA1B3B,+BAiDoBoK,GACZ,IACI,IAAMnD,EAASrG,MAAsC,IACjDkF,EAAO9D,EAAkBoI,EAAGxJ,KAAwBA,MACpD6F,EAAOrF,EACXR,KAAmBqG,EAAQnB,EAAMW,GACjC,IAAIc,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWyH,GAErB,OAAO4F,EAAK1F,OAAOH,GAXvB,QAaI3G,KAAqC,SA/DjD,KAsEasR,GAAb,WAyBI,WAAYzF,EAAQ0F,GAAK,oBACrB7M,EAAamH,EAAQ5B,GACrBvF,EAAa6M,EAAKlG,IAClB,IAAIjM,EAAMY,KAAuB6L,EAAO1L,IAAKoR,EAAIpR,KACjD,OAAOmR,EAAcxK,OAAO1H,GA7BpC,iEAUQ,IAAMe,EAAM2H,KAAK3H,IAGjB,OAFA2H,KAAK3H,IAAM,EAEJA,IAbf,6BAiBQ,IAAMA,EAAM2H,KAAKkB,qBACjBhJ,KAA8BG,MAlBtC,8BAEkBA,GACV,IAAMI,EAAM0H,OAAOmB,OAAOkI,EAAcjI,WAGxC,OAFA9I,EAAIJ,IAAMA,EAEHI,MANf,8CA+CQ,IAAInB,EAAMY,KAA0B8H,KAAK3H,KACzC,OAAO8J,EAAMnD,OAAO1H,KAhD5B,kCAuDQ,IAAIA,EAAMY,KAA6B8H,KAAK3H,KAC5C,OAAOkL,GAAiBvE,OAAO1H,MAxDvC,mCAqCuByM,GACfnH,EAAamH,EAAQ5B,GACrB,IAAI7K,EAAMY,KAA+B6L,EAAO1L,KAChD,OAAOmR,EAAcxK,OAAO1H,OAxCpC,KA8DaoS,GAAb,WAuBI,aAAc,oBACV,IAAIpS,EAAMY,OACV,OAAOwR,EAAe1K,OAAO1H,GAzBrC,iEAUQ,IAAMe,EAAM2H,KAAK3H,IAGjB,OAFA2H,KAAK3H,IAAM,EAEJA,IAbf,6BAiBQ,IAAMA,EAAM2H,KAAKkB,qBACjBhJ,KAA+BG,MAlBvC,8BAEkBA,GACV,IAAMI,EAAM0H,OAAOmB,OAAOoI,EAAenI,WAGzC,OAFA9I,EAAIJ,IAAMA,EAEHI,MANf,2CAiCQ,OADUP,KAAwB8H,KAAK3H,OACxB,IAjCvB,0BAwCQ6J,GACA,IAAI5K,EAAMY,KAAwB8H,KAAK3H,IAAK6J,GAC5C,OAAOsH,GAAcxK,OAAO1H,KA1CpC,0BAgDQwE,GACAc,EAAad,EAAG0N,IAChBtR,KAAwB8H,KAAK3H,IAAKyD,EAAEzD,SAlD5C,KAwDagQ,GAAb,WA0BI,WAAYK,EAAQO,EAAaG,GAAmB,oBAChD,IACI,IAAM7K,EAASrG,MAAsC,IACrD0E,EAAa8L,EAAQgB,IACrB9M,EAAaqM,EAAajF,IAC1BpH,EAAawM,EAAmBxD,IAChC1N,KAA6BqG,EAAQmK,EAAOrQ,IAAK4Q,EAAY5Q,IAAK+Q,EAAkB/Q,KACpF,IAAIwG,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWyH,GAErB,OAAOuJ,EAAoBrJ,OAAOH,GAZtC,QAcI3G,KAAqC,KAzCjD,iEAUQ,IAAMG,EAAM2H,KAAK3H,IAGjB,OAFA2H,KAAK3H,IAAM,EAEJA,IAbf,6BAiBQ,IAAMA,EAAM2H,KAAKkB,qBACjBhJ,KAAoCG,MAlB5C,8BAEkBA,GACV,IAAMI,EAAM0H,OAAOmB,OAAO+G,EAAoB9G,WAG9C,OAFA9I,EAAIJ,IAAMA,EAEHI,MANf,4DAoD2BkR,EAAUF,GAC7B,IACI,IAAMpR,EAAM2H,KAAKkB,qBACX3C,EAASrG,MAAsC,IACrD0E,EAAa+M,EAAUxH,GACvBvF,EAAa6M,EAAKlG,IAClBrL,KAAgDqG,EAAQlG,EAAKsR,EAAStR,IAAKoR,EAAIpR,KAC/E,IAAIwG,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWyH,GAErB,OAAOuJ,EAAoBrJ,OAAOH,GAZtC,QAcI3G,KAAqC,OAnEjD,2BA2EQ,IAAIZ,EAAMY,KAA4B8H,KAAK3H,KAC3C,OAAOqM,GAAK1F,OAAO1H,KA5E3B,+BAmFQ,IAAIA,EAAMY,KAAgC8H,KAAK3H,KAC/C,OAAOqR,GAAe1K,OAAO1H,KApFrC,oCA2FQ,IAAIA,EAAMY,KAAqC8H,KAAK3H,KACpD,OAAO2L,GAAWhF,OAAO1H,KA5FjC,0CAmGQ,IAAIA,EAAMY,KAA2C8H,KAAK3H,KAC1D,OAAOuN,GAAkB5G,OAAO1H,KApGxC,gCA2GQ,IACI,IAAMiH,EAASrG,MAAsC,IACrDA,KAAiCqG,EAAQyB,KAAK3H,KAC9C,IAAIwG,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GACpCc,EAAKpF,IAAkBsE,EAAS,EAAI,GACpCuE,EAAK7I,IAAkBsE,EAAS,EAAI,GACpCnB,EAAOyB,EACPd,EAAOe,EACX,GAAIgE,EAEA,MADA1F,EAAO,EAAGW,EAAO,EACX1G,EAAWgI,GAErB,OAAOjH,EAAmBgF,EAAMW,GAbpC,QAeI7F,KAAqC,IACrCA,KAAqBkF,EAAMW,MA3HvC,oCAoIQ,IACI,IAAMQ,EAASrG,MAAsC,IACrDA,KAAqCqG,EAAQyB,KAAK3H,KAClD,IAAIwG,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWyH,GAErB,OAAOzH,EAAWwH,GATtB,QAWI3G,KAAqC,OA/IjD,2CA8KQ,IACI,IAAMqG,EAASrG,MAAsC,IACrDA,KAA4CqG,EAAQyB,KAAK3H,KACzD,IAAIwG,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GACpC6C,EAAKnC,EAAyBJ,EAAIC,GAAIjF,QAE1C,OADA3B,KAAqB2G,EAAS,EAALC,GAClBsC,EAPX,QASIlJ,KAAqC,QAvLjD,iCAwJqB2J,GACb,IACI,IAAMtD,EAASrG,MAAsC,IACjDkF,EAAO9D,EAAkBuI,EAAM3J,KAAwBA,MACvD6F,EAAOrF,EACXR,KAAmCqG,EAAQnB,EAAMW,GACjD,IAAIc,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWyH,GAErB,OAAOuJ,EAAoBrJ,OAAOH,GAXtC,QAaI3G,KAAqC,SAtKjD,KA8La0R,GAAb,6GAUQ,IAAMvR,EAAM2H,KAAK3H,IAGjB,OAFA2H,KAAK3H,IAAM,EAEJA,IAbf,6BAiBQ,IAAMA,EAAM2H,KAAKkB,qBACjBhJ,KAAuBG,KAlB/B,iCAiDewR,GACPjN,EAAaiN,EAAQtB,IACrBrQ,KAAuB8H,KAAK3H,IAAKwR,EAAOxR,OAnDhD,uCAgEqByR,EAAgBC,EAAI5L,EAAgBC,GACjD,IACI,IAAMG,EAASrG,MAAsC,IACrD0E,EAAakN,EAAgBrL,IAC7B7B,EAAamN,EAAI1B,IACjBzL,EAAauB,EAAgBO,IAC7B9B,EAAawB,EAAYM,IACzBxG,KAA6BqG,EAAQyB,KAAK3H,IAAKyR,EAAezR,IAAK0R,EAAG1R,IAAK8F,EAAe9F,IAAK+F,EAAW/F,KAC1G,IAAIwG,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWyH,GAErB,OAAON,GAAYQ,OAAOH,GAb9B,QAeI3G,KAAqC,OAhFjD,6CAgG2B4R,EAAgBC,EAAI5L,EAAgBC,EAAY4L,GACnE,IACI,IAAMzL,EAASrG,MAAsC,IACrD0E,EAAakN,EAAgBrL,IAC7B7B,EAAamN,EAAI1B,IACjBzL,EAAauB,EAAgBO,IAC7B9B,EAAawB,EAAYM,IACzB9B,EAAaoN,EAAUjL,IACvB7G,KAAmCqG,EAAQyB,KAAK3H,IAAKyR,EAAezR,IAAK0R,EAAG1R,IAAK8F,EAAe9F,IAAK+F,EAAW/F,IAAK2R,EAAS3R,KAC9H,IAAIwG,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWyH,GAErB,OAAON,GAAYQ,OAAOH,GAd9B,QAgBI3G,KAAqC,OAjHjD,+CA2H6B+R,GACrB,IACI,IAAM1L,EAASrG,MAAsC,IACrD0E,EAAaqN,EAAY7B,IACzBlQ,KAAqCqG,EAAQyB,KAAK3H,IAAK4R,EAAW5R,KAClE,IAAIwG,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWyH,GAErB,OAAON,GAAYQ,OAAOH,GAV9B,QAYI3G,KAAqC,OAxIjD,qDAoJmC+R,EAAYD,GACvC,IACI,IAAMzL,EAASrG,MAAsC,IACrD0E,EAAaqN,EAAY7B,IACzBxL,EAAaoN,EAAUjL,IACvB7G,KAA2CqG,EAAQyB,KAAK3H,IAAK4R,EAAW5R,IAAK2R,EAAS3R,KACtF,IAAIwG,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWyH,GAErB,OAAON,GAAYQ,OAAOH,GAX9B,QAaI3G,KAAqC,OAlKjD,2CA6KyB4R,EAAgBC,EAAI5L,EAAgBC,GACrD,IACI,IAAMG,EAASrG,MAAsC,IACrD0E,EAAakN,EAAgBrL,IAC7B7B,EAAamN,EAAI1B,IACjBzL,EAAauB,EAAgBO,IAC7B9B,EAAawB,EAAYM,IACzBxG,KAAiCqG,EAAQyB,KAAK3H,IAAKyR,EAAezR,IAAK0R,EAAG1R,IAAK8F,EAAe9F,IAAK+F,EAAW/F,KAC9G,IAAIwG,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWyH,GAErB,OAAOC,GAAoBC,OAAOH,GAbtC,QAeI3G,KAAqC,OA7LjD,mEAqMiD+R,GACzC,IACI,IAAM1L,EAASrG,MAAsC,IACrD0E,EAAaqN,EAAY7B,IACzBlQ,KAAyDqG,EAAQyB,KAAK3H,IAAK4R,EAAW5R,KACtF,IAAIwG,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWyH,GAErB,OAAOC,GAAoBC,OAAOH,GAVtC,QAYI3G,KAAqC,OAlNjD,8CA2N4BuH,EAASrE,GAC7B,IACI,IAAMmD,EAASrG,MAAsC,IACrD0E,EAAa6C,EAASE,GACtB,IAAIvC,EAAOJ,EAAkB5B,EAASlD,MAClC6F,EAAOrF,EACXR,KAAoCqG,EAAQyB,KAAK3H,IAAKoH,EAAQpH,IAAK+E,EAAMW,GACzE,IAAIc,EAAK5E,IAAkBsE,EAAS,EAAI,GACpCO,EAAK7E,IAAkBsE,EAAS,EAAI,GAExC,GADStE,IAAkBsE,EAAS,EAAI,GAEpC,MAAMlH,EAAWyH,GAErB,OAAOzH,EAAWwH,GAZtB,QAcI3G,KAAqC,QA1OjD,8BAEkBG,GACV,IAAMI,EAAM0H,OAAOmB,OAAOsI,EAAOrI,WAGjC,OAFA9I,EAAIJ,IAAMA,EAEHI,IANf,oCA2ByB+O,EAAiBC,GAClC,IAAIrK,EAAO9D,EAAkBkO,EAAiBtP,KAAwBA,MAClE6F,EAAOrF,EACPgF,EAAOpE,EAAkBmO,EAAevP,KAAwBA,MAChE0H,EAAOlH,EACPpB,EAAMY,KAA0BkF,EAAMW,EAAML,EAAMkC,GACtD,OAAe,IAARtI,OAAYP,EAAY6S,EAAO5K,OAAO1H,KAjCrD,mCAwCwBuS,GAChBjN,EAAaiN,EAAQrB,IACrB,IAAIlR,EAAMY,KAAyB2R,EAAOxR,KAC1C,OAAOuR,EAAO5K,OAAO1H,OA3C7B,KA+OO,SAAS4S,GAA2B3O,GACvClE,EAAWkE,GAGR,SAAS4O,GAAsB5O,EAAMC,GAExC,OAAOhD,EADGJ,EAAmBmD,EAAMC,IAIhC,SAAS4O,GAAmB7O,GAE/B,OAAO/C,EADGwP,GAAShJ,OAAOzD,IAIvB,SAAS8O,GAAuB9O,GAEnC,OAAO/C,EADGqP,GAAa7I,OAAOzD,IAI3B,SAAS+O,GAAqB/O,GAEjC,MADsC,kBAArBvE,EAAUuE,GAIxB,SAASgP,GAAsBhP,EAAMC,GACxC,IAAM/C,EAAMzB,EAAUwE,GAClBlE,EAAsB,kBAATmB,EAAoBA,OAAM1B,EACvCqG,EAAOtD,EAAWxC,GAAO,EAAIgC,EAAkBhC,EAAKY,KAAwBA,MAC5E6F,EAAOrF,EACXuB,IAAkBsB,EAAO,EAAI,GAAKwC,EAClC9D,IAAkBsB,EAAO,EAAI,GAAK6B,EAG/B,SAASoN,GAA4BjP,GAExC,OAAO/C,EADGxB,EAAUuE,IAIjB,SAASkP,GAAsBlP,EAAMC,GAExC,OAAOhD,EADGwC,KAAK0P,MAAMtS,EAAmBmD,EAAMC,KAI3C,SAASmP,GAA0BpP,EAAMC,GAC5C,IAAM/C,EAAMzB,EAAUwE,GAElB4B,EAAO9D,EADD0B,KAAKC,eAAkBlE,IAAR0B,EAAoB,KAAOA,GAClBP,KAAwBA,MACtD6F,EAAOrF,EACXuB,IAAkBsB,EAAO,EAAI,GAAKwC,EAClC9D,IAAkBsB,EAAO,EAAI,GAAK6B,EAG/B,SAASwN,GAAqBrP,EAAMC,GAEvC,OAAOhD,EADG,IAAI2C,MAAM/C,EAAmBmD,EAAMC,KAI1C,SAASqP,GAAsBtP,GAElC,OAAO/C,EADG+C,GAIP,SAASuP,GAA6BvP,GAEzC,OAAO/C,EADGuS,MAAM/T,EAAUuE,KAIvB,SAASyP,GAAmBzP,GAC/B,IAAM9C,EAAMpB,EAAWkE,GAAMY,SAC7B,GAAiB,GAAb1D,EAAIsD,MAEJ,OADAtD,EAAIoD,EAAI,GACD,EAGX,OADU,EAIP,SAASoP,GAAyC1P,GAErD,OADUvE,EAAUuE,aAAiB2P,OAIlC,SAASC,GAAmC5P,GAC/C,IAAIjE,EAAMN,EAAUuE,GAAM6P,YAC1B,OAAOtR,EAAWxC,GAAO,EAAIkB,EAAclB,GAGxC,SAAS+T,KAAsC,OAAOvL,GAAY,SAAUvE,EAAMC,EAAMc,GAE3F,OADUtF,EAAUuE,GAAM+P,WAAWtU,EAAUwE,GAAOc,KAEvDiP,WAEI,SAASC,GAA6BjQ,EAAMC,GAE/C,OAAOhD,EADGxB,EAAUuE,GAAMwP,MAAM/T,EAAUwE,KAIvC,SAASiQ,KAA+B,OAAO3L,GAAY,WAE9D,OAAOtH,EADG,IAAIkT,WAEfH,WAEI,SAASI,KAAkC,OAAO7L,GAAY,SAAUvE,EAAMC,EAAMc,EAAMsP,EAAMC,GACnG7U,EAAUuE,GAAMuQ,OAAO1T,EAAmBoD,EAAMc,GAAOlE,EAAmBwT,EAAMC,MACjFN,WAEI,SAASQ,GAA8BxQ,GAE1C,OAAO/C,EADGxB,EAAUuE,GAAMyQ,QAIvB,SAASC,KAA+B,OAAOnM,GAAY,WAE9D,OAAOtH,EADG,IAAI0T,mBAEfX,WAEI,SAASY,GAA6B5Q,GACzCvE,EAAUuE,GAAM6Q,QAGb,SAASC,GAA2C9Q,GAEvD,OADUvE,EAAUuE,aAAiB+Q,SAIlC,SAASC,GAA2BhR,EAAMC,GAC7C,IACI4B,EAAO9D,EADDtC,EAAUwE,GAAMgR,IACQtU,KAAwBA,MACtD6F,EAAOrF,EACXuB,IAAkBsB,EAAO,EAAI,GAAKwC,EAClC9D,IAAkBsB,EAAO,EAAI,GAAK6B,EAG/B,SAASqP,GAA8BlR,GAE1C,OADUvE,EAAUuE,GAAMmR,OAIvB,SAASC,GAA+BpR,GAE3C,OAAO/C,EADGxB,EAAUuE,GAAMwK,SAIvB,SAAS6G,KAAuC,OAAO9M,GAAY,SAAUvE,GAEhF,OAAO/C,EADGxB,EAAUuE,GAAMsR,iBAE3BtB,WAEI,SAASuB,KAA+B,OAAOhN,GAAY,SAAUvE,EAAMC,GAE9E,OAAOhD,EADG,IAAIuU,IAAI3U,EAAmBmD,EAAMC,OAE5C+P,WAEI,SAASyB,KAA6C,OAAOlN,GAAY,SAAUvE,EAAMC,EAAMc,GAElG,OAAO9D,EADG,IAAIyU,QAAQ7U,EAAmBmD,EAAMC,GAAOxE,EAAUsF,OAEjEiP,WAEI,SAAS2B,GAA2B3R,GAEvC,OADUvE,EAAUuE,GAAM4R,MAIvB,SAASC,GAA+B7R,GAE3C,OAAO/C,EADGxB,EAAUuE,GAAM8R,SAIvB,SAASC,GAAqB/R,GACjC,IAAMnB,EAAMpD,EAAUuE,GAEtB,MAD0B,kBAATnB,GAA6B,OAARA,EAInC,SAASmT,GAAgChS,GAE5C,OAAO/C,EADGxB,EAAUuE,GAAMiS,UAIvB,SAASC,GAA4BlS,GAExC,OAAO/C,EADGxB,EAAUuE,GAAM2B,MAIvB,SAASwQ,KAAyC,OAAO5N,GAAY,SAAUvE,EAAMC,GAExF,OAAOhD,EADGd,OAAeU,EAAmBmD,EAAMC,OAEnD+P,WAEI,SAASoC,GAA8BpS,GAE1C,OAAO/C,EADGxB,EAAUuE,GAAMqS,QAIvB,SAASC,GAAgCtS,GAE5C,OAAO/C,EADGxB,EAAUuE,GAAMuS,UAIvB,SAASC,KAA2C,OAAOjO,GAAY,SAAUvE,EAAMC,GAC1FxE,EAAUuE,GAAMyS,gBAAgBhX,EAAUwE,MAC3C+P,WAEI,SAAS0C,KAA0C,OAAOnO,GAAY,SAAUvE,EAAMC,EAAMc,GAC/FtF,EAAUuE,GAAM2S,eAAenR,EAAoBvB,EAAMc,MAC1DiP,WAEI,SAAS4C,GAAuB5S,GAEnC,MADsC,oBAArBvE,EAAUuE,GAIxB,SAAS6S,GAAiC7S,EAAMC,GAEnD,OAAOhD,EADG,IAAI6V,SAASjW,EAAmBmD,EAAMC,KAI7C,SAAS8S,GAA4B/S,GAExC,OAAO/C,EADGxB,EAAUuE,GAAMgT,MAIvB,SAASC,KAAgC,OAAO1O,GAAY,SAAUvE,GAEzE,OAAO/C,EADGxB,EAAUuE,GAAMgT,UAE3BhD,WAEI,SAASkD,GAA4BlT,GAExC,OADUvE,EAAUuE,GAAMmT,KAIvB,SAASC,GAA6BpT,GAEzC,OAAO/C,EADGxB,EAAUuE,GAAMkI,OAIvB,SAASmL,KAEZ,OAAOpW,EADGqW,OAAOC,UAId,SAASC,KAA+B,OAAOjP,GAAY,SAAUvE,EAAMC,GAE9E,OAAOhD,EADGwW,QAAQ9S,IAAIlF,EAAUuE,GAAOvE,EAAUwE,OAElD+P,WAEI,SAAS0D,KAAgC,OAAOnP,GAAY,SAAUvE,EAAMC,GAE/E,OAAOhD,EADGxB,EAAUuE,GAAMR,KAAK/D,EAAUwE,OAE1C+P,WAEI,SAAS2D,KAEZ,OAAO1W,EADG,IAAI2H,QAIX,SAASgP,KAAgC,OAAOrP,GAAY,WAE/D,OAAOtH,EADG4W,KAAKA,QAEhB7D,WAEI,SAAS8D,KAAkC,OAAOvP,GAAY,WAEjE,OAAOtH,EADG8W,OAAOA,UAElB/D,WAEI,SAASgE,KAAsC,OAAOzP,GAAY,WAErE,OAAOtH,EADGgX,WAAWA,cAEtBjE,WAEI,SAASkE,KAAkC,OAAO3P,GAAY,WAEjE,OAAOtH,EADGkX,EAAOA,UAElBnE,WAEI,SAASoE,GAAwBpU,GAEpC,YAD8BxE,IAApBC,EAAUuE,GAIjB,SAASqU,GAA2BrU,EAAMC,GAE7C,OAAOhD,EADG,IAAI2C,MAAM/C,EAAmBmD,EAAMC,KAI1C,SAASqU,KAAgC,OAAO/P,GAAY,SAAUvE,EAAMC,EAAMc,GAErF,OAAO9D,EADGxB,EAAUuE,GAAMR,KAAK/D,EAAUwE,GAAOxE,EAAUsF,OAE3DiP,WAEI,SAASuE,GAAgCvU,GAE5C,OAAO/C,EADGxB,EAAUuE,GAAMT,YAIvB,SAASiV,GAA2BxU,EAAMC,GAC7C,IACI,IAAIwU,EAAS,CAACnU,EAAGN,EAAMO,EAAGN,GAUtBlE,EAAM,IAAI2Y,SATJ,SAAC1U,EAAMC,GACb,IAAMK,EAAImU,EAAOnU,EACjBmU,EAAOnU,EAAI,EACX,IACI,OAx+LhB,SAA2BN,EAAMC,EAAMc,EAAMsP,GACzC1T,KAAqEqD,EAAMC,EAAMhD,EAAc8D,GAAO9D,EAAcoT,IAu+LjGsE,CAAkBrU,EAAGmU,EAAOlU,EAAGP,EAAMC,GADhD,QAGIwU,EAAOnU,EAAIA,MAInB,OAAOrD,EAAclB,GAZzB,QAcI0Y,EAAOnU,EAAImU,EAAOlU,EAAI,GAIvB,SAASqU,GAA+B5U,GAE3C,OAAO/C,EADGyX,QAAQG,QAAQpZ,EAAUuE,KAIjC,SAAS8U,GAA4B9U,EAAMC,GAE9C,OAAOhD,EADGxB,EAAUuE,GAAM+U,KAAKtZ,EAAUwE,KAItC,SAAS+U,GAA4BhV,EAAMC,EAAMc,GAEpD,OAAO9D,EADGxB,EAAUuE,GAAM+U,KAAKtZ,EAAUwE,GAAOxE,EAAUsF,KAIvD,SAASkU,GAA8BjV,GAE1C,OAAO/C,EADGxB,EAAUuE,GAAMtD,QAIvB,SAASwY,GAAkDlV,EAAMC,EAAMc,GAE1E,OAAO9D,EADG,IAAIL,WAAWnB,EAAUuE,GAAOC,IAAS,EAAGc,IAAS,IAI5D,SAASoU,GAA2BnV,GAEvC,OAAO/C,EADG,IAAIL,WAAWnB,EAAUuE,KAIhC,SAASoV,GAA2BpV,EAAMC,EAAMc,GACnDtF,EAAUuE,GAAMpC,IAAInC,EAAUwE,GAAOc,IAAS,GAG3C,SAASsU,GAA8BrV,GAE1C,OADUvE,EAAUuE,GAAMnE,OAIvB,SAASyZ,GAAqCtV,GAEjD,OAAO/C,EADG,IAAIL,WAAWoD,IAAS,IAI/B,SAASuV,GAAgCvV,EAAMC,EAAMc,GAExD,OAAO9D,EADGxB,EAAUuE,GAAMhD,SAASiD,IAAS,EAAGc,IAAS,IAIrD,SAASyU,KAA+B,OAAOjR,GAAY,SAAUvE,EAAMC,GAE9E,OADUwT,QAAQgC,IAAIha,EAAUuE,GAAOvE,EAAUwE,MAElD+P,WAEI,SAAS0F,KAA+B,OAAOnR,GAAY,SAAUvE,EAAMC,EAAMc,GAEpF,OADU0S,QAAQ7V,IAAInC,EAAUuE,GAAOvE,EAAUwE,GAAOxE,EAAUsF,MAEnEiP,WAEI,SAAS2F,KAAqC,OAAOpR,GAAY,SAAUvE,GAE9E,OAAO/C,EADGwC,KAAKC,UAAUjE,EAAUuE,OAEpCgQ,WAEI,SAAS4F,GAAwB5V,EAAMC,GAC1C,IACI4B,EAAO9D,EADDa,EAAYnD,EAAUwE,IACEtD,KAAwBA,MACtD6F,EAAOrF,EACXuB,IAAkBsB,EAAO,EAAI,GAAKwC,EAClC9D,IAAkBsB,EAAO,EAAI,GAAK6B,EAG/B,SAASgU,GAAiB7V,EAAMC,GACnC,MAAM,IAAIL,MAAM/C,EAAmBmD,EAAMC,IAGtC,SAAS6V,KAEZ,OAAO7Y,EADGN,MAIP,SAASoZ,GAA+B/V,EAAMC,EAAMc,GAEvD,OAAO9D,EAr1MX,SAAqB+C,EAAMC,EAAME,EAAMC,GACnC,IAAMC,EAAQ,CAAEC,EAAGN,EAAMO,EAAGN,EAAMO,IAAK,EAAGL,QACpCM,EAAO,WAITJ,EAAMG,MACN,IAAI,2BALSE,EAKT,yBALSA,EAKT,gBACA,OAAON,EAAC,WAAD,GAAEC,EAAMC,EAAGD,EAAME,GAAjB,OAAuBG,IADlC,QAGwB,MAAdL,EAAMG,MACR7D,KAAyBgE,IAAIN,EAAMF,KAAnCxD,CAAyC0D,EAAMC,EAAGD,EAAME,GACxDF,EAAMC,EAAI,KAOtB,OAFAG,EAAKG,SAAWP,EAETI,EAi0MGuV,CAAYhW,EAAMC,EAAM,IAAKF,IAIpC,SAASkW,GAA+BjW,EAAMC,EAAMc,GAEvD,OAAO9D,EADGiD,EAAeF,EAAMC,EAAM,IAAKY,IAIvC,SAASqV,GAA+BlW,EAAMC,EAAMc,GAEvD,OAAO9D,EADGiD,EAAeF,EAAMC,EAAM,IAAKa,O,uICrhN9C","file":"static/js/0.672215e7.chunk.js","sourcesContent":["import * as wasm from './ergo_lib_wasm_bg.wasm';\n\nconst heap = new Array(32).fill(undefined);\n\nheap.push(undefined, null, true, false);\n\nfunction getObject(idx) { return heap[idx]; }\n\nlet heap_next = heap.length;\n\nfunction dropObject(idx) {\n    if (idx < 36) return;\n    heap[idx] = heap_next;\n    heap_next = idx;\n}\n\nfunction takeObject(idx) {\n    const ret = getObject(idx);\n    dropObject(idx);\n    return ret;\n}\n\nconst lTextDecoder = typeof TextDecoder === 'undefined' ? (0, module.require)('util').TextDecoder : TextDecoder;\n\nlet cachedTextDecoder = new lTextDecoder('utf-8', { ignoreBOM: true, fatal: true });\n\ncachedTextDecoder.decode();\n\nlet cachegetUint8Memory0 = null;\nfunction getUint8Memory0() {\n    if (cachegetUint8Memory0 === null || cachegetUint8Memory0.buffer !== wasm.memory.buffer) {\n        cachegetUint8Memory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachegetUint8Memory0;\n}\n\nfunction getStringFromWasm0(ptr, len) {\n    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));\n}\n\nfunction addHeapObject(obj) {\n    if (heap_next === heap.length) heap.push(heap.length + 1);\n    const idx = heap_next;\n    heap_next = heap[idx];\n\n    heap[idx] = obj;\n    return idx;\n}\n\nlet WASM_VECTOR_LEN = 0;\n\nconst lTextEncoder = typeof TextEncoder === 'undefined' ? (0, module.require)('util').TextEncoder : TextEncoder;\n\nlet cachedTextEncoder = new lTextEncoder('utf-8');\n\nconst encodeString = (typeof cachedTextEncoder.encodeInto === 'function'\n    ? function (arg, view) {\n    return cachedTextEncoder.encodeInto(arg, view);\n}\n    : function (arg, view) {\n    const buf = cachedTextEncoder.encode(arg);\n    view.set(buf);\n    return {\n        read: arg.length,\n        written: buf.length\n    };\n});\n\nfunction passStringToWasm0(arg, malloc, realloc) {\n\n    if (realloc === undefined) {\n        const buf = cachedTextEncoder.encode(arg);\n        const ptr = malloc(buf.length);\n        getUint8Memory0().subarray(ptr, ptr + buf.length).set(buf);\n        WASM_VECTOR_LEN = buf.length;\n        return ptr;\n    }\n\n    let len = arg.length;\n    let ptr = malloc(len);\n\n    const mem = getUint8Memory0();\n\n    let offset = 0;\n\n    for (; offset < len; offset++) {\n        const code = arg.charCodeAt(offset);\n        if (code > 0x7F) break;\n        mem[ptr + offset] = code;\n    }\n\n    if (offset !== len) {\n        if (offset !== 0) {\n            arg = arg.slice(offset);\n        }\n        ptr = realloc(ptr, len, len = offset + arg.length * 3);\n        const view = getUint8Memory0().subarray(ptr + offset, ptr + len);\n        const ret = encodeString(arg, view);\n\n        offset += ret.written;\n    }\n\n    WASM_VECTOR_LEN = offset;\n    return ptr;\n}\n\nfunction isLikeNone(x) {\n    return x === undefined || x === null;\n}\n\nlet cachegetInt32Memory0 = null;\nfunction getInt32Memory0() {\n    if (cachegetInt32Memory0 === null || cachegetInt32Memory0.buffer !== wasm.memory.buffer) {\n        cachegetInt32Memory0 = new Int32Array(wasm.memory.buffer);\n    }\n    return cachegetInt32Memory0;\n}\n\nfunction debugString(val) {\n    // primitive types\n    const type = typeof val;\n    if (type == 'number' || type == 'boolean' || val == null) {\n        return  `${val}`;\n    }\n    if (type == 'string') {\n        return `\"${val}\"`;\n    }\n    if (type == 'symbol') {\n        const description = val.description;\n        if (description == null) {\n            return 'Symbol';\n        } else {\n            return `Symbol(${description})`;\n        }\n    }\n    if (type == 'function') {\n        const name = val.name;\n        if (typeof name == 'string' && name.length > 0) {\n            return `Function(${name})`;\n        } else {\n            return 'Function';\n        }\n    }\n    // objects\n    if (Array.isArray(val)) {\n        const length = val.length;\n        let debug = '[';\n        if (length > 0) {\n            debug += debugString(val[0]);\n        }\n        for(let i = 1; i < length; i++) {\n            debug += ', ' + debugString(val[i]);\n        }\n        debug += ']';\n        return debug;\n    }\n    // Test for built-in\n    const builtInMatches = /\\[object ([^\\]]+)\\]/.exec(toString.call(val));\n    let className;\n    if (builtInMatches.length > 1) {\n        className = builtInMatches[1];\n    } else {\n        // Failed to match the standard '[object ClassName]'\n        return toString.call(val);\n    }\n    if (className == 'Object') {\n        // we're a user defined class or Object\n        // JSON.stringify avoids problems with cycles, and is generally much\n        // easier than looping through ownProperties of `val`.\n        try {\n            return 'Object(' + JSON.stringify(val) + ')';\n        } catch (_) {\n            return 'Object';\n        }\n    }\n    // errors\n    if (val instanceof Error) {\n        return `${val.name}: ${val.message}\\n${val.stack}`;\n    }\n    // TODO we could test for more things here, like `Set`s and `Map`s.\n    return className;\n}\n\nfunction makeClosure(arg0, arg1, dtor, f) {\n    const state = { a: arg0, b: arg1, cnt: 1, dtor };\n    const real = (...args) => {\n        // First up with a closure we increment the internal reference\n        // count. This ensures that the Rust closure environment won't\n        // be deallocated while we're invoking it.\n        state.cnt++;\n        try {\n            return f(state.a, state.b, ...args);\n        } finally {\n            if (--state.cnt === 0) {\n                wasm.__wbindgen_export_2.get(state.dtor)(state.a, state.b);\n                state.a = 0;\n\n            }\n        }\n    };\n    real.original = state;\n\n    return real;\n}\nfunction __wbg_adapter_34(arg0, arg1) {\n    wasm._dyn_core__ops__function__Fn_____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__hf5cd7e853ebfb9c9(arg0, arg1);\n}\n\nfunction makeMutClosure(arg0, arg1, dtor, f) {\n    const state = { a: arg0, b: arg1, cnt: 1, dtor };\n    const real = (...args) => {\n        // First up with a closure we increment the internal reference\n        // count. This ensures that the Rust closure environment won't\n        // be deallocated while we're invoking it.\n        state.cnt++;\n        const a = state.a;\n        state.a = 0;\n        try {\n            return f(a, state.b, ...args);\n        } finally {\n            if (--state.cnt === 0) {\n                wasm.__wbindgen_export_2.get(state.dtor)(a, state.b);\n\n            } else {\n                state.a = a;\n            }\n        }\n    };\n    real.original = state;\n\n    return real;\n}\nfunction __wbg_adapter_37(arg0, arg1) {\n    wasm._dyn_core__ops__function__FnMut_____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__h5bd6d4091c926c5c(arg0, arg1);\n}\n\nfunction __wbg_adapter_40(arg0, arg1, arg2) {\n    wasm._dyn_core__ops__function__FnMut__A____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__h592c0927249c018a(arg0, arg1, addHeapObject(arg2));\n}\n\nlet cachegetUint32Memory0 = null;\nfunction getUint32Memory0() {\n    if (cachegetUint32Memory0 === null || cachegetUint32Memory0.buffer !== wasm.memory.buffer) {\n        cachegetUint32Memory0 = new Uint32Array(wasm.memory.buffer);\n    }\n    return cachegetUint32Memory0;\n}\n\nfunction passArrayJsValueToWasm0(array, malloc) {\n    const ptr = malloc(array.length * 4);\n    const mem = getUint32Memory0();\n    for (let i = 0; i < array.length; i++) {\n        mem[ptr / 4 + i] = addHeapObject(array[i]);\n    }\n    WASM_VECTOR_LEN = array.length;\n    return ptr;\n}\n\nfunction _assertClass(instance, klass) {\n    if (!(instance instanceof klass)) {\n        throw new Error(`expected instance of ${klass.name}`);\n    }\n    return instance.ptr;\n}\n\nfunction getArrayU8FromWasm0(ptr, len) {\n    return getUint8Memory0().subarray(ptr / 1, ptr / 1 + len);\n}\n\nfunction passArray8ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 1);\n    getUint8Memory0().set(arg, ptr / 1);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n/**\n* GET on /info endpoint\n* @param {NodeConf} node\n* @returns {Promise<any>}\n*/\nexport function get_info(node) {\n    _assertClass(node, NodeConf);\n    var ptr0 = node.ptr;\n    node.ptr = 0;\n    var ret = wasm.get_info(ptr0);\n    return takeObject(ret);\n}\n\n/**\n* GET on /nipopow/proof/{minChainLength}/{suffixLength}/{headerId} endpoint\n* @param {NodeConf} node\n* @param {number} min_chain_length\n* @param {number} suffix_len\n* @param {BlockId} header_id\n* @returns {Promise<NipopowProof>}\n*/\nexport function get_nipopow_proof_by_header_id(node, min_chain_length, suffix_len, header_id) {\n    _assertClass(node, NodeConf);\n    var ptr0 = node.ptr;\n    node.ptr = 0;\n    _assertClass(header_id, BlockId);\n    var ptr1 = header_id.ptr;\n    header_id.ptr = 0;\n    var ret = wasm.get_nipopow_proof_by_header_id(ptr0, min_chain_length, suffix_len, ptr1);\n    return takeObject(ret);\n}\n\n/**\n* Given a list of seed nodes, search for peer nodes with an active REST API on port 9053.\n*  - `seeds` represents a list of ergo node URLs from which to start peer discovery.\n*  - `max_parallel_requests` represents the maximum number of HTTP requests that can be made in\n*    parallel\n*  - `timeout` represents the amount of time that is spent search for peers. Once the timeout\n*    value is reached, return with the vec of active peers that have been discovered up to that\n*    point in time.\n* @param {(URL)[]} seeds\n* @param {number} max_parallel_requests\n* @param {number} timeout_sec\n* @returns {Promise<PeerUrls>}\n*/\nexport function peer_discovery(seeds, max_parallel_requests, timeout_sec) {\n    var ptr0 = passArrayJsValueToWasm0(seeds, wasm.__wbindgen_malloc);\n    var len0 = WASM_VECTOR_LEN;\n    var ret = wasm.peer_discovery(ptr0, len0, max_parallel_requests, timeout_sec);\n    return takeObject(ret);\n}\n\n/**\n* Extracting hints form singed(invalid) Transaction\n* @param {Transaction} signed_transaction\n* @param {ErgoStateContext} state_context\n* @param {ErgoBoxes} boxes_to_spend\n* @param {ErgoBoxes} data_boxes\n* @param {Propositions} real_propositions\n* @param {Propositions} simulated_propositions\n* @returns {TransactionHintsBag}\n*/\nexport function extract_hints(signed_transaction, state_context, boxes_to_spend, data_boxes, real_propositions, simulated_propositions) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        _assertClass(signed_transaction, Transaction);\n        var ptr0 = signed_transaction.ptr;\n        signed_transaction.ptr = 0;\n        _assertClass(state_context, ErgoStateContext);\n        _assertClass(boxes_to_spend, ErgoBoxes);\n        _assertClass(data_boxes, ErgoBoxes);\n        _assertClass(real_propositions, Propositions);\n        var ptr1 = real_propositions.ptr;\n        real_propositions.ptr = 0;\n        _assertClass(simulated_propositions, Propositions);\n        var ptr2 = simulated_propositions.ptr;\n        simulated_propositions.ptr = 0;\n        wasm.extract_hints(retptr, ptr0, state_context.ptr, boxes_to_spend.ptr, data_boxes.ptr, ptr1, ptr2);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return TransactionHintsBag.__wrap(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\nfunction getArrayJsValueFromWasm0(ptr, len) {\n    const mem = getUint32Memory0();\n    const slice = mem.subarray(ptr / 4, ptr / 4 + len);\n    const result = [];\n    for (let i = 0; i < slice.length; i++) {\n        result.push(takeObject(slice[i]));\n    }\n    return result;\n}\n/**\n* Decodes a base16 string into an array of bytes\n* @param {string} data\n* @returns {Uint8Array}\n*/\nexport function base16_decode(data) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        var ptr0 = passStringToWasm0(data, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        wasm.base16_decode(retptr, ptr0, len0);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        var r3 = getInt32Memory0()[retptr / 4 + 3];\n        if (r3) {\n            throw takeObject(r2);\n        }\n        var v1 = getArrayU8FromWasm0(r0, r1).slice();\n        wasm.__wbindgen_free(r0, r1 * 1);\n        return v1;\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\nlet stack_pointer = 32;\n\nfunction addBorrowedObject(obj) {\n    if (stack_pointer == 1) throw new Error('out of js stack');\n    heap[--stack_pointer] = obj;\n    return stack_pointer;\n}\n/**\n* Verify that the signature is presented to satisfy SigmaProp conditions.\n* @param {Address} address\n* @param {Uint8Array} message\n* @param {Uint8Array} signature\n* @returns {boolean}\n*/\nexport function verify_signature(address, message, signature) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        _assertClass(address, Address);\n        var ptr0 = passArray8ToWasm0(message, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ptr1 = passArray8ToWasm0(signature, wasm.__wbindgen_malloc);\n        var len1 = WASM_VECTOR_LEN;\n        wasm.verify_signature(retptr, address.ptr, ptr0, len0, ptr1, len1);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return r0 !== 0;\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\nfunction passArray32ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 4);\n    getUint32Memory0().set(arg, ptr / 4);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n\nfunction getArrayI32FromWasm0(ptr, len) {\n    return getInt32Memory0().subarray(ptr / 4, ptr / 4 + len);\n}\n\nfunction handleError(f, args) {\n    try {\n        return f.apply(this, args);\n    } catch (e) {\n        wasm.__wbindgen_exn_store(addHeapObject(e));\n    }\n}\nfunction __wbg_adapter_413(arg0, arg1, arg2, arg3) {\n    wasm.wasm_bindgen__convert__closures__invoke2_mut__h4cefed9586ed31bf(arg0, arg1, addHeapObject(arg2), addHeapObject(arg3));\n}\n\n/**\n* newtype for box registers R4 - R9\n*/\nexport const NonMandatoryRegisterId = Object.freeze({\n/**\n* id for R4 register\n*/\nR4:4,\"4\":\"R4\",\n/**\n* id for R5 register\n*/\nR5:5,\"5\":\"R5\",\n/**\n* id for R6 register\n*/\nR6:6,\"6\":\"R6\",\n/**\n* id for R7 register\n*/\nR7:7,\"7\":\"R7\",\n/**\n* id for R8 register\n*/\nR8:8,\"8\":\"R8\",\n/**\n* id for R9 register\n*/\nR9:9,\"9\":\"R9\", });\n/**\n* Network type\n*/\nexport const NetworkPrefix = Object.freeze({\n/**\n* Mainnet\n*/\nMainnet:0,\"0\":\"Mainnet\",\n/**\n* Testnet\n*/\nTestnet:16,\"16\":\"Testnet\", });\n/**\n* Address types\n*/\nexport const AddressTypePrefix = Object.freeze({\n/**\n* 0x01 - Pay-to-PublicKey(P2PK) address\n*/\nP2Pk:1,\"1\":\"P2Pk\",\n/**\n* 0x02 - Pay-to-Script-Hash(P2SH)\n*/\nPay2Sh:2,\"2\":\"Pay2Sh\",\n/**\n* 0x03 - Pay-to-Script(P2S)\n*/\nPay2S:3,\"3\":\"Pay2S\", });\n/**\n*\n* * An address is a short string corresponding to some script used to protect a box. Unlike (string-encoded) binary\n* * representation of a script, an address has some useful characteristics:\n* *\n* * - Integrity of an address could be checked., as it is incorporating a checksum.\n* * - A prefix of address is showing network and an address type.\n* * - An address is using an encoding (namely, Base58) which is avoiding similarly l0Oking characters, friendly to\n* * double-clicking and line-breaking in emails.\n* *\n* *\n* *\n* * An address is encoding network type, address type, checksum, and enough information to watch for a particular scripts.\n* *\n* * Possible network types are:\n* * Mainnet - 0x00\n* * Testnet - 0x10\n* *\n* * For an address type, we form content bytes as follows:\n* *\n* * P2PK - serialized (compressed) public key\n* * P2SH - first 192 bits of the Blake2b256 hash of serialized script bytes\n* * P2S  - serialized script\n* *\n* * Address examples for testnet:\n* *\n* * 3   - P2PK (3WvsT2Gm4EpsM9Pg18PdY6XyhNNMqXDsvJTbbf6ihLvAmSb7u5RN)\n* * ?   - P2SH (rbcrmKEYduUvADj9Ts3dSVSG27h54pgrq5fPuwB)\n* * ?   - P2S (Ms7smJwLGbUAjuWQ)\n* *\n* * for mainnet:\n* *\n* * 9  - P2PK (9fRAWhdxEsTcdb8PhGNrZfwqa65zfkuYHAMmkQLcic1gdLSV5vA)\n* * ?  - P2SH (8UApt8czfFVuTgQmMwtsRBZ4nfWquNiSwCWUjMg)\n* * ?  - P2S (4MQyML64GnzMxZgm, BxKBaHkvrTvLZrDcZjcsxsF7aSsrN73ijeFZXtbj4CXZHHcvBtqSxQ)\n* *\n* *\n* * Prefix byte = network type + address type\n* *\n* * checksum = blake2b256(prefix byte ++ content bytes)\n* *\n* * address = prefix byte ++ content bytes ++ checksum\n* *\n*\n*/\nexport class Address {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Address.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_address_free(ptr);\n    }\n    /**\n    * Re-create the address from ErgoTree that was built from the address\n    *\n    * At some point in the past a user entered an address from which the ErgoTree was built.\n    * Re-create the address from this ErgoTree.\n    * `tree` - ErgoTree that was created from an Address\n    * @param {ErgoTree} ergo_tree\n    * @returns {Address}\n    */\n    static recreate_from_ergo_tree(ergo_tree) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(ergo_tree, ErgoTree);\n            wasm.address_recreate_from_ergo_tree(retptr, ergo_tree.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Address.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Create a P2PK address from serialized PK bytes(EcPoint/GroupElement)\n    * @param {Uint8Array} bytes\n    * @returns {Address}\n    */\n    static p2pk_from_pk_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.address_p2pk_from_pk_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Address.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Decode (base58) testnet address from string, checking that address is from the testnet\n    * @param {string} s\n    * @returns {Address}\n    */\n    static from_testnet_str(s) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(s, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.address_from_testnet_str(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Address.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Decode (base58) mainnet address from string, checking that address is from the mainnet\n    * @param {string} s\n    * @returns {Address}\n    */\n    static from_mainnet_str(s) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(s, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.address_from_mainnet_str(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Address.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Decode (base58) address from string without checking the network prefix\n    * @param {string} s\n    * @returns {Address}\n    */\n    static from_base58(s) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(s, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.address_from_base58(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Address.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Encode (base58) address\n    * @param {number} network_prefix\n    * @returns {string}\n    */\n    to_base58(network_prefix) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.address_to_base58(retptr, this.ptr, network_prefix);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * Decode from a serialized address (that includes the network prefix)\n    * @param {Uint8Array} data\n    * @returns {Address}\n    */\n    static from_bytes(data) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passArray8ToWasm0(data, wasm.__wbindgen_malloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.address_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Address.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Encode address as serialized bytes (that includes the network prefix)\n    * @param {number} network_prefix\n    * @returns {Uint8Array}\n    */\n    to_bytes(network_prefix) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.address_to_bytes(retptr, this.ptr, network_prefix);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Get the type of the address\n    * @returns {number}\n    */\n    address_type_prefix() {\n        var ret = wasm.address_address_type_prefix(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Create an address from a public key\n    * @param {Uint8Array} bytes\n    * @returns {Address}\n    */\n    static from_public_key(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.address_from_public_key(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Address.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Creates an ErgoTree script from the address\n    * @returns {ErgoTree}\n    */\n    to_ergo_tree() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.address_to_ergo_tree(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ErgoTree.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n* BatchMerkleProof type to validate root hash for multiple nodes\n*/\nexport class BatchMerkleProof {\n\n    static __wrap(ptr) {\n        const obj = Object.create(BatchMerkleProof.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_batchmerkleproof_free(ptr);\n    }\n    /**\n    * Creates a new [`BatchMerkleProof`] from json representation\n    * @param {any} json\n    * @returns {BatchMerkleProof}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.batchmerkleproof_from_json(retptr, addBorrowedObject(json));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return BatchMerkleProof.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Converts [`BatchMerkleProof`] to json representation\n    * @returns {any}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.batchmerkleproof_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Calculates root hash for [`BatchMerkleProof`] and compares it against expected root hash\n    * @param {Uint8Array} expected_root\n    * @returns {boolean}\n    */\n    valid(expected_root) {\n        var ptr0 = passArray8ToWasm0(expected_root, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.batchmerkleproof_valid(this.ptr, ptr0, len0);\n        return ret !== 0;\n    }\n}\n/**\n* Block header\n*/\nexport class BlockHeader {\n\n    static __wrap(ptr) {\n        const obj = Object.create(BlockHeader.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_blockheader_free(ptr);\n    }\n    /**\n    * Parse from JSON (Node API)\n    * @param {string} json\n    * @returns {BlockHeader}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.blockheader_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return BlockHeader.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Get Header's id\n    * @returns {BlockId}\n    */\n    id() {\n        var ret = wasm.blockheader_id(this.ptr);\n        return BlockId.__wrap(ret);\n    }\n}\n/**\n* Collection of BlockHeaders\n*/\nexport class BlockHeaders {\n\n    static __wrap(ptr) {\n        const obj = Object.create(BlockHeaders.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_blockheaders_free(ptr);\n    }\n    /**\n    * parse BlockHeader array from JSON (Node API)\n    * @param {any[]} json_vals\n    * @returns {BlockHeaders}\n    */\n    static from_json(json_vals) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passArrayJsValueToWasm0(json_vals, wasm.__wbindgen_malloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.blockheaders_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return BlockHeaders.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Create new collection with one element\n    * @param {BlockHeader} b\n    */\n    constructor(b) {\n        _assertClass(b, BlockHeader);\n        var ret = wasm.blockheaders_new(b.ptr);\n        return BlockHeaders.__wrap(ret);\n    }\n    /**\n    * Returns the number of elements in the collection\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.blockheaders_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Add an element to the collection\n    * @param {BlockHeader} b\n    */\n    add(b) {\n        _assertClass(b, BlockHeader);\n        wasm.blockheaders_add(this.ptr, b.ptr);\n    }\n    /**\n    * Returns the element of the collection with a given index\n    * @param {number} index\n    * @returns {BlockHeader}\n    */\n    get(index) {\n        var ret = wasm.blockheaders_get(this.ptr, index);\n        return BlockHeader.__wrap(ret);\n    }\n}\n/**\n* Block id\n*/\nexport class BlockId {\n\n    static __wrap(ptr) {\n        const obj = Object.create(BlockId.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_blockid_free(ptr);\n    }\n}\n/**\n* Box id (32-byte digest)\n*/\nexport class BoxId {\n\n    static __wrap(ptr) {\n        const obj = Object.create(BoxId.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_boxid_free(ptr);\n    }\n    /**\n    * Parse box id (32 byte digest) from base16-encoded string\n    * @param {string} box_id_str\n    * @returns {BoxId}\n    */\n    static from_str(box_id_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(box_id_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.boxid_from_str(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return BoxId.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Base16 encoded string\n    * @returns {string}\n    */\n    to_str() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.boxid_to_str(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * Returns byte array (32 bytes)\n    * @returns {Uint8Array}\n    */\n    as_bytes() {\n        var ret = wasm.boxid_as_bytes(this.ptr);\n        return takeObject(ret);\n    }\n}\n/**\n* Selected boxes with change boxes (by [`BoxSelector`])\n*/\nexport class BoxSelection {\n\n    static __wrap(ptr) {\n        const obj = Object.create(BoxSelection.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_boxselection_free(ptr);\n    }\n    /**\n    * Create a selection to easily inject custom selection algorithms\n    * @param {ErgoBoxes} boxes\n    * @param {ErgoBoxAssetsDataList} change\n    */\n    constructor(boxes, change) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(boxes, ErgoBoxes);\n            _assertClass(change, ErgoBoxAssetsDataList);\n            wasm.boxselection_new(retptr, boxes.ptr, change.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return BoxSelection.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Selected boxes to spend as transaction inputs\n    * @returns {ErgoBoxes}\n    */\n    boxes() {\n        var ret = wasm.boxselection_boxes(this.ptr);\n        return ErgoBoxes.__wrap(ret);\n    }\n    /**\n    * Selected boxes to use as change\n    * @returns {ErgoBoxAssetsDataList}\n    */\n    change() {\n        var ret = wasm.boxselection_change(this.ptr);\n        return ErgoBoxAssetsDataList.__wrap(ret);\n    }\n}\n/**\n* Box value in nanoERGs with bound checks\n*/\nexport class BoxValue {\n\n    static __wrap(ptr) {\n        const obj = Object.create(BoxValue.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_boxvalue_free(ptr);\n    }\n    /**\n    * Recommended (safe) minimal box value to use in case box size estimation is unavailable.\n    * Allows box size upto 2777 bytes with current min box value per byte of 360 nanoERGs\n    * @returns {BoxValue}\n    */\n    static SAFE_USER_MIN() {\n        var ret = wasm.boxvalue_SAFE_USER_MIN();\n        return BoxValue.__wrap(ret);\n    }\n    /**\n    * Number of units inside one ERGO (i.e. one ERG using nano ERG representation)\n    * @returns {I64}\n    */\n    static UNITS_PER_ERGO() {\n        var ret = wasm.boxvalue_UNITS_PER_ERGO();\n        return I64.__wrap(ret);\n    }\n    /**\n    * Create from i64 with bounds check\n    * @param {I64} v\n    * @returns {BoxValue}\n    */\n    static from_i64(v) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(v, I64);\n            wasm.boxvalue_from_i64(retptr, v.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return BoxValue.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Get value as signed 64-bit long (I64)\n    * @returns {I64}\n    */\n    as_i64() {\n        var ret = wasm.boxvalue_as_i64(this.ptr);\n        return I64.__wrap(ret);\n    }\n    /**\n    * big-endian byte array representation\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.boxvalue_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n* CommitmentHint\n*/\nexport class CommitmentHint {\n\n    static __wrap(ptr) {\n        const obj = Object.create(CommitmentHint.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_commitmenthint_free(ptr);\n    }\n}\n/**\n* Ergo constant(evaluated) values\n*/\nexport class Constant {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Constant.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_constant_free(ptr);\n    }\n    /**\n    * Decode from Base16-encoded ErgoTree serialized value\n    * @param {string} base16_bytes_str\n    * @returns {Constant}\n    */\n    static decode_from_base16(base16_bytes_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(base16_bytes_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.constant_decode_from_base16(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Constant.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Encode as Base16-encoded ErgoTree serialized value or return an error if serialization\n    * failed\n    * @returns {string}\n    */\n    encode_to_base16() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.constant_encode_to_base16(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr0 = r0;\n            var len0 = r1;\n            if (r3) {\n                ptr0 = 0; len0 = 0;\n                throw takeObject(r2);\n            }\n            return getStringFromWasm0(ptr0, len0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(ptr0, len0);\n        }\n    }\n    /**\n    * Returns serialized bytes or fails with error if Constant cannot be serialized\n    * @returns {Uint8Array}\n    */\n    sigma_serialize_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.constant_sigma_serialize_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            if (r3) {\n                throw takeObject(r2);\n            }\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Create from i32 value\n    * @param {number} v\n    * @returns {Constant}\n    */\n    static from_i32(v) {\n        var ret = wasm.constant_from_i32(v);\n        return Constant.__wrap(ret);\n    }\n    /**\n    * Extract i32 value, returning error if wrong type\n    * @returns {number}\n    */\n    to_i32() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.constant_to_i32(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return r0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Create from i64\n    * @param {I64} v\n    * @returns {Constant}\n    */\n    static from_i64(v) {\n        _assertClass(v, I64);\n        var ret = wasm.constant_from_i64(v.ptr);\n        return Constant.__wrap(ret);\n    }\n    /**\n    * Extract i64 value, returning error if wrong type\n    * @returns {I64}\n    */\n    to_i64() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.constant_to_i64(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return I64.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Create BigInt constant from byte array (signed bytes bit-endian)\n    * @param {Uint8Array} num\n    * @returns {Constant}\n    */\n    static from_bigint_signed_bytes_be(num) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passArray8ToWasm0(num, wasm.__wbindgen_malloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.constant_from_bigint_signed_bytes_be(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Constant.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Create from byte array\n    * @param {Uint8Array} v\n    * @returns {Constant}\n    */\n    static from_byte_array(v) {\n        var ptr0 = passArray8ToWasm0(v, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.constant_from_byte_array(ptr0, len0);\n        return Constant.__wrap(ret);\n    }\n    /**\n    * Extract byte array, returning error if wrong type\n    * @returns {Uint8Array}\n    */\n    to_byte_array() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.constant_to_byte_array(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Create `Coll[Int]` from integer array\n    * @param {Int32Array} arr\n    * @returns {Constant}\n    */\n    static from_i32_array(arr) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passArray32ToWasm0(arr, wasm.__wbindgen_malloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.constant_from_i32_array(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Constant.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Extract `Coll[Int]` as integer array\n    * @returns {Int32Array}\n    */\n    to_i32_array() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.constant_to_i32_array(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            if (r3) {\n                throw takeObject(r2);\n            }\n            var v0 = getArrayI32FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 4);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Create `Coll[Long]` from string array\n    * @param {any[]} arr\n    * @returns {Constant}\n    */\n    static from_i64_str_array(arr) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passArrayJsValueToWasm0(arr, wasm.__wbindgen_malloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.constant_from_i64_str_array(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Constant.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Extract `Coll[Long]` as string array\n    * @returns {any[]}\n    */\n    to_i64_str_array() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.constant_to_i64_str_array(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            if (r3) {\n                throw takeObject(r2);\n            }\n            var v0 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 4);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Extract `Coll[Coll[Byte]]` as array of byte arrays\n    * @returns {(Uint8Array)[]}\n    */\n    to_coll_coll_byte() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.constant_to_coll_coll_byte(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            if (r3) {\n                throw takeObject(r2);\n            }\n            var v0 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 4);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Create `Coll[Coll[Byte]]` from array byte array\n    * @param {(Uint8Array)[]} arr\n    * @returns {Constant}\n    */\n    static from_coll_coll_byte(arr) {\n        var ptr0 = passArrayJsValueToWasm0(arr, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.constant_from_coll_coll_byte(ptr0, len0);\n        return Constant.__wrap(ret);\n    }\n    /**\n    * Parse raw `EcPoint` value from bytes and make `ProveDlog` constant\n    * @param {Uint8Array} bytes\n    * @returns {Constant}\n    */\n    static from_ecpoint_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.constant_from_ecpoint_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Constant.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Parse raw `EcPoint` value from bytes and make `GroupElement` constant\n    * @param {Uint8Array} bytes\n    * @returns {Constant}\n    */\n    static from_ecpoint_bytes_group_element(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.constant_from_ecpoint_bytes_group_element(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Constant.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Create `(Coll[Byte], Coll[Byte])` tuple Constant\n    * @param {Uint8Array} bytes1\n    * @param {Uint8Array} bytes2\n    * @returns {Constant}\n    */\n    static from_tuple_coll_bytes(bytes1, bytes2) {\n        var ptr0 = passArray8ToWasm0(bytes1, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ptr1 = passArray8ToWasm0(bytes2, wasm.__wbindgen_malloc);\n        var len1 = WASM_VECTOR_LEN;\n        var ret = wasm.constant_from_tuple_coll_bytes(ptr0, len0, ptr1, len1);\n        return Constant.__wrap(ret);\n    }\n    /**\n    * Extract `(Coll[Byte], Coll[Byte])` tuple from Constant as array of Uint8Array\n    * @returns {(Uint8Array)[]}\n    */\n    to_tuple_coll_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.constant_to_tuple_coll_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            if (r3) {\n                throw takeObject(r2);\n            }\n            var v0 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 4);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Create `(Int, Int)` tuple Constant\n    * @returns {any[]}\n    */\n    to_tuple_i32() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.constant_to_tuple_i32(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            if (r3) {\n                throw takeObject(r2);\n            }\n            var v0 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 4);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Create `(Long, Long)` tuple Constant\n    * @param {I64} l1\n    * @param {I64} l2\n    * @returns {Constant}\n    */\n    static from_tuple_i64(l1, l2) {\n        _assertClass(l1, I64);\n        _assertClass(l2, I64);\n        var ret = wasm.constant_from_tuple_i64(l1.ptr, l2.ptr);\n        return Constant.__wrap(ret);\n    }\n    /**\n    * Extract `(Long, Long)` tuple from Constant as array of strings\n    * @returns {any[]}\n    */\n    to_tuple_i64() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.constant_to_tuple_i64(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            if (r3) {\n                throw takeObject(r2);\n            }\n            var v0 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 4);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Create from ErgoBox value\n    * @param {ErgoBox} v\n    * @returns {Constant}\n    */\n    static from_ergo_box(v) {\n        _assertClass(v, ErgoBox);\n        var ret = wasm.constant_from_ergo_box(v.ptr);\n        return Constant.__wrap(ret);\n    }\n    /**\n    * Extract ErgoBox value, returning error if wrong type\n    * @returns {ErgoBox}\n    */\n    to_ergo_box() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.constant_to_ergo_box(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ErgoBox.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n* User-defined variables to be put into context\n*/\nexport class ContextExtension {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ContextExtension.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_contextextension_free(ptr);\n    }\n    /**\n    * Create new ContextExtension instance\n    */\n    constructor() {\n        var ret = wasm.contextextension_new();\n        return ContextExtension.__wrap(ret);\n    }\n    /**\n    * Set the supplied pair in the ContextExtension\n    * @param {number} id\n    * @param {Constant} value\n    */\n    set_pair(id, value) {\n        _assertClass(value, Constant);\n        wasm.contextextension_set_pair(this.ptr, id, value.ptr);\n    }\n    /**\n    * Returns the number of elements in the collection\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.contextextension_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * get from map or fail if key is missing\n    * @param {number} key\n    * @returns {Constant}\n    */\n    get(key) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.contextextension_get(retptr, this.ptr, key);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Constant.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Returns all keys in the map\n    * @returns {Uint8Array}\n    */\n    keys() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.contextextension_keys(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Returns serialized bytes or fails with error if ContextExtension cannot be serialized\n    * @returns {Uint8Array}\n    */\n    sigma_serialize_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.contextextension_sigma_serialize_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            if (r3) {\n                throw takeObject(r2);\n            }\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n* Defines the contract(script) that will be guarding box contents\n*/\nexport class Contract {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Contract.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_contract_free(ptr);\n    }\n    /**\n    * Create new contract from ErgoTree\n    * @param {ErgoTree} ergo_tree\n    * @returns {Contract}\n    */\n    static new(ergo_tree) {\n        _assertClass(ergo_tree, ErgoTree);\n        var ptr0 = ergo_tree.ptr;\n        ergo_tree.ptr = 0;\n        var ret = wasm.contract_new(ptr0);\n        return Contract.__wrap(ret);\n    }\n    /**\n    * create new contract that allow spending of the guarded box by a given recipient ([`Address`])\n    * @param {Address} recipient\n    * @returns {Contract}\n    */\n    static pay_to_address(recipient) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(recipient, Address);\n            wasm.contract_pay_to_address(retptr, recipient.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Contract.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Compiles a contract from ErgoScript source code\n    * @param {string} source\n    * @returns {Contract}\n    */\n    static compile(source) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(source, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.contract_compile(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Contract.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Get the ErgoTree of the contract\n    * @returns {ErgoTree}\n    */\n    ergo_tree() {\n        var ret = wasm.contract_ergo_tree(this.ptr);\n        return ErgoTree.__wrap(ret);\n    }\n}\n/**\n* Inputs, that are used to enrich script context, but won't be spent by the transaction\n*/\nexport class DataInput {\n\n    static __wrap(ptr) {\n        const obj = Object.create(DataInput.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_datainput_free(ptr);\n    }\n    /**\n    * Parse box id (32 byte digest) from base16-encoded string\n    * @param {BoxId} box_id\n    */\n    constructor(box_id) {\n        _assertClass(box_id, BoxId);\n        var ptr0 = box_id.ptr;\n        box_id.ptr = 0;\n        var ret = wasm.datainput_new(ptr0);\n        return DataInput.__wrap(ret);\n    }\n    /**\n    * Get box id\n    * @returns {BoxId}\n    */\n    box_id() {\n        var ret = wasm.datainput_box_id(this.ptr);\n        return BoxId.__wrap(ret);\n    }\n}\n/**\n* DataInput collection\n*/\nexport class DataInputs {\n\n    static __wrap(ptr) {\n        const obj = Object.create(DataInputs.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_datainputs_free(ptr);\n    }\n    /**\n    * Create empty DataInputs\n    */\n    constructor() {\n        var ret = wasm.datainputs_new();\n        return DataInputs.__wrap(ret);\n    }\n    /**\n    * Returns the number of elements in the collection\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.datainputs_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Returns the element of the collection with a given index\n    * @param {number} index\n    * @returns {DataInput}\n    */\n    get(index) {\n        var ret = wasm.datainputs_get(this.ptr, index);\n        return DataInput.__wrap(ret);\n    }\n    /**\n    * Adds an elements to the collection\n    * @param {DataInput} elem\n    */\n    add(elem) {\n        _assertClass(elem, DataInput);\n        wasm.datainputs_add(this.ptr, elem.ptr);\n    }\n}\n/**\n* According to\n* BIP-44 <https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki>\n* and EIP-3 <https://github.com/ergoplatform/eips/blob/master/eip-0003.md>\n*/\nexport class DerivationPath {\n\n    static __wrap(ptr) {\n        const obj = Object.create(DerivationPath.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_derivationpath_free(ptr);\n    }\n    /**\n    * Create derivation path for a given account index (hardened) and address indices\n    * `m / 44' / 429' / acc' / 0 / address[0] / address[1] / ...`\n    * or `m / 44' / 429' / acc' / 0` if address indices are empty\n    * change is always zero according to EIP-3\n    * acc is expected as a 31-bit value (32th bit should not be set)\n    * @param {number} acc\n    * @param {Uint32Array} address_indices\n    * @returns {DerivationPath}\n    */\n    static new(acc, address_indices) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passArray32ToWasm0(address_indices, wasm.__wbindgen_malloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.derivationpath_new(retptr, acc, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return DerivationPath.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Create root derivation path\n    * @returns {DerivationPath}\n    */\n    static master_path() {\n        var ret = wasm.derivationpath_master_path();\n        return DerivationPath.__wrap(ret);\n    }\n    /**\n    * Returns the length of the derivation path\n    * @returns {number}\n    */\n    depth() {\n        var ret = wasm.derivationpath_depth(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Returns a new path with the last element of the deriviation path being increased, e.g. m/1/2 -> m/1/3\n    * Returns an empty path error if the path is empty (master node)\n    * @returns {DerivationPath}\n    */\n    next() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.derivationpath_next(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return DerivationPath.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * String representation of derivation path\n    * E.g m/44'/429'/0'/0/1\n    * @returns {string}\n    */\n    toString() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.derivationpath_toString(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * Create a derivation path from a formatted string\n    * E.g \"m/44'/429'/0'/0/1\"\n    * @param {string} path\n    * @returns {DerivationPath}\n    */\n    static from_string(path) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(path, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.derivationpath_from_string(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return DerivationPath.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * For 0x21 Sign Transaction command of Ergo Ledger App Protocol\n    * P2PK Sign (0x0D) instruction\n    * Sign calculated TX hash with private key for provided BIP44 path.\n    * Data:\n    *\n    * Field\n    * Size (B)\n    * Description\n    *\n    * BIP32 path length\n    * 1\n    * Value: 0x02-0x0A (2-10). Number of path components\n    *\n    * First derivation index\n    * 4\n    * Big-endian. Value: 44’\n    *\n    * Second derivation index\n    * 4\n    * Big-endian. Value: 429’ (Ergo coin id)\n    *\n    * Optional Third index\n    * 4\n    * Big-endian. Any valid bip44 hardened value.\n    * ...\n    * Optional Last index\n    * 4\n    * Big-endian. Any valid bip44 value.\n    * @returns {Uint8Array}\n    */\n    ledger_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.derivationpath_ledger_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n* Ergo box, that is taking part in some transaction on the chain\n* Differs with [`ErgoBoxCandidate`] by added transaction id and an index in the input of that transaction\n*/\nexport class ErgoBox {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ErgoBox.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_ergobox_free(ptr);\n    }\n    /**\n    * make a new box with:\n    * `value` - amount of money associated with the box\n    * `contract` - guarding contract([`Contract`]), which should be evaluated to true in order\n    * to open(spend) this box\n    * `creation_height` - height when a transaction containing the box is created.\n    * `tx_id` - transaction id in which this box was \"created\" (participated in outputs)\n    * `index` - index (in outputs) in the transaction\n    * @param {BoxValue} value\n    * @param {number} creation_height\n    * @param {Contract} contract\n    * @param {TxId} tx_id\n    * @param {number} index\n    * @param {Tokens} tokens\n    */\n    constructor(value, creation_height, contract, tx_id, index, tokens) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(value, BoxValue);\n            _assertClass(contract, Contract);\n            _assertClass(tx_id, TxId);\n            _assertClass(tokens, Tokens);\n            wasm.ergobox_new(retptr, value.ptr, creation_height, contract.ptr, tx_id.ptr, index, tokens.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ErgoBox.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Get box id\n    * @returns {BoxId}\n    */\n    box_id() {\n        var ret = wasm.ergobox_box_id(this.ptr);\n        return BoxId.__wrap(ret);\n    }\n    /**\n    * Get id of transaction which created the box\n    * @returns {TxId}\n    */\n    tx_id() {\n        var ret = wasm.ergobox_tx_id(this.ptr);\n        return TxId.__wrap(ret);\n    }\n    /**\n    * Index of this box in transaction outputs\n    * @returns {number}\n    */\n    index() {\n        var ret = wasm.ergobox_index(this.ptr);\n        return ret;\n    }\n    /**\n    * Get box creation height\n    * @returns {number}\n    */\n    creation_height() {\n        var ret = wasm.ergobox_creation_height(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Get tokens for box\n    * @returns {Tokens}\n    */\n    tokens() {\n        var ret = wasm.ergobox_tokens(this.ptr);\n        return Tokens.__wrap(ret);\n    }\n    /**\n    * Get ergo tree for box\n    * @returns {ErgoTree}\n    */\n    ergo_tree() {\n        var ret = wasm.ergobox_ergo_tree(this.ptr);\n        return ErgoTree.__wrap(ret);\n    }\n    /**\n    * Get box value in nanoERGs\n    * @returns {BoxValue}\n    */\n    value() {\n        var ret = wasm.ergobox_value(this.ptr);\n        return BoxValue.__wrap(ret);\n    }\n    /**\n    * Returns value (ErgoTree constant) stored in the register or None if the register is empty\n    * @param {number} register_id\n    * @returns {Constant | undefined}\n    */\n    register_value(register_id) {\n        var ret = wasm.ergobox_register_value(this.ptr, register_id);\n        return ret === 0 ? undefined : Constant.__wrap(ret);\n    }\n    /**\n    * JSON representation as text (compatible with Ergo Node/Explorer API, numbers are encoded as numbers)\n    * @returns {string}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ergobox_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr0 = r0;\n            var len0 = r1;\n            if (r3) {\n                ptr0 = 0; len0 = 0;\n                throw takeObject(r2);\n            }\n            return getStringFromWasm0(ptr0, len0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(ptr0, len0);\n        }\n    }\n    /**\n    * JSON representation according to EIP-12 <https://github.com/ergoplatform/eips/pull/23>\n    * (similar to [`Self::to_json`], but as JS object with box value and token amounts encoding as strings)\n    * @returns {any}\n    */\n    to_js_eip12() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ergobox_to_js_eip12(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * parse from JSON\n    * supports Ergo Node/Explorer API and box values and token amount encoded as strings\n    * @param {string} json\n    * @returns {ErgoBox}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.ergobox_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ErgoBox.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Serialized additional register as defined in ErgoBox serialization (registers count,\n    * followed by every non-empyt register value serialized)\n    * @returns {Uint8Array}\n    */\n    serialized_additional_registers() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ergobox_serialized_additional_registers(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            if (r3) {\n                throw takeObject(r2);\n            }\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Returns serialized bytes or fails with error if cannot be serialized\n    * @returns {Uint8Array}\n    */\n    sigma_serialize_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ergobox_sigma_serialize_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            if (r3) {\n                throw takeObject(r2);\n            }\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Parses ErgoBox or fails with error\n    * @param {Uint8Array} data\n    * @returns {ErgoBox}\n    */\n    static sigma_parse_bytes(data) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passArray8ToWasm0(data, wasm.__wbindgen_malloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.ergobox_sigma_parse_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ErgoBox.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n* Pair of <value, tokens> for an box\n*/\nexport class ErgoBoxAssetsData {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ErgoBoxAssetsData.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_ergoboxassetsdata_free(ptr);\n    }\n    /**\n    * Create new instance\n    * @param {BoxValue} value\n    * @param {Tokens} tokens\n    */\n    constructor(value, tokens) {\n        _assertClass(value, BoxValue);\n        _assertClass(tokens, Tokens);\n        var ret = wasm.ergoboxassetsdata_new(value.ptr, tokens.ptr);\n        return ErgoBoxAssetsData.__wrap(ret);\n    }\n    /**\n    * Value part of the box\n    * @returns {BoxValue}\n    */\n    value() {\n        var ret = wasm.ergoboxassetsdata_value(this.ptr);\n        return BoxValue.__wrap(ret);\n    }\n    /**\n    * Tokens part of the box\n    * @returns {Tokens}\n    */\n    tokens() {\n        var ret = wasm.ergoboxassetsdata_tokens(this.ptr);\n        return Tokens.__wrap(ret);\n    }\n}\n/**\n* List of asset data for a box\n*/\nexport class ErgoBoxAssetsDataList {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ErgoBoxAssetsDataList.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_ergoboxassetsdatalist_free(ptr);\n    }\n    /**\n    * Create empty Tokens\n    */\n    constructor() {\n        var ret = wasm.ergoboxassetsdatalist_new();\n        return ErgoBoxAssetsDataList.__wrap(ret);\n    }\n    /**\n    * Returns the number of elements in the collection\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.ergoboxassetsdatalist_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Returns the element of the collection with a given index\n    * @param {number} index\n    * @returns {ErgoBoxAssetsData}\n    */\n    get(index) {\n        var ret = wasm.ergoboxassetsdatalist_get(this.ptr, index);\n        return ErgoBoxAssetsData.__wrap(ret);\n    }\n    /**\n    * Adds an elements to the collection\n    * @param {ErgoBoxAssetsData} elem\n    */\n    add(elem) {\n        _assertClass(elem, ErgoBoxAssetsData);\n        wasm.ergoboxassetsdatalist_add(this.ptr, elem.ptr);\n    }\n}\n/**\n* ErgoBox candidate not yet included in any transaction on the chain\n*/\nexport class ErgoBoxCandidate {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ErgoBoxCandidate.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_ergoboxcandidate_free(ptr);\n    }\n    /**\n    * Create a box with miner's contract and given value\n    * @param {BoxValue} fee_amount\n    * @param {number} creation_height\n    * @returns {ErgoBoxCandidate}\n    */\n    static new_miner_fee_box(fee_amount, creation_height) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(fee_amount, BoxValue);\n            wasm.ergoboxcandidate_new_miner_fee_box(retptr, fee_amount.ptr, creation_height);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ErgoBoxCandidate.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Returns value (ErgoTree constant) stored in the register or None if the register is empty\n    * @param {number} register_id\n    * @returns {Constant | undefined}\n    */\n    register_value(register_id) {\n        var ret = wasm.ergoboxcandidate_register_value(this.ptr, register_id);\n        return ret === 0 ? undefined : Constant.__wrap(ret);\n    }\n    /**\n    * Get box creation height\n    * @returns {number}\n    */\n    creation_height() {\n        var ret = wasm.ergoboxcandidate_creation_height(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Get tokens for box\n    * @returns {Tokens}\n    */\n    tokens() {\n        var ret = wasm.ergoboxcandidate_tokens(this.ptr);\n        return Tokens.__wrap(ret);\n    }\n    /**\n    * Get ergo tree for box\n    * @returns {ErgoTree}\n    */\n    ergo_tree() {\n        var ret = wasm.ergoboxcandidate_ergo_tree(this.ptr);\n        return ErgoTree.__wrap(ret);\n    }\n    /**\n    * Get box value in nanoERGs\n    * @returns {BoxValue}\n    */\n    value() {\n        var ret = wasm.ergoboxcandidate_value(this.ptr);\n        return BoxValue.__wrap(ret);\n    }\n    /**\n    * Serialized additional register as defined in ErgoBox serialization (registers count,\n    * followed by every non-empyt register value serialized)\n    * @returns {Uint8Array}\n    */\n    serialized_additional_registers() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ergoboxcandidate_serialized_additional_registers(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            if (r3) {\n                throw takeObject(r2);\n            }\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n* ErgoBoxCandidate builder\n*/\nexport class ErgoBoxCandidateBuilder {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ErgoBoxCandidateBuilder.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_ergoboxcandidatebuilder_free(ptr);\n    }\n    /**\n    * Create builder with required box parameters:\n    * `value` - amount of money associated with the box\n    * `contract` - guarding contract([`Contract`]), which should be evaluated to true in order\n    * to open(spend) this box\n    * `creation_height` - height when a transaction containing the box is created.\n    * It should not exceed height of the block, containing the transaction with this box.\n    * @param {BoxValue} value\n    * @param {Contract} contract\n    * @param {number} creation_height\n    */\n    constructor(value, contract, creation_height) {\n        _assertClass(value, BoxValue);\n        _assertClass(contract, Contract);\n        var ret = wasm.ergoboxcandidatebuilder_new(value.ptr, contract.ptr, creation_height);\n        return ErgoBoxCandidateBuilder.__wrap(ret);\n    }\n    /**\n    * Set minimal value (per byte of the serialized box size)\n    * @param {number} new_min_value_per_byte\n    */\n    set_min_box_value_per_byte(new_min_value_per_byte) {\n        wasm.ergoboxcandidatebuilder_set_min_box_value_per_byte(this.ptr, new_min_value_per_byte);\n    }\n    /**\n    * Get minimal value (per byte of the serialized box size)\n    * @returns {number}\n    */\n    min_box_value_per_byte() {\n        var ret = wasm.ergoboxcandidatebuilder_min_box_value_per_byte(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Set new box value\n    * @param {BoxValue} new_value\n    */\n    set_value(new_value) {\n        _assertClass(new_value, BoxValue);\n        var ptr0 = new_value.ptr;\n        new_value.ptr = 0;\n        wasm.ergoboxcandidatebuilder_set_value(this.ptr, ptr0);\n    }\n    /**\n    * Get box value\n    * @returns {BoxValue}\n    */\n    value() {\n        var ret = wasm.ergoboxcandidatebuilder_value(this.ptr);\n        return BoxValue.__wrap(ret);\n    }\n    /**\n    * Calculate serialized box size(in bytes)\n    * @returns {number}\n    */\n    calc_box_size_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ergoboxcandidatebuilder_calc_box_size_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return r0 >>> 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Calculate minimal box value for the current box serialized size(in bytes)\n    * @returns {BoxValue}\n    */\n    calc_min_box_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ergoboxcandidatebuilder_calc_min_box_value(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return BoxValue.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Set register with a given id (R4-R9) to the given value\n    * @param {number} register_id\n    * @param {Constant} value\n    */\n    set_register_value(register_id, value) {\n        _assertClass(value, Constant);\n        wasm.ergoboxcandidatebuilder_set_register_value(this.ptr, register_id, value.ptr);\n    }\n    /**\n    * Returns register value for the given register id (R4-R9), or None if the register is empty\n    * @param {number} register_id\n    * @returns {Constant | undefined}\n    */\n    register_value(register_id) {\n        var ret = wasm.ergoboxcandidatebuilder_register_value(this.ptr, register_id);\n        return ret === 0 ? undefined : Constant.__wrap(ret);\n    }\n    /**\n    * Delete register value(make register empty) for the given register id (R4-R9)\n    * @param {number} register_id\n    */\n    delete_register_value(register_id) {\n        wasm.ergoboxcandidatebuilder_delete_register_value(this.ptr, register_id);\n    }\n    /**\n    * Mint token, as defined in <https://github.com/ergoplatform/eips/blob/master/eip-0004.md>\n    * `token` - token id(box id of the first input box in transaction) and token amount,\n    * `token_name` - token name (will be encoded in R4),\n    * `token_desc` - token description (will be encoded in R5),\n    * `num_decimals` - number of decimals (will be encoded in R6)\n    * @param {Token} token\n    * @param {string} token_name\n    * @param {string} token_desc\n    * @param {number} num_decimals\n    */\n    mint_token(token, token_name, token_desc, num_decimals) {\n        _assertClass(token, Token);\n        var ptr0 = passStringToWasm0(token_name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ptr1 = passStringToWasm0(token_desc, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len1 = WASM_VECTOR_LEN;\n        wasm.ergoboxcandidatebuilder_mint_token(this.ptr, token.ptr, ptr0, len0, ptr1, len1, num_decimals);\n    }\n    /**\n    * Add given token id and token amount\n    * @param {TokenId} token_id\n    * @param {TokenAmount} amount\n    */\n    add_token(token_id, amount) {\n        _assertClass(token_id, TokenId);\n        _assertClass(amount, TokenAmount);\n        wasm.ergoboxcandidatebuilder_add_token(this.ptr, token_id.ptr, amount.ptr);\n    }\n    /**\n    * Build the box candidate\n    * @returns {ErgoBoxCandidate}\n    */\n    build() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ergoboxcandidatebuilder_build(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ErgoBoxCandidate.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n* Collection of ErgoBoxCandidates\n*/\nexport class ErgoBoxCandidates {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ErgoBoxCandidates.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_ergoboxcandidates_free(ptr);\n    }\n    /**\n    * Create new outputs\n    * @param {ErgoBoxCandidate} box_candidate\n    */\n    constructor(box_candidate) {\n        _assertClass(box_candidate, ErgoBoxCandidate);\n        var ret = wasm.ergoboxcandidates_new(box_candidate.ptr);\n        return ErgoBoxCandidates.__wrap(ret);\n    }\n    /**\n    * sometimes it's useful to keep track of an empty list\n    * but keep in mind Ergo transactions need at least 1 output\n    * @returns {ErgoBoxCandidates}\n    */\n    static empty() {\n        var ret = wasm.ergoboxcandidates_empty();\n        return ErgoBoxCandidates.__wrap(ret);\n    }\n    /**\n    * Returns the number of elements in the collection\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.ergoboxcandidates_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Returns the element of the collection with a given index\n    * @param {number} index\n    * @returns {ErgoBoxCandidate}\n    */\n    get(index) {\n        var ret = wasm.ergoboxcandidates_get(this.ptr, index);\n        return ErgoBoxCandidate.__wrap(ret);\n    }\n    /**\n    * Add an element to the collection\n    * @param {ErgoBoxCandidate} b\n    */\n    add(b) {\n        _assertClass(b, ErgoBoxCandidate);\n        wasm.ergoboxcandidates_add(this.ptr, b.ptr);\n    }\n}\n/**\n* Collection of ErgoBox'es\n*/\nexport class ErgoBoxes {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ErgoBoxes.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_ergoboxes_free(ptr);\n    }\n    /**\n    * parse ErgoBox array from json\n    * @param {any[]} json_vals\n    * @returns {ErgoBoxes}\n    */\n    static from_boxes_json(json_vals) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passArrayJsValueToWasm0(json_vals, wasm.__wbindgen_malloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.ergoboxes_from_boxes_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ErgoBoxes.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Create new collection with one element\n    * @param {ErgoBox} b\n    */\n    constructor(b) {\n        _assertClass(b, ErgoBox);\n        var ret = wasm.ergoboxes_new(b.ptr);\n        return ErgoBoxes.__wrap(ret);\n    }\n    /**\n    * Returns the number of elements in the collection\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.ergoboxes_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Add an element to the collection\n    * @param {ErgoBox} b\n    */\n    add(b) {\n        _assertClass(b, ErgoBox);\n        wasm.ergoboxes_add(this.ptr, b.ptr);\n    }\n    /**\n    * Returns the element of the collection with a given index\n    * @param {number} index\n    * @returns {ErgoBox}\n    */\n    get(index) {\n        var ret = wasm.ergoboxes_get(this.ptr, index);\n        return ErgoBox.__wrap(ret);\n    }\n    /**\n    * Empty ErgoBoxes\n    * @returns {ErgoBoxes}\n    */\n    static empty() {\n        var ret = wasm.ergoboxes_empty();\n        return ErgoBoxes.__wrap(ret);\n    }\n}\n/**\n* Blockchain state (last headers, etc.)\n*/\nexport class ErgoStateContext {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ErgoStateContext.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_ergostatecontext_free(ptr);\n    }\n    /**\n    * Create new context from pre-header\n    * @param {PreHeader} pre_header\n    * @param {BlockHeaders} headers\n    */\n    constructor(pre_header, headers) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(pre_header, PreHeader);\n            var ptr0 = pre_header.ptr;\n            pre_header.ptr = 0;\n            _assertClass(headers, BlockHeaders);\n            var ptr1 = headers.ptr;\n            headers.ptr = 0;\n            wasm.ergostatecontext_new(retptr, ptr0, ptr1);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ErgoStateContext.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n* The root of ErgoScript IR. Serialized instances of this class are self sufficient and can be passed around.\n*/\nexport class ErgoTree {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ErgoTree.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_ergotree_free(ptr);\n    }\n    /**\n    * Decode from base16 encoded serialized ErgoTree\n    * @param {string} s\n    * @returns {ErgoTree}\n    */\n    static from_base16_bytes(s) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(s, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.ergotree_from_base16_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ErgoTree.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Decode from encoded serialized ErgoTree\n    * @param {Uint8Array} data\n    * @returns {ErgoTree}\n    */\n    static from_bytes(data) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passArray8ToWasm0(data, wasm.__wbindgen_malloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.ergotree_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ErgoTree.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Returns serialized bytes or fails with error if ErgoTree cannot be serialized\n    * @returns {Uint8Array}\n    */\n    sigma_serialize_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ergotree_sigma_serialize_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            if (r3) {\n                throw takeObject(r2);\n            }\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Returns Base16-encoded serialized bytes\n    * @returns {string}\n    */\n    to_base16_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ergotree_to_base16_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr0 = r0;\n            var len0 = r1;\n            if (r3) {\n                ptr0 = 0; len0 = 0;\n                throw takeObject(r2);\n            }\n            return getStringFromWasm0(ptr0, len0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(ptr0, len0);\n        }\n    }\n    /**\n    * Returns constants number as stored in serialized ErgoTree or error if the parsing of\n    * constants is failed\n    * @returns {number}\n    */\n    constants_len() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ergotree_constants_len(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return r0 >>> 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Returns constant with given index (as stored in serialized ErgoTree)\n    * or None if index is out of bounds\n    * or error if constants parsing were failed\n    * @param {number} index\n    * @returns {Constant | undefined}\n    */\n    get_constant(index) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ergotree_get_constant(retptr, this.ptr, index);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return r0 === 0 ? undefined : Constant.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Consumes the calling ErgoTree and returns new ErgoTree with a new constant value\n    * for a given index in constants list (as stored in serialized ErgoTree), or an error.\n    * After the call the calling ErgoTree will be null.\n    * @param {number} index\n    * @param {Constant} constant\n    * @returns {ErgoTree}\n    */\n    with_constant(index, constant) {\n        try {\n            const ptr = this.__destroy_into_raw();\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(constant, Constant);\n            wasm.ergotree_with_constant(retptr, ptr, index, constant.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ErgoTree.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Serialized proposition expression of SigmaProp type with\n    * ConstantPlaceholder nodes instead of Constant nodes\n    * @returns {Uint8Array}\n    */\n    template_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ergotree_template_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            if (r3) {\n                throw takeObject(r2);\n            }\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n* Extented public key implemented according to BIP-32\n*/\nexport class ExtPubKey {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ExtPubKey.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_extpubkey_free(ptr);\n    }\n    /**\n    * Create ExtPubKey from public key bytes (from SEC1 compressed), chain code and derivation\n    * path\n    * @param {Uint8Array} public_key_bytes\n    * @param {Uint8Array} chain_code\n    * @param {DerivationPath} derivation_path\n    * @returns {ExtPubKey}\n    */\n    static new(public_key_bytes, chain_code, derivation_path) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passArray8ToWasm0(public_key_bytes, wasm.__wbindgen_malloc);\n            var len0 = WASM_VECTOR_LEN;\n            var ptr1 = passArray8ToWasm0(chain_code, wasm.__wbindgen_malloc);\n            var len1 = WASM_VECTOR_LEN;\n            _assertClass(derivation_path, DerivationPath);\n            wasm.extpubkey_new(retptr, ptr0, len0, ptr1, len1, derivation_path.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ExtPubKey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Soft derivation of the child public key with a given index\n    * index is expected to be a 31-bit value(32th bit should not be set)\n    * @param {number} index\n    * @returns {ExtPubKey}\n    */\n    child(index) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.extpubkey_child(retptr, this.ptr, index);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ExtPubKey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Derive a new extended pub key from the derivation path\n    * @param {DerivationPath} path\n    * @returns {ExtPubKey}\n    */\n    derive(path) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(path, DerivationPath);\n            var ptr0 = path.ptr;\n            path.ptr = 0;\n            wasm.extpubkey_derive(retptr, this.ptr, ptr0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ExtPubKey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Create address (P2PK) from this extended public key\n    * @returns {Address}\n    */\n    to_address() {\n        var ret = wasm.extpubkey_to_address(this.ptr);\n        return Address.__wrap(ret);\n    }\n    /**\n    * Chain code of the `ExtPubKey`\n    * @returns {Uint8Array}\n    */\n    chain_code() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.extpubkey_chain_code(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Public key bytes of the `ExtPubKey`\n    * @returns {Uint8Array}\n    */\n    pub_key_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.extpubkey_pub_key_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n* Extented secret key implemented according to BIP-32\n*/\nexport class ExtSecretKey {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ExtSecretKey.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_extsecretkey_free(ptr);\n    }\n    /**\n    * Create ExtSecretKey from secret key bytes, chain code and derivation path\n    * @param {Uint8Array} secret_key_bytes\n    * @param {Uint8Array} chain_code\n    * @param {DerivationPath} derivation_path\n    * @returns {ExtSecretKey}\n    */\n    static new(secret_key_bytes, chain_code, derivation_path) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passArray8ToWasm0(secret_key_bytes, wasm.__wbindgen_malloc);\n            var len0 = WASM_VECTOR_LEN;\n            var ptr1 = passArray8ToWasm0(chain_code, wasm.__wbindgen_malloc);\n            var len1 = WASM_VECTOR_LEN;\n            _assertClass(derivation_path, DerivationPath);\n            wasm.extsecretkey_new(retptr, ptr0, len0, ptr1, len1, derivation_path.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ExtSecretKey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Derive root extended secret key\n    * @param {Uint8Array} seed_bytes\n    * @returns {ExtSecretKey}\n    */\n    static derive_master(seed_bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passArray8ToWasm0(seed_bytes, wasm.__wbindgen_malloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.extsecretkey_derive_master(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ExtSecretKey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Derive a new extended secret key from the provided index\n    * The index is in the form of soft or hardened indices\n    * For example: 4 or 4' respectively\n    * @param {string} index\n    * @returns {ExtSecretKey}\n    */\n    child(index) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(index, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.extsecretkey_child(retptr, this.ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ExtSecretKey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Derive a new extended secret key from the derivation path\n    * @param {DerivationPath} path\n    * @returns {ExtSecretKey}\n    */\n    derive(path) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(path, DerivationPath);\n            var ptr0 = path.ptr;\n            path.ptr = 0;\n            wasm.extsecretkey_derive(retptr, this.ptr, ptr0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ExtSecretKey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * The bytes of the associated secret key\n    * @returns {Uint8Array}\n    */\n    secret_key_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.extsecretkey_secret_key_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            if (r3) {\n                throw takeObject(r2);\n            }\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * The extended public key associated with this secret key\n    * @returns {ExtPubKey}\n    */\n    public_key() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.extsecretkey_public_key(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ExtPubKey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Derivation path associated with the ext secret key\n    * @returns {DerivationPath}\n    */\n    path() {\n        var ret = wasm.extsecretkey_path(this.ptr);\n        return DerivationPath.__wrap(ret);\n    }\n}\n/**\n* HintsBag\n*/\nexport class HintsBag {\n\n    static __wrap(ptr) {\n        const obj = Object.create(HintsBag.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_hintsbag_free(ptr);\n    }\n    /**\n    * Empty HintsBag\n    * @returns {HintsBag}\n    */\n    static empty() {\n        var ret = wasm.hintsbag_empty();\n        return HintsBag.__wrap(ret);\n    }\n    /**\n    * Add commitment hint to the bag\n    * @param {CommitmentHint} hint\n    */\n    add_commitment(hint) {\n        _assertClass(hint, CommitmentHint);\n        var ptr0 = hint.ptr;\n        hint.ptr = 0;\n        wasm.hintsbag_add_commitment(this.ptr, ptr0);\n    }\n    /**\n    * Length of HintsBag\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.hintsbag_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Get commitment\n    * @param {number} index\n    * @returns {CommitmentHint}\n    */\n    get(index) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.hintsbag_get(retptr, this.ptr, index);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return CommitmentHint.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n* Wrapper for i64 for JS/TS\n*/\nexport class I64 {\n\n    static __wrap(ptr) {\n        const obj = Object.create(I64.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_i64_free(ptr);\n    }\n    /**\n    * Create from a standard rust string representation\n    * @param {string} string\n    * @returns {I64}\n    */\n    static from_str(string) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(string, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.i64_from_str(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return I64.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * String representation of the value for use from environments that don't support i64\n    * @returns {string}\n    */\n    to_str() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.i64_to_str(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * Get the value as JS number (64-bit float)\n    * @returns {number}\n    */\n    as_num() {\n        var ret = wasm.i64_as_num(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * Addition with overflow check\n    * @param {I64} other\n    * @returns {I64}\n    */\n    checked_add(other) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(other, I64);\n            wasm.i64_checked_add(retptr, this.ptr, other.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return I64.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n* Signed inputs used in signed transactions\n*/\nexport class Input {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Input.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_input_free(ptr);\n    }\n    /**\n    * Get box id\n    * @returns {BoxId}\n    */\n    box_id() {\n        var ret = wasm.input_box_id(this.ptr);\n        return BoxId.__wrap(ret);\n    }\n    /**\n    * Get the spending proof\n    * @returns {ProverResult}\n    */\n    spending_proof() {\n        var ret = wasm.input_spending_proof(this.ptr);\n        return ProverResult.__wrap(ret);\n    }\n}\n/**\n* Collection of signed inputs\n*/\nexport class Inputs {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Inputs.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_inputs_free(ptr);\n    }\n    /**\n    * Create empty Inputs\n    */\n    constructor() {\n        var ret = wasm.inputs_new();\n        return Inputs.__wrap(ret);\n    }\n    /**\n    * Returns the number of elements in the collection\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.inputs_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Returns the element of the collection with a given index\n    * @param {number} index\n    * @returns {Input}\n    */\n    get(index) {\n        var ret = wasm.inputs_get(this.ptr, index);\n        return Input.__wrap(ret);\n    }\n}\n/**\n* A level node in a merkle proof\n*/\nexport class LevelNode {\n\n    static __wrap(ptr) {\n        const obj = Object.create(LevelNode.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_levelnode_free(ptr);\n    }\n    /**\n    * Creates a new LevelNode from a 32 byte hash and side that the node belongs on in the tree. Fails if the digest is not 32 bytes\n    * @param {Uint8Array} hash\n    * @param {number} side\n    * @returns {LevelNode}\n    */\n    static new(hash, side) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passArray8ToWasm0(hash, wasm.__wbindgen_malloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.levelnode_new(retptr, ptr0, len0, side);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return LevelNode.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Returns the associated digest (hash) with this node. Returns an empty array if there's no hash\n    * @returns {Uint8Array}\n    */\n    get digest() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.levelnode_digest(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Returns the associated side with this node (0 = Left, 1 = Right)\n    * @returns {number}\n    */\n    get side() {\n        var ret = wasm.levelnode_side(this.ptr);\n        return ret;\n    }\n}\n/**\n* A MerkleProof type. Given leaf data and levels (bottom-upwards), the root hash can be computed and validated\n*/\nexport class MerkleProof {\n\n    static __wrap(ptr) {\n        const obj = Object.create(MerkleProof.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_merkleproof_free(ptr);\n    }\n    /**\n    * Creates a new merkle proof with given leaf data and level data (bottom-upwards)\n    * You can verify it against a Blakeb256 root hash by using [`Self::valid()`]\n    * Add a node by using [`Self::add_node()`]\n    * Each digest on the level must be exactly 32 bytes\n    * @param {Uint8Array} leaf_data\n    * @returns {MerkleProof}\n    */\n    static new(leaf_data) {\n        var ptr0 = passArray8ToWasm0(leaf_data, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.merkleproof_new(ptr0, len0);\n        return MerkleProof.__wrap(ret);\n    }\n    /**\n    * Adds a new node to the MerkleProof above the current nodes\n    * @param {LevelNode} level\n    */\n    add_node(level) {\n        _assertClass(level, LevelNode);\n        wasm.merkleproof_add_node(this.ptr, level.ptr);\n    }\n    /**\n    * Validates the Merkle proof against the root hash\n    * @param {Uint8Array} expected_root\n    * @returns {boolean}\n    */\n    valid(expected_root) {\n        var ptr0 = passArray8ToWasm0(expected_root, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.merkleproof_valid(this.ptr, ptr0, len0);\n        return ret !== 0;\n    }\n}\n/**\n* helper methods to get the fee address for various networks\n*/\nexport class MinerAddress {\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_mineraddress_free(ptr);\n    }\n    /**\n    * address to use in mainnet for the fee\n    * @returns {string}\n    */\n    static mainnet_fee_address() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.mineraddress_mainnet_fee_address(retptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * address to use in testnet for the fee\n    * @returns {string}\n    */\n    static testnet_fee_address() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.mineraddress_testnet_fee_address(retptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n}\n/**\n* Mnemonic\n*/\nexport class Mnemonic {\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_mnemonic_free(ptr);\n    }\n    /**\n    * Convert a mnemonic phrase into a mnemonic seed\n    * mnemonic_pass is optional and is used to salt the seed\n    * @param {string} mnemonic_phrase\n    * @param {string} mnemonic_pass\n    * @returns {Uint8Array}\n    */\n    static to_seed(mnemonic_phrase, mnemonic_pass) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(mnemonic_phrase, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            var ptr1 = passStringToWasm0(mnemonic_pass, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len1 = WASM_VECTOR_LEN;\n            wasm.mnemonic_to_seed(retptr, ptr0, len0, ptr1, len1);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v2 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v2;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n* Combination of an Address with a network\n* These two combined together form a base58 encoding\n*/\nexport class NetworkAddress {\n\n    static __wrap(ptr) {\n        const obj = Object.create(NetworkAddress.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_networkaddress_free(ptr);\n    }\n    /**\n    * create a new NetworkAddress(address + network prefix) for a given network type\n    * @param {number} network\n    * @param {Address} address\n    * @returns {NetworkAddress}\n    */\n    static new(network, address) {\n        _assertClass(address, Address);\n        var ret = wasm.networkaddress_new(network, address.ptr);\n        return NetworkAddress.__wrap(ret);\n    }\n    /**\n    * Decode (base58) a NetworkAddress (address + network prefix) from string\n    * @param {string} s\n    * @returns {NetworkAddress}\n    */\n    static from_base58(s) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(s, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.networkaddress_from_base58(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return NetworkAddress.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Encode (base58) address\n    * @returns {string}\n    */\n    to_base58() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.networkaddress_to_base58(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * Decode from a serialized address\n    * @param {Uint8Array} data\n    * @returns {NetworkAddress}\n    */\n    static from_bytes(data) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passArray8ToWasm0(data, wasm.__wbindgen_malloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.networkaddress_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return NetworkAddress.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Encode address as serialized bytes\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.networkaddress_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Network for the address\n    * @returns {number}\n    */\n    network() {\n        var ret = wasm.networkaddress_network(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Get address without network information\n    * @returns {Address}\n    */\n    address() {\n        var ret = wasm.networkaddress_address(this.ptr);\n        return Address.__wrap(ret);\n    }\n}\n/**\n* A structure representing NiPoPow proof.\n*/\nexport class NipopowProof {\n\n    static __wrap(ptr) {\n        const obj = Object.create(NipopowProof.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_nipopowproof_free(ptr);\n    }\n}\n/**\n* A verifier for PoPoW proofs. During its lifetime, it processes many proofs with the aim of\n* deducing at any given point what is the best (sub)chain rooted at the specified genesis.\n*/\nexport class NipopowVerifier {\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_nipopowverifier_free(ptr);\n    }\n}\n/**\n* Node configuration\n*/\nexport class NodeConf {\n\n    static __wrap(ptr) {\n        const obj = Object.create(NodeConf.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_nodeconf_free(ptr);\n    }\n    /**\n    * Create a node configuration\n    * addr - a string in a format 'ip_address:port'\n    * @param {string} addr\n    */\n    constructor(addr) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(addr, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.nodeconf_new(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return NodeConf.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n* List of peer urls returned from `peer_discovery`. We need this wrapper struct because the\n* `wasm_bindgen` macro currently cannot deal with `Result<Box<[T]>, JsValue>`, for any value `T`\n* that can be converted into a `JsValue` (`Result<Box<[web_sys::Url]>, JsValue>` would be a\n* convenient return type for `peer_discovery`).\n*/\nexport class PeerUrls {\n\n    static __wrap(ptr) {\n        const obj = Object.create(PeerUrls.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_peerurls_free(ptr);\n    }\n    /**\n    * Returns the number of elements in the collection\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.peerurls_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Returns the element of the collection with a given index\n    * @param {number} index\n    * @returns {URL}\n    */\n    get(index) {\n        var ret = wasm.peerurls_get(this.ptr, index);\n        return takeObject(ret);\n    }\n}\n/**\n* PoPowHeader structure. Represents the block header and unpacked interlinks\n*/\nexport class PoPowHeader {\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_popowheader_free(ptr);\n    }\n    /**\n    * Returns block header\n    * @returns {BlockHeader}\n    */\n    header() {\n        var ret = wasm.popowheader_header(this.ptr);\n        return BlockHeader.__wrap(ret);\n    }\n    /**\n    * Returns interlinks for PoPowHeader\n    * @returns {any}\n    */\n    interlinks() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.popowheader_interlinks(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Returns interlinks proof [`crate::batchmerkleproof::BatchMerkleProof`]\n    * @returns {BatchMerkleProof}\n    */\n    interlinks_proof() {\n        var ret = wasm.popowheader_interlinks_proof(this.ptr);\n        return BatchMerkleProof.__wrap(ret);\n    }\n    /**\n    * Validates interlinks merkle root with compact merkle multiproof. See [`PoPowHeader::interlinks_proof`] for BatchMerkleProof access\n    * @returns {boolean}\n    */\n    check_interlinks_proof() {\n        var ret = wasm.popowheader_check_interlinks_proof(this.ptr);\n        return ret !== 0;\n    }\n    /**\n    * Returns block height for Header\n    * @returns {number}\n    */\n    height() {\n        var ret = wasm.popowheader_height(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Returns Block ID for Header\n    * @returns {BlockId}\n    */\n    id() {\n        var ret = wasm.popowheader_id(this.ptr);\n        return BlockId.__wrap(ret);\n    }\n}\n/**\n* Block header with the current `spendingTransaction`, that can be predicted\n* by a miner before it's formation\n*/\nexport class PreHeader {\n\n    static __wrap(ptr) {\n        const obj = Object.create(PreHeader.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_preheader_free(ptr);\n    }\n    /**\n    * Create using data from block header\n    * @param {BlockHeader} block_header\n    * @returns {PreHeader}\n    */\n    static from_block_header(block_header) {\n        _assertClass(block_header, BlockHeader);\n        var ptr0 = block_header.ptr;\n        block_header.ptr = 0;\n        var ret = wasm.preheader_from_block_header(ptr0);\n        return PreHeader.__wrap(ret);\n    }\n}\n/**\n* Propositions list(public keys)\n*/\nexport class Propositions {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Propositions.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_propositions_free(ptr);\n    }\n    /**\n    * Create empty proposition holder\n    */\n    constructor() {\n        var ret = wasm.propositions_new();\n        return Propositions.__wrap(ret);\n    }\n    /**\n    * Adding new proposition\n    * @param {Uint8Array} proposition\n    */\n    add_proposition_from_byte(proposition) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passArray8ToWasm0(proposition, wasm.__wbindgen_malloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.propositions_add_proposition_from_byte(retptr, this.ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n* Proof of correctness of tx spending\n*/\nexport class ProverResult {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ProverResult.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_proverresult_free(ptr);\n    }\n    /**\n    * Get proof\n    * @returns {Uint8Array}\n    */\n    proof() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.proverresult_proof(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Get extension\n    * @returns {ContextExtension}\n    */\n    extension() {\n        var ret = wasm.proverresult_extension(this.ptr);\n        return ContextExtension.__wrap(ret);\n    }\n    /**\n    * JSON representation as text (compatible with Ergo Node/Explorer API, numbers are encoded as numbers)\n    * @returns {string}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.proverresult_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr0 = r0;\n            var len0 = r1;\n            if (r3) {\n                ptr0 = 0; len0 = 0;\n                throw takeObject(r2);\n            }\n            return getStringFromWasm0(ptr0, len0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(ptr0, len0);\n        }\n    }\n}\n/**\n* Represent `reduced` transaction, i.e. unsigned transaction where each unsigned input\n* is augmented with ReducedInput which contains a script reduction result.\n* After an unsigned transaction is reduced it can be signed without context.\n* Thus, it can be serialized and transferred for example to Cold Wallet and signed\n* in an environment where secrets are known.\n* see EIP-19 for more details -\n* <https://github.com/ergoplatform/eips/blob/f280890a4163f2f2e988a0091c078e36912fc531/eip-0019.md>\n*/\nexport class ReducedTransaction {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ReducedTransaction.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_reducedtransaction_free(ptr);\n    }\n    /**\n    * Returns `reduced` transaction, i.e. unsigned transaction where each unsigned input\n    * is augmented with ReducedInput which contains a script reduction result.\n    * @param {UnsignedTransaction} unsigned_tx\n    * @param {ErgoBoxes} boxes_to_spend\n    * @param {ErgoBoxes} data_boxes\n    * @param {ErgoStateContext} state_context\n    * @returns {ReducedTransaction}\n    */\n    static from_unsigned_tx(unsigned_tx, boxes_to_spend, data_boxes, state_context) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(unsigned_tx, UnsignedTransaction);\n            _assertClass(boxes_to_spend, ErgoBoxes);\n            _assertClass(data_boxes, ErgoBoxes);\n            _assertClass(state_context, ErgoStateContext);\n            wasm.reducedtransaction_from_unsigned_tx(retptr, unsigned_tx.ptr, boxes_to_spend.ptr, data_boxes.ptr, state_context.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ReducedTransaction.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Returns serialized bytes or fails with error if cannot be serialized\n    * @returns {Uint8Array}\n    */\n    sigma_serialize_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.reducedtransaction_sigma_serialize_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            if (r3) {\n                throw takeObject(r2);\n            }\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Parses ReducedTransaction or fails with error\n    * @param {Uint8Array} data\n    * @returns {ReducedTransaction}\n    */\n    static sigma_parse_bytes(data) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passArray8ToWasm0(data, wasm.__wbindgen_malloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.reducedtransaction_sigma_parse_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ReducedTransaction.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Returns the unsigned transaction\n    * @returns {UnsignedTransaction}\n    */\n    unsigned_tx() {\n        var ret = wasm.reducedtransaction_unsigned_tx(this.ptr);\n        return UnsignedTransaction.__wrap(ret);\n    }\n}\n/**\n* Secret key for the prover\n*/\nexport class SecretKey {\n\n    static __wrap(ptr) {\n        const obj = Object.create(SecretKey.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_secretkey_free(ptr);\n    }\n    /**\n    * generate random key\n    * @returns {SecretKey}\n    */\n    static random_dlog() {\n        var ret = wasm.secretkey_random_dlog();\n        return SecretKey.__wrap(ret);\n    }\n    /**\n    * Parse dlog secret key from bytes (SEC-1-encoded scalar)\n    * @param {Uint8Array} bytes\n    * @returns {SecretKey}\n    */\n    static dlog_from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.secretkey_dlog_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return SecretKey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Address (encoded public image)\n    * @returns {Address}\n    */\n    get_address() {\n        var ret = wasm.secretkey_get_address(this.ptr);\n        return Address.__wrap(ret);\n    }\n    /**\n    * Encode from a serialized key\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.secretkey_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n* SecretKey collection\n*/\nexport class SecretKeys {\n\n    static __wrap(ptr) {\n        const obj = Object.create(SecretKeys.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_secretkeys_free(ptr);\n    }\n    /**\n    * Create empty SecretKeys\n    */\n    constructor() {\n        var ret = wasm.secretkeys_new();\n        return SecretKeys.__wrap(ret);\n    }\n    /**\n    * Returns the number of elements in the collection\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.secretkeys_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Returns the element of the collection with a given index\n    * @param {number} index\n    * @returns {SecretKey}\n    */\n    get(index) {\n        var ret = wasm.secretkeys_get(this.ptr, index);\n        return SecretKey.__wrap(ret);\n    }\n    /**\n    * Adds an elements to the collection\n    * @param {SecretKey} elem\n    */\n    add(elem) {\n        _assertClass(elem, SecretKey);\n        wasm.secretkeys_add(this.ptr, elem.ptr);\n    }\n}\n/**\n* Naive box selector, collects inputs until target balance is reached\n*/\nexport class SimpleBoxSelector {\n\n    static __wrap(ptr) {\n        const obj = Object.create(SimpleBoxSelector.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_simpleboxselector_free(ptr);\n    }\n    /**\n    * Create empty SimpleBoxSelector\n    */\n    constructor() {\n        var ret = wasm.simpleboxselector_new();\n        return SimpleBoxSelector.__wrap(ret);\n    }\n    /**\n    * Selects inputs to satisfy target balance and tokens.\n    * `inputs` - available inputs (returns an error, if empty),\n    * `target_balance` - coins (in nanoERGs) needed,\n    * `target_tokens` - amount of tokens needed.\n    * Returns selected inputs and box assets(value+tokens) with change.\n    * @param {ErgoBoxes} inputs\n    * @param {BoxValue} target_balance\n    * @param {Tokens} target_tokens\n    * @returns {BoxSelection}\n    */\n    select(inputs, target_balance, target_tokens) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(inputs, ErgoBoxes);\n            _assertClass(target_balance, BoxValue);\n            _assertClass(target_tokens, Tokens);\n            wasm.simpleboxselector_select(retptr, this.ptr, inputs.ptr, target_balance.ptr, target_tokens.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return BoxSelection.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n* Token represented with token id paired with it's amount\n*/\nexport class Token {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Token.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_token_free(ptr);\n    }\n    /**\n    * Create a token with given token id and amount\n    * @param {TokenId} token_id\n    * @param {TokenAmount} amount\n    */\n    constructor(token_id, amount) {\n        _assertClass(token_id, TokenId);\n        _assertClass(amount, TokenAmount);\n        var ret = wasm.token_new(token_id.ptr, amount.ptr);\n        return Token.__wrap(ret);\n    }\n    /**\n    * Get token id\n    * @returns {TokenId}\n    */\n    id() {\n        var ret = wasm.token_id(this.ptr);\n        return TokenId.__wrap(ret);\n    }\n    /**\n    * Get token amount\n    * @returns {TokenAmount}\n    */\n    amount() {\n        var ret = wasm.token_amount(this.ptr);\n        return TokenAmount.__wrap(ret);\n    }\n    /**\n    * JSON representation as text (compatible with Ergo Node/Explorer API, numbers are encoded as numbers)\n    * @returns {string}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.token_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr0 = r0;\n            var len0 = r1;\n            if (r3) {\n                ptr0 = 0; len0 = 0;\n                throw takeObject(r2);\n            }\n            return getStringFromWasm0(ptr0, len0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(ptr0, len0);\n        }\n    }\n    /**\n    * JSON representation according to EIP-12 <https://github.com/ergoplatform/eips/pull/23>\n    * (similar to [`Self::to_json`], but as JS object with token amount encoding as string)\n    * @returns {any}\n    */\n    to_js_eip12() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.token_to_js_eip12(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n* Token amount with bound checks\n*/\nexport class TokenAmount {\n\n    static __wrap(ptr) {\n        const obj = Object.create(TokenAmount.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_tokenamount_free(ptr);\n    }\n    /**\n    * Create from i64 with bounds check\n    * @param {I64} v\n    * @returns {TokenAmount}\n    */\n    static from_i64(v) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(v, I64);\n            wasm.tokenamount_from_i64(retptr, v.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TokenAmount.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Get value as signed 64-bit long (I64)\n    * @returns {I64}\n    */\n    as_i64() {\n        var ret = wasm.tokenamount_as_i64(this.ptr);\n        return I64.__wrap(ret);\n    }\n    /**\n    * big-endian byte array representation\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.tokenamount_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n* Token id (32 byte digest)\n*/\nexport class TokenId {\n\n    static __wrap(ptr) {\n        const obj = Object.create(TokenId.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_tokenid_free(ptr);\n    }\n    /**\n    * Create token id from ergo box id (32 byte digest)\n    * @param {BoxId} box_id\n    * @returns {TokenId}\n    */\n    static from_box_id(box_id) {\n        _assertClass(box_id, BoxId);\n        var ret = wasm.tokenid_from_box_id(box_id.ptr);\n        return TokenId.__wrap(ret);\n    }\n    /**\n    * Parse token id (32 byte digest) from base16-encoded string\n    * @param {string} str\n    * @returns {TokenId}\n    */\n    static from_str(str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.tokenid_from_str(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TokenId.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Base16 encoded string\n    * @returns {string}\n    */\n    to_str() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.tokenid_to_str(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * Returns byte array (32 bytes)\n    * @returns {Uint8Array}\n    */\n    as_bytes() {\n        var ret = wasm.tokenid_as_bytes(this.ptr);\n        return takeObject(ret);\n    }\n}\n/**\n* Array of tokens\n*/\nexport class Tokens {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Tokens.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_tokens_free(ptr);\n    }\n    /**\n    * Create empty Tokens\n    */\n    constructor() {\n        var ret = wasm.tokens_new();\n        return Tokens.__wrap(ret);\n    }\n    /**\n    * Returns the number of elements in the collection\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.tokens_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Returns the element of the collection with a given index\n    * @param {number} index\n    * @returns {Token}\n    */\n    get(index) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.tokens_get(retptr, this.ptr, index);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Token.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Adds an elements to the collection\n    * @param {Token} elem\n    */\n    add(elem) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(elem, Token);\n            wasm.tokens_add(retptr, this.ptr, elem.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*\n* * ErgoTransaction is an atomic state transition operation. It destroys Boxes from the state\n* * and creates new ones. If transaction is spending boxes protected by some non-trivial scripts,\n* * its inputs should also contain proof of spending correctness - context extension (user-defined\n* * key-value map) and data inputs (links to existing boxes in the state) that may be used during\n* * script reduction to crypto, signatures that satisfies the remaining cryptographic protection\n* * of the script.\n* * Transactions are not encrypted, so it is possible to browse and view every transaction ever\n* * collected into a block.\n*\n*/\nexport class Transaction {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Transaction.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transaction_free(ptr);\n    }\n    /**\n    * Create Transaction from UnsignedTransaction and an array of proofs in the same order as\n    * UnsignedTransaction.inputs with empty proof indicated with empty byte array\n    * @param {UnsignedTransaction} unsigned_tx\n    * @param {(Uint8Array)[]} proofs\n    * @returns {Transaction}\n    */\n    static from_unsigned_tx(unsigned_tx, proofs) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(unsigned_tx, UnsignedTransaction);\n            var ptr0 = unsigned_tx.ptr;\n            unsigned_tx.ptr = 0;\n            var ptr1 = passArrayJsValueToWasm0(proofs, wasm.__wbindgen_malloc);\n            var len1 = WASM_VECTOR_LEN;\n            wasm.transaction_from_unsigned_tx(retptr, ptr0, ptr1, len1);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Transaction.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Get id for transaction\n    * @returns {TxId}\n    */\n    id() {\n        var ret = wasm.transaction_id(this.ptr);\n        return TxId.__wrap(ret);\n    }\n    /**\n    * JSON representation as text (compatible with Ergo Node/Explorer API, numbers are encoded as numbers)\n    * @returns {string}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transaction_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr0 = r0;\n            var len0 = r1;\n            if (r3) {\n                ptr0 = 0; len0 = 0;\n                throw takeObject(r2);\n            }\n            return getStringFromWasm0(ptr0, len0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(ptr0, len0);\n        }\n    }\n    /**\n    * JSON representation according to EIP-12 <https://github.com/ergoplatform/eips/pull/23>\n    * (similar to [`Self::to_json`], but as JS object with box value and token amount encoding as strings)\n    * @returns {any}\n    */\n    to_js_eip12() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transaction_to_js_eip12(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * parse from JSON\n    * supports Ergo Node/Explorer API and box values and token amount encoded as strings\n    * @param {string} json\n    * @returns {Transaction}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.transaction_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Transaction.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Inputs for transaction\n    * @returns {Inputs}\n    */\n    inputs() {\n        var ret = wasm.transaction_inputs(this.ptr);\n        return Inputs.__wrap(ret);\n    }\n    /**\n    * Data inputs for transaction\n    * @returns {DataInputs}\n    */\n    data_inputs() {\n        var ret = wasm.transaction_data_inputs(this.ptr);\n        return DataInputs.__wrap(ret);\n    }\n    /**\n    * Output candidates for transaction\n    * @returns {ErgoBoxCandidates}\n    */\n    output_candidates() {\n        var ret = wasm.transaction_output_candidates(this.ptr);\n        return ErgoBoxCandidates.__wrap(ret);\n    }\n    /**\n    * Returns ErgoBox's created from ErgoBoxCandidate's with tx id and indices\n    * @returns {ErgoBoxes}\n    */\n    outputs() {\n        var ret = wasm.transaction_outputs(this.ptr);\n        return ErgoBoxes.__wrap(ret);\n    }\n    /**\n    * Returns serialized bytes or fails with error if cannot be serialized\n    * @returns {Uint8Array}\n    */\n    sigma_serialize_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transaction_sigma_serialize_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            if (r3) {\n                throw takeObject(r2);\n            }\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Parses Transaction or fails with error\n    * @param {Uint8Array} data\n    * @returns {Transaction}\n    */\n    static sigma_parse_bytes(data) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passArray8ToWasm0(data, wasm.__wbindgen_malloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.transaction_sigma_parse_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Transaction.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n* TransactionHintsBag\n*/\nexport class TransactionHintsBag {\n\n    static __wrap(ptr) {\n        const obj = Object.create(TransactionHintsBag.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transactionhintsbag_free(ptr);\n    }\n    /**\n    * Empty TransactionHintsBag\n    * @returns {TransactionHintsBag}\n    */\n    static empty() {\n        var ret = wasm.transactionhintsbag_empty();\n        return TransactionHintsBag.__wrap(ret);\n    }\n    /**\n    * Adding hints for input\n    * @param {number} index\n    * @param {HintsBag} hints_bag\n    */\n    add_hints_for_input(index, hints_bag) {\n        _assertClass(hints_bag, HintsBag);\n        wasm.transactionhintsbag_add_hints_for_input(this.ptr, index, hints_bag.ptr);\n    }\n    /**\n    * Outputting HintsBag corresponding for an input index\n    * @param {number} index\n    * @returns {HintsBag}\n    */\n    all_hints_for_input(index) {\n        var ret = wasm.transactionhintsbag_all_hints_for_input(this.ptr, index);\n        return HintsBag.__wrap(ret);\n    }\n    /**\n    * Return JSON object (node format)\n    * @returns {any}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionhintsbag_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Parse from JSON object (node format)\n    * @param {string} json\n    * @returns {TransactionHintsBag}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.transactionhintsbag_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TransactionHintsBag.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n* Unsigned transaction builder\n*/\nexport class TxBuilder {\n\n    static __wrap(ptr) {\n        const obj = Object.create(TxBuilder.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_txbuilder_free(ptr);\n    }\n    /**\n    * Suggested transaction fee (semi-default value used across wallets and dApps as of Oct 2020)\n    * @returns {BoxValue}\n    */\n    static SUGGESTED_TX_FEE() {\n        var ret = wasm.txbuilder_SUGGESTED_TX_FEE();\n        return BoxValue.__wrap(ret);\n    }\n    /**\n    * Creates new TxBuilder\n    * `box_selection` - selected input boxes (via [`super::box_selector`])\n    * `output_candidates` - output boxes to be \"created\" in this transaction,\n    * `current_height` - chain height that will be used in additionally created boxes (change, miner's fee, etc.),\n    * `fee_amount` - miner's fee,\n    * `change_address` - change (inputs - outputs) will be sent to this address,\n    * `min_change_value` - minimal value of the change to be sent to `change_address`, value less than that\n    * will be given to miners,\n    * @param {BoxSelection} box_selection\n    * @param {ErgoBoxCandidates} output_candidates\n    * @param {number} current_height\n    * @param {BoxValue} fee_amount\n    * @param {Address} change_address\n    * @param {BoxValue} min_change_value\n    * @returns {TxBuilder}\n    */\n    static new(box_selection, output_candidates, current_height, fee_amount, change_address, min_change_value) {\n        _assertClass(box_selection, BoxSelection);\n        _assertClass(output_candidates, ErgoBoxCandidates);\n        _assertClass(fee_amount, BoxValue);\n        _assertClass(change_address, Address);\n        _assertClass(min_change_value, BoxValue);\n        var ret = wasm.txbuilder_new(box_selection.ptr, output_candidates.ptr, current_height, fee_amount.ptr, change_address.ptr, min_change_value.ptr);\n        return TxBuilder.__wrap(ret);\n    }\n    /**\n    * Set transaction's data inputs\n    * @param {DataInputs} data_inputs\n    */\n    set_data_inputs(data_inputs) {\n        _assertClass(data_inputs, DataInputs);\n        wasm.txbuilder_set_data_inputs(this.ptr, data_inputs.ptr);\n    }\n    /**\n    * Set context extension for a given input\n    * @param {BoxId} box_id\n    * @param {ContextExtension} context_extension\n    */\n    set_context_extension(box_id, context_extension) {\n        _assertClass(box_id, BoxId);\n        _assertClass(context_extension, ContextExtension);\n        wasm.txbuilder_set_context_extension(this.ptr, box_id.ptr, context_extension.ptr);\n    }\n    /**\n    * Build the unsigned transaction\n    * @returns {UnsignedTransaction}\n    */\n    build() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.txbuilder_build(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return UnsignedTransaction.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Get box selection\n    * @returns {BoxSelection}\n    */\n    box_selection() {\n        var ret = wasm.txbuilder_box_selection(this.ptr);\n        return BoxSelection.__wrap(ret);\n    }\n    /**\n    * Get data inputs\n    * @returns {DataInputs}\n    */\n    data_inputs() {\n        var ret = wasm.txbuilder_data_inputs(this.ptr);\n        return DataInputs.__wrap(ret);\n    }\n    /**\n    * Get outputs EXCLUDING fee and change\n    * @returns {ErgoBoxCandidates}\n    */\n    output_candidates() {\n        var ret = wasm.txbuilder_output_candidates(this.ptr);\n        return ErgoBoxCandidates.__wrap(ret);\n    }\n    /**\n    * Get current height\n    * @returns {number}\n    */\n    current_height() {\n        var ret = wasm.txbuilder_current_height(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Get fee amount\n    * @returns {BoxValue}\n    */\n    fee_amount() {\n        var ret = wasm.txbuilder_fee_amount(this.ptr);\n        return BoxValue.__wrap(ret);\n    }\n    /**\n    * Get change address\n    * @returns {Address}\n    */\n    change_address() {\n        var ret = wasm.txbuilder_change_address(this.ptr);\n        return Address.__wrap(ret);\n    }\n    /**\n    * Get min change value\n    * @returns {BoxValue}\n    */\n    min_change_value() {\n        var ret = wasm.txbuilder_min_change_value(this.ptr);\n        return BoxValue.__wrap(ret);\n    }\n}\n/**\n* Transaction id\n*/\nexport class TxId {\n\n    static __wrap(ptr) {\n        const obj = Object.create(TxId.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_txid_free(ptr);\n    }\n    /**\n    * Zero (empty) transaction id (to use as dummy value in tests)\n    * @returns {TxId}\n    */\n    static zero() {\n        var ret = wasm.txid_zero();\n        return TxId.__wrap(ret);\n    }\n    /**\n    * get the tx id as bytes\n    * @returns {string}\n    */\n    to_str() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.txid_to_str(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * convert a hex string into a TxId\n    * @param {string} s\n    * @returns {TxId}\n    */\n    static from_str(s) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(s, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.txid_from_str(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TxId.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n* Unsigned inputs used in constructing unsigned transactions\n*/\nexport class UnsignedInput {\n\n    static __wrap(ptr) {\n        const obj = Object.create(UnsignedInput.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_unsignedinput_free(ptr);\n    }\n    /**\n    * Create new unsigned input instance from box id and extension\n    * @param {BoxId} box_id\n    * @param {ContextExtension} ext\n    */\n    constructor(box_id, ext) {\n        _assertClass(box_id, BoxId);\n        _assertClass(ext, ContextExtension);\n        var ret = wasm.unsignedinput_new(box_id.ptr, ext.ptr);\n        return UnsignedInput.__wrap(ret);\n    }\n    /**\n    * Create a new unsigned input from the provided box id\n    * using an empty context extension\n    * @param {BoxId} box_id\n    * @returns {UnsignedInput}\n    */\n    static from_box_id(box_id) {\n        _assertClass(box_id, BoxId);\n        var ret = wasm.unsignedinput_from_box_id(box_id.ptr);\n        return UnsignedInput.__wrap(ret);\n    }\n    /**\n    * Get box id\n    * @returns {BoxId}\n    */\n    box_id() {\n        var ret = wasm.unsignedinput_box_id(this.ptr);\n        return BoxId.__wrap(ret);\n    }\n    /**\n    * Get extension\n    * @returns {ContextExtension}\n    */\n    extension() {\n        var ret = wasm.unsignedinput_extension(this.ptr);\n        return ContextExtension.__wrap(ret);\n    }\n}\n/**\n* Collection of unsigned signed inputs\n*/\nexport class UnsignedInputs {\n\n    static __wrap(ptr) {\n        const obj = Object.create(UnsignedInputs.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_unsignedinputs_free(ptr);\n    }\n    /**\n    * Create empty UnsignedInputs\n    */\n    constructor() {\n        var ret = wasm.unsignedinputs_new();\n        return UnsignedInputs.__wrap(ret);\n    }\n    /**\n    * Returns the number of elements in the collection\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.unsignedinputs_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Returns the element of the collection with a given index\n    * @param {number} index\n    * @returns {UnsignedInput}\n    */\n    get(index) {\n        var ret = wasm.unsignedinputs_get(this.ptr, index);\n        return UnsignedInput.__wrap(ret);\n    }\n    /**\n    * Add an element to the collection\n    * @param {UnsignedInput} b\n    */\n    add(b) {\n        _assertClass(b, UnsignedInput);\n        wasm.unsignedinputs_add(this.ptr, b.ptr);\n    }\n}\n/**\n* Unsigned (inputs without proofs) transaction\n*/\nexport class UnsignedTransaction {\n\n    static __wrap(ptr) {\n        const obj = Object.create(UnsignedTransaction.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_unsignedtransaction_free(ptr);\n    }\n    /**\n    * Create a new unsigned transaction\n    * @param {UnsignedInputs} inputs\n    * @param {DataInputs} data_inputs\n    * @param {ErgoBoxCandidates} output_candidates\n    */\n    constructor(inputs, data_inputs, output_candidates) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(inputs, UnsignedInputs);\n            _assertClass(data_inputs, DataInputs);\n            _assertClass(output_candidates, ErgoBoxCandidates);\n            wasm.unsignedtransaction_new(retptr, inputs.ptr, data_inputs.ptr, output_candidates.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return UnsignedTransaction.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Consumes the calling UnsignedTransaction and returns a new UnsignedTransaction containing\n    * the ContextExtension in the provided input box id or returns an error if the input box cannot be found.\n    * After the call the calling UnsignedTransaction will be null.\n    * @param {BoxId} input_id\n    * @param {ContextExtension} ext\n    * @returns {UnsignedTransaction}\n    */\n    with_input_context_ext(input_id, ext) {\n        try {\n            const ptr = this.__destroy_into_raw();\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(input_id, BoxId);\n            _assertClass(ext, ContextExtension);\n            wasm.unsignedtransaction_with_input_context_ext(retptr, ptr, input_id.ptr, ext.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return UnsignedTransaction.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Get id for transaction\n    * @returns {TxId}\n    */\n    id() {\n        var ret = wasm.unsignedtransaction_id(this.ptr);\n        return TxId.__wrap(ret);\n    }\n    /**\n    * Inputs for transaction\n    * @returns {UnsignedInputs}\n    */\n    inputs() {\n        var ret = wasm.unsignedtransaction_inputs(this.ptr);\n        return UnsignedInputs.__wrap(ret);\n    }\n    /**\n    * Data inputs for transaction\n    * @returns {DataInputs}\n    */\n    data_inputs() {\n        var ret = wasm.unsignedtransaction_data_inputs(this.ptr);\n        return DataInputs.__wrap(ret);\n    }\n    /**\n    * Output candidates for transaction\n    * @returns {ErgoBoxCandidates}\n    */\n    output_candidates() {\n        var ret = wasm.unsignedtransaction_output_candidates(this.ptr);\n        return ErgoBoxCandidates.__wrap(ret);\n    }\n    /**\n    * JSON representation as text (compatible with Ergo Node/Explorer API, numbers are encoded as numbers)\n    * @returns {string}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.unsignedtransaction_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr0 = r0;\n            var len0 = r1;\n            if (r3) {\n                ptr0 = 0; len0 = 0;\n                throw takeObject(r2);\n            }\n            return getStringFromWasm0(ptr0, len0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(ptr0, len0);\n        }\n    }\n    /**\n    * JSON representation according to EIP-12 <https://github.com/ergoplatform/eips/pull/23>\n    * (similar to [`Self::to_json`], but as JS object with box value and token amount encoding as strings)\n    * @returns {any}\n    */\n    to_js_eip12() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.unsignedtransaction_to_js_eip12(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * parse from JSON\n    * supports Ergo Node/Explorer API and box values and token amount encoded as strings\n    * @param {string} json\n    * @returns {UnsignedTransaction}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.unsignedtransaction_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return UnsignedTransaction.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Returns distinct token id from output_candidates as array of byte arrays\n    * @returns {(Uint8Array)[]}\n    */\n    distinct_token_ids() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.unsignedtransaction_distinct_token_ids(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 4);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n* A collection of secret keys. This simplified signing by matching the secret keys to the correct inputs automatically.\n*/\nexport class Wallet {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Wallet.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_wallet_free(ptr);\n    }\n    /**\n    * Create wallet instance loading secret key from mnemonic\n    * Returns None if a DlogSecretKey cannot be parsed from the provided phrase\n    * @param {string} mnemonic_phrase\n    * @param {string} mnemonic_pass\n    * @returns {Wallet | undefined}\n    */\n    static from_mnemonic(mnemonic_phrase, mnemonic_pass) {\n        var ptr0 = passStringToWasm0(mnemonic_phrase, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ptr1 = passStringToWasm0(mnemonic_pass, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len1 = WASM_VECTOR_LEN;\n        var ret = wasm.wallet_from_mnemonic(ptr0, len0, ptr1, len1);\n        return ret === 0 ? undefined : Wallet.__wrap(ret);\n    }\n    /**\n    * Create wallet using provided secret key\n    * @param {SecretKeys} secret\n    * @returns {Wallet}\n    */\n    static from_secrets(secret) {\n        _assertClass(secret, SecretKeys);\n        var ret = wasm.wallet_from_secrets(secret.ptr);\n        return Wallet.__wrap(ret);\n    }\n    /**\n    * Add a secret to the wallets prover\n    * @param {SecretKey} secret\n    */\n    add_secret(secret) {\n        _assertClass(secret, SecretKey);\n        wasm.wallet_add_secret(this.ptr, secret.ptr);\n    }\n    /**\n    * Sign a transaction:\n    * `tx` - transaction to sign\n    * `boxes_to_spend` - boxes corresponding to [`UnsignedTransaction::inputs`]\n    * `data_boxes` - boxes corresponding to [`UnsignedTransaction::data_inputs`]\n    * @param {ErgoStateContext} _state_context\n    * @param {UnsignedTransaction} tx\n    * @param {ErgoBoxes} boxes_to_spend\n    * @param {ErgoBoxes} data_boxes\n    * @returns {Transaction}\n    */\n    sign_transaction(_state_context, tx, boxes_to_spend, data_boxes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(_state_context, ErgoStateContext);\n            _assertClass(tx, UnsignedTransaction);\n            _assertClass(boxes_to_spend, ErgoBoxes);\n            _assertClass(data_boxes, ErgoBoxes);\n            wasm.wallet_sign_transaction(retptr, this.ptr, _state_context.ptr, tx.ptr, boxes_to_spend.ptr, data_boxes.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Transaction.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Sign a multi signature transaction:\n    * `tx` - transaction to sign\n    * `boxes_to_spend` - boxes corresponding to [`UnsignedTransaction::inputs`]\n    * `data_boxes` - boxes corresponding to [`UnsignedTransaction::data_inputs`]\n    * `tx_hints` - transaction hints bag corresponding to [`TransactionHintsBag`]\n    * @param {ErgoStateContext} _state_context\n    * @param {UnsignedTransaction} tx\n    * @param {ErgoBoxes} boxes_to_spend\n    * @param {ErgoBoxes} data_boxes\n    * @param {TransactionHintsBag} tx_hints\n    * @returns {Transaction}\n    */\n    sign_transaction_multi(_state_context, tx, boxes_to_spend, data_boxes, tx_hints) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(_state_context, ErgoStateContext);\n            _assertClass(tx, UnsignedTransaction);\n            _assertClass(boxes_to_spend, ErgoBoxes);\n            _assertClass(data_boxes, ErgoBoxes);\n            _assertClass(tx_hints, TransactionHintsBag);\n            wasm.wallet_sign_transaction_multi(retptr, this.ptr, _state_context.ptr, tx.ptr, boxes_to_spend.ptr, data_boxes.ptr, tx_hints.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Transaction.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Sign a transaction:\n    * `reduced_tx` - reduced transaction, i.e. unsigned transaction where for each unsigned input\n    * added a script reduction result.\n    * @param {ReducedTransaction} reduced_tx\n    * @returns {Transaction}\n    */\n    sign_reduced_transaction(reduced_tx) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(reduced_tx, ReducedTransaction);\n            wasm.wallet_sign_reduced_transaction(retptr, this.ptr, reduced_tx.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Transaction.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Sign a multi signature reduced transaction:\n    * `reduced_tx` - reduced transaction, i.e. unsigned transaction where for each unsigned input\n    * added a script reduction result.\n    * `tx_hints` - transaction hints bag corresponding to [`TransactionHintsBag`]\n    * @param {ReducedTransaction} reduced_tx\n    * @param {TransactionHintsBag} tx_hints\n    * @returns {Transaction}\n    */\n    sign_reduced_transaction_multi(reduced_tx, tx_hints) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(reduced_tx, ReducedTransaction);\n            _assertClass(tx_hints, TransactionHintsBag);\n            wasm.wallet_sign_reduced_transaction_multi(retptr, this.ptr, reduced_tx.ptr, tx_hints.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Transaction.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Generate Commitments for unsigned tx\n    * @param {ErgoStateContext} _state_context\n    * @param {UnsignedTransaction} tx\n    * @param {ErgoBoxes} boxes_to_spend\n    * @param {ErgoBoxes} data_boxes\n    * @returns {TransactionHintsBag}\n    */\n    generate_commitments(_state_context, tx, boxes_to_spend, data_boxes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(_state_context, ErgoStateContext);\n            _assertClass(tx, UnsignedTransaction);\n            _assertClass(boxes_to_spend, ErgoBoxes);\n            _assertClass(data_boxes, ErgoBoxes);\n            wasm.wallet_generate_commitments(retptr, this.ptr, _state_context.ptr, tx.ptr, boxes_to_spend.ptr, data_boxes.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TransactionHintsBag.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Generate Commitments for reduced Transaction\n    * @param {ReducedTransaction} reduced_tx\n    * @returns {TransactionHintsBag}\n    */\n    generate_commitments_for_reduced_transaction(reduced_tx) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(reduced_tx, ReducedTransaction);\n            wasm.wallet_generate_commitments_for_reduced_transaction(retptr, this.ptr, reduced_tx.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TransactionHintsBag.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Sign an arbitrary message using a P2PK address\n    * @param {Address} address\n    * @param {Uint8Array} message\n    * @returns {Uint8Array}\n    */\n    sign_message_using_p2pk(address, message) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(address, Address);\n            var ptr0 = passArray8ToWasm0(message, wasm.__wbindgen_malloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.wallet_sign_message_using_p2pk(retptr, this.ptr, address.ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n\nexport function __wbindgen_object_drop_ref(arg0) {\n    takeObject(arg0);\n};\n\nexport function __wbindgen_string_new(arg0, arg1) {\n    var ret = getStringFromWasm0(arg0, arg1);\n    return addHeapObject(ret);\n};\n\nexport function __wbg_peerurls_new(arg0) {\n    var ret = PeerUrls.__wrap(arg0);\n    return addHeapObject(ret);\n};\n\nexport function __wbg_nipopowproof_new(arg0) {\n    var ret = NipopowProof.__wrap(arg0);\n    return addHeapObject(ret);\n};\n\nexport function __wbindgen_is_string(arg0) {\n    var ret = typeof(getObject(arg0)) === 'string';\n    return ret;\n};\n\nexport function __wbindgen_string_get(arg0, arg1) {\n    const obj = getObject(arg1);\n    var ret = typeof(obj) === 'string' ? obj : undefined;\n    var ptr0 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    var len0 = WASM_VECTOR_LEN;\n    getInt32Memory0()[arg0 / 4 + 1] = len0;\n    getInt32Memory0()[arg0 / 4 + 0] = ptr0;\n};\n\nexport function __wbindgen_object_clone_ref(arg0) {\n    var ret = getObject(arg0);\n    return addHeapObject(ret);\n};\n\nexport function __wbindgen_json_parse(arg0, arg1) {\n    var ret = JSON.parse(getStringFromWasm0(arg0, arg1));\n    return addHeapObject(ret);\n};\n\nexport function __wbindgen_json_serialize(arg0, arg1) {\n    const obj = getObject(arg1);\n    var ret = JSON.stringify(obj === undefined ? null : obj);\n    var ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    var len0 = WASM_VECTOR_LEN;\n    getInt32Memory0()[arg0 / 4 + 1] = len0;\n    getInt32Memory0()[arg0 / 4 + 0] = ptr0;\n};\n\nexport function __wbindgen_error_new(arg0, arg1) {\n    var ret = new Error(getStringFromWasm0(arg0, arg1));\n    return addHeapObject(ret);\n};\n\nexport function __wbindgen_number_new(arg0) {\n    var ret = arg0;\n    return addHeapObject(ret);\n};\n\nexport function __wbg_fetch_bf9c65a3164e36df(arg0) {\n    var ret = fetch(getObject(arg0));\n    return addHeapObject(ret);\n};\n\nexport function __wbindgen_cb_drop(arg0) {\n    const obj = takeObject(arg0).original;\n    if (obj.cnt-- == 1) {\n        obj.a = 0;\n        return true;\n    }\n    var ret = false;\n    return ret;\n};\n\nexport function __wbg_instanceof_Window_434ce1849eb4e0fc(arg0) {\n    var ret = getObject(arg0) instanceof Window;\n    return ret;\n};\n\nexport function __wbg_performance_bbca4ccfaef860b2(arg0) {\n    var ret = getObject(arg0).performance;\n    return isLikeNone(ret) ? 0 : addHeapObject(ret);\n};\n\nexport function __wbg_setTimeout_1c75092906446b91() { return handleError(function (arg0, arg1, arg2) {\n    var ret = getObject(arg0).setTimeout(getObject(arg1), arg2);\n    return ret;\n}, arguments) };\n\nexport function __wbg_fetch_fe54824ee845f6b4(arg0, arg1) {\n    var ret = getObject(arg0).fetch(getObject(arg1));\n    return addHeapObject(ret);\n};\n\nexport function __wbg_new_226d109446575877() { return handleError(function () {\n    var ret = new Headers();\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_append_4d85f35672cbffa7() { return handleError(function (arg0, arg1, arg2, arg3, arg4) {\n    getObject(arg0).append(getStringFromWasm0(arg1, arg2), getStringFromWasm0(arg3, arg4));\n}, arguments) };\n\nexport function __wbg_signal_259ba662a5555524(arg0) {\n    var ret = getObject(arg0).signal;\n    return addHeapObject(ret);\n};\n\nexport function __wbg_new_7456dc18cc110e9c() { return handleError(function () {\n    var ret = new AbortController();\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_abort_3c64506fb0036132(arg0) {\n    getObject(arg0).abort();\n};\n\nexport function __wbg_instanceof_Response_ea36d565358a42f7(arg0) {\n    var ret = getObject(arg0) instanceof Response;\n    return ret;\n};\n\nexport function __wbg_url_6e564c9e212456f8(arg0, arg1) {\n    var ret = getObject(arg1).url;\n    var ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    var len0 = WASM_VECTOR_LEN;\n    getInt32Memory0()[arg0 / 4 + 1] = len0;\n    getInt32Memory0()[arg0 / 4 + 0] = ptr0;\n};\n\nexport function __wbg_status_3a55bb50e744b834(arg0) {\n    var ret = getObject(arg0).status;\n    return ret;\n};\n\nexport function __wbg_headers_e4204c6775f7b3b4(arg0) {\n    var ret = getObject(arg0).headers;\n    return addHeapObject(ret);\n};\n\nexport function __wbg_arrayBuffer_0e2a43f68a8b3e49() { return handleError(function (arg0) {\n    var ret = getObject(arg0).arrayBuffer();\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_new_4473c9af1cac368b() { return handleError(function (arg0, arg1) {\n    var ret = new URL(getStringFromWasm0(arg0, arg1));\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_newwithstrandinit_c07f0662ece15bc6() { return handleError(function (arg0, arg1, arg2) {\n    var ret = new Request(getStringFromWasm0(arg0, arg1), getObject(arg2));\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_now_5fa0ca001e042f8a(arg0) {\n    var ret = getObject(arg0).now();\n    return ret;\n};\n\nexport function __wbg_process_f2b73829dbd321da(arg0) {\n    var ret = getObject(arg0).process;\n    return addHeapObject(ret);\n};\n\nexport function __wbindgen_is_object(arg0) {\n    const val = getObject(arg0);\n    var ret = typeof(val) === 'object' && val !== null;\n    return ret;\n};\n\nexport function __wbg_versions_cd82f79c98672a9f(arg0) {\n    var ret = getObject(arg0).versions;\n    return addHeapObject(ret);\n};\n\nexport function __wbg_node_ee3f6da4130bd35f(arg0) {\n    var ret = getObject(arg0).node;\n    return addHeapObject(ret);\n};\n\nexport function __wbg_modulerequire_0a83c0c31d12d2c7() { return handleError(function (arg0, arg1) {\n    var ret = module.require(getStringFromWasm0(arg0, arg1));\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_crypto_9e3521ed42436d35(arg0) {\n    var ret = getObject(arg0).crypto;\n    return addHeapObject(ret);\n};\n\nexport function __wbg_msCrypto_c429c3f8f7a70bb5(arg0) {\n    var ret = getObject(arg0).msCrypto;\n    return addHeapObject(ret);\n};\n\nexport function __wbg_getRandomValues_3e46aa268da0fed1() { return handleError(function (arg0, arg1) {\n    getObject(arg0).getRandomValues(getObject(arg1));\n}, arguments) };\n\nexport function __wbg_randomFillSync_59fcc2add91fe7b3() { return handleError(function (arg0, arg1, arg2) {\n    getObject(arg0).randomFillSync(getArrayU8FromWasm0(arg1, arg2));\n}, arguments) };\n\nexport function __wbindgen_is_function(arg0) {\n    var ret = typeof(getObject(arg0)) === 'function';\n    return ret;\n};\n\nexport function __wbg_newnoargs_f579424187aa1717(arg0, arg1) {\n    var ret = new Function(getStringFromWasm0(arg0, arg1));\n    return addHeapObject(ret);\n};\n\nexport function __wbg_next_c7a2a6b012059a5e(arg0) {\n    var ret = getObject(arg0).next;\n    return addHeapObject(ret);\n};\n\nexport function __wbg_next_dd1a890d37e38d73() { return handleError(function (arg0) {\n    var ret = getObject(arg0).next();\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_done_982b1c7ac0cbc69d(arg0) {\n    var ret = getObject(arg0).done;\n    return ret;\n};\n\nexport function __wbg_value_2def2d1fb38b02cd(arg0) {\n    var ret = getObject(arg0).value;\n    return addHeapObject(ret);\n};\n\nexport function __wbg_iterator_4b9cedbeda0c0e30() {\n    var ret = Symbol.iterator;\n    return addHeapObject(ret);\n};\n\nexport function __wbg_get_8bbb82393651dd9c() { return handleError(function (arg0, arg1) {\n    var ret = Reflect.get(getObject(arg0), getObject(arg1));\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_call_89558c3e96703ca1() { return handleError(function (arg0, arg1) {\n    var ret = getObject(arg0).call(getObject(arg1));\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_new_d3138911a89329b0() {\n    var ret = new Object();\n    return addHeapObject(ret);\n};\n\nexport function __wbg_self_e23d74ae45fb17d1() { return handleError(function () {\n    var ret = self.self;\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_window_b4be7f48b24ac56e() { return handleError(function () {\n    var ret = window.window;\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_globalThis_d61b1f48a57191ae() { return handleError(function () {\n    var ret = globalThis.globalThis;\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_global_e7669da72fd7f239() { return handleError(function () {\n    var ret = global.global;\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbindgen_is_undefined(arg0) {\n    var ret = getObject(arg0) === undefined;\n    return ret;\n};\n\nexport function __wbg_new_55259b13834a484c(arg0, arg1) {\n    var ret = new Error(getStringFromWasm0(arg0, arg1));\n    return addHeapObject(ret);\n};\n\nexport function __wbg_call_94697a95cb7e239c() { return handleError(function (arg0, arg1, arg2) {\n    var ret = getObject(arg0).call(getObject(arg1), getObject(arg2));\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_toString_9b85345d84562096(arg0) {\n    var ret = getObject(arg0).toString();\n    return addHeapObject(ret);\n};\n\nexport function __wbg_new_4beacc9c71572250(arg0, arg1) {\n    try {\n        var state0 = {a: arg0, b: arg1};\n        var cb0 = (arg0, arg1) => {\n            const a = state0.a;\n            state0.a = 0;\n            try {\n                return __wbg_adapter_413(a, state0.b, arg0, arg1);\n            } finally {\n                state0.a = a;\n            }\n        };\n        var ret = new Promise(cb0);\n        return addHeapObject(ret);\n    } finally {\n        state0.a = state0.b = 0;\n    }\n};\n\nexport function __wbg_resolve_4f8f547f26b30b27(arg0) {\n    var ret = Promise.resolve(getObject(arg0));\n    return addHeapObject(ret);\n};\n\nexport function __wbg_then_a6860c82b90816ca(arg0, arg1) {\n    var ret = getObject(arg0).then(getObject(arg1));\n    return addHeapObject(ret);\n};\n\nexport function __wbg_then_58a04e42527f52c6(arg0, arg1, arg2) {\n    var ret = getObject(arg0).then(getObject(arg1), getObject(arg2));\n    return addHeapObject(ret);\n};\n\nexport function __wbg_buffer_5e74a88a1424a2e0(arg0) {\n    var ret = getObject(arg0).buffer;\n    return addHeapObject(ret);\n};\n\nexport function __wbg_newwithbyteoffsetandlength_278ec7532799393a(arg0, arg1, arg2) {\n    var ret = new Uint8Array(getObject(arg0), arg1 >>> 0, arg2 >>> 0);\n    return addHeapObject(ret);\n};\n\nexport function __wbg_new_e3b800e570795b3c(arg0) {\n    var ret = new Uint8Array(getObject(arg0));\n    return addHeapObject(ret);\n};\n\nexport function __wbg_set_5b8081e9d002f0df(arg0, arg1, arg2) {\n    getObject(arg0).set(getObject(arg1), arg2 >>> 0);\n};\n\nexport function __wbg_length_30803400a8f15c59(arg0) {\n    var ret = getObject(arg0).length;\n    return ret;\n};\n\nexport function __wbg_newwithlength_5f4ce114a24dfe1e(arg0) {\n    var ret = new Uint8Array(arg0 >>> 0);\n    return addHeapObject(ret);\n};\n\nexport function __wbg_subarray_a68f835ca2af506f(arg0, arg1, arg2) {\n    var ret = getObject(arg0).subarray(arg1 >>> 0, arg2 >>> 0);\n    return addHeapObject(ret);\n};\n\nexport function __wbg_has_3850edde6df9191b() { return handleError(function (arg0, arg1) {\n    var ret = Reflect.has(getObject(arg0), getObject(arg1));\n    return ret;\n}, arguments) };\n\nexport function __wbg_set_c42875065132a932() { return handleError(function (arg0, arg1, arg2) {\n    var ret = Reflect.set(getObject(arg0), getObject(arg1), getObject(arg2));\n    return ret;\n}, arguments) };\n\nexport function __wbg_stringify_f8bfc9e2d1e8b6a0() { return handleError(function (arg0) {\n    var ret = JSON.stringify(getObject(arg0));\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbindgen_debug_string(arg0, arg1) {\n    var ret = debugString(getObject(arg1));\n    var ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    var len0 = WASM_VECTOR_LEN;\n    getInt32Memory0()[arg0 / 4 + 1] = len0;\n    getInt32Memory0()[arg0 / 4 + 0] = ptr0;\n};\n\nexport function __wbindgen_throw(arg0, arg1) {\n    throw new Error(getStringFromWasm0(arg0, arg1));\n};\n\nexport function __wbindgen_memory() {\n    var ret = wasm.memory;\n    return addHeapObject(ret);\n};\n\nexport function __wbindgen_closure_wrapper1289(arg0, arg1, arg2) {\n    var ret = makeClosure(arg0, arg1, 245, __wbg_adapter_34);\n    return addHeapObject(ret);\n};\n\nexport function __wbindgen_closure_wrapper6956(arg0, arg1, arg2) {\n    var ret = makeMutClosure(arg0, arg1, 965, __wbg_adapter_37);\n    return addHeapObject(ret);\n};\n\nexport function __wbindgen_closure_wrapper7044(arg0, arg1, arg2) {\n    var ret = makeMutClosure(arg0, arg1, 988, __wbg_adapter_40);\n    return addHeapObject(ret);\n};\n\n","import * as wasm from \"./ergo_lib_wasm_bg.wasm\";\nexport * from \"./ergo_lib_wasm_bg.js\";"],"sourceRoot":""}