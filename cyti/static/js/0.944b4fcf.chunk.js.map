{"version":3,"sources":["../node_modules/ergo-lib-wasm-browser/ergo_lib_wasm_bg.js","../node_modules/webpack/buildin/harmony-module.js","../node_modules/ergo-lib-wasm-browser/ergo_lib_wasm.js"],"names":["heap","Array","fill","undefined","getObject","idx","push","heap_next","length","takeObject","ret","dropObject","addHeapObject","obj","cachedTextDecoder","TextDecoder","module","require","ignoreBOM","fatal","decode","cachegetUint8Memory0","getUint8Memory0","buffer","wasm","Uint8Array","getStringFromWasm0","ptr","len","subarray","WASM_VECTOR_LEN","cachedTextEncoder","TextEncoder","encodeString","encodeInto","arg","view","buf","encode","set","read","written","passStringToWasm0","malloc","realloc","mem","offset","code","charCodeAt","slice","isLikeNone","x","cachegetInt32Memory0","getInt32Memory0","Int32Array","cachegetFloat64Memory0","debugString","val","type","description","name","isArray","debug","i","className","builtInMatches","exec","toString","call","JSON","stringify","_","Error","message","stack","__wbg_adapter_40","arg0","arg1","makeMutClosure","dtor","f","state","a","b","cnt","real","args","get","original","__wbg_adapter_43","__wbg_adapter_46","arg2","cachegetUint32Memory0","getUint32Memory0","Uint32Array","passArrayJsValueToWasm0","array","array_as_tuple","items","ptr0","len0","_assertClass","instance","klass","getArrayU8FromWasm0","passArray8ToWasm0","passArray32ToWasm0","getArrayJsValueFromWasm0","result","stack_pointer","addBorrowedObject","extract_hints","signed_transaction","state_context","boxes_to_spend","data_boxes","real_propositions","simulated_propositions","retptr","Transaction","ErgoStateContext","ErgoBoxes","Propositions","ptr1","ptr2","r0","r1","TransactionHintsBag","__wrap","base16_decode","data","r2","v1","get_info","node","NodeConf","get_header","header_id","BlockId","get_nipopow_proof_by_header_id","min_chain_length","suffix_len","get_blocks_header_id_proof_for_tx_id","tx_id","TxId","peer_discovery","seeds","max_parallel_requests","timeout_sec","is_chrome","incremental_peer_discovery_chrome","scan","ChromePeerDiscoveryScan","verify_signature","address","signature","Address","len1","handleError","apply","this","e","NonMandatoryRegisterId","Object","freeze","R4","R5","R6","R7","R8","R9","NetworkPrefix","Mainnet","Testnet","AddressTypePrefix","P2Pk","Pay2Sh","Pay2S","__destroy_into_raw","network_prefix","v0","ErgoTree","create","prototype","ergo_tree","bytes","s","BatchMerkleProof","expected_root","json","BlockHeader","BlockHeaders","json_vals","index","id","BoxId","box_id_str","BoxSelection","boxes","change","ErgoBoxAssetsDataList","BoxValue","I64","v","PeerUrls","CommitmentHint","Constant","r3","ErgoBox","base16_bytes_str","num","arr","bytes1","bytes2","l1","l2","value","ContextExtension","key","Contract","recipient","source","DataInput","box_id","DataInputs","elem","DerivationPath","acc","address_indices","path","creation_height","contract","tokens","Tokens","register_id","ErgoBoxAssetsData","ErgoBoxCandidate","fee_amount","ErgoBoxCandidateBuilder","new_min_value_per_byte","new_value","token","token_name","token_desc","num_decimals","Token","token_id","amount","TokenId","TokenAmount","ErgoBoxCandidates","box_candidate","pre_header","headers","PreHeader","constant","ExtPubKey","public_key_bytes","chain_code","derivation_path","ExtSecretKey","secret_key_bytes","seed_bytes","HintsBag","hint","other","string","Input","ProverResult","Inputs","LevelNode","hash","side","MerkleProof","level","leaf_data","MinerAddress","Mnemonic","mnemonic_phrase","mnemonic_pass","v2","NetworkAddress","network","NipopowProof","that","PoPowHeader","NipopowVerifier","genesis_block_id","new_proof","url","NodeInfo","block_header","proposition","ReducedTransaction","UnsignedTransaction","unsigned_tx","SecretKey","SecretKeys","SimpleBoxSelector","inputs","target_balance","target_tokens","str","input_box","proofs","hints_bag","TxBuilder","data_inputs","context_extension","box_selection","output_candidates","current_height","change_address","UnsignedInput","ext","UnsignedInputs","input_id","Wallet","secret","_state_context","tx","tx_hints","reduced_tx","__wbindgen_object_drop_ref","__wbg_peerurls_new","__wbindgen_object_clone_ref","__wbindgen_number_new","__wbindgen_string_new","__wbindgen_is_string","__wbindgen_string_get","__wbg_merkleproof_new","__wbg_chromepeerdiscoveryscan_new","__wbg_blockheader_new","__wbg_nipopowproof_new","__wbg_nodeinfo_new","__wbindgen_ge","__wbindgen_number_get","Float64Array","__wbindgen_is_bigint","__wbindgen_json_parse","parse","__wbindgen_json_serialize","__wbindgen_error_new","__wbg_new_693216e109162396","__wbg_stack_0ddaca5d1abfb52f","__wbg_error_09919627ac0992f5","console","error","__wbg_fetch_96cb59599250c5c7","fetch","__wbindgen_cb_drop","__wbg_instanceof_Window_434ce1849eb4e0fc","Window","__wbg_performance_bbca4ccfaef860b2","performance","__wbg_clearTimeout_0ca9612f07e1cdae","clearTimeout","__wbg_setTimeout_1c75092906446b91","setTimeout","arguments","__wbg_new_226d109446575877","Headers","__wbg_append_4d85f35672cbffa7","arg3","arg4","append","__wbg_fetch_fe54824ee845f6b4","__wbg_instanceof_Response_ea36d565358a42f7","Response","__wbg_url_6e564c9e212456f8","__wbg_status_3a55bb50e744b834","status","__wbg_headers_e4204c6775f7b3b4","__wbg_arrayBuffer_0e2a43f68a8b3e49","arrayBuffer","__wbg_host_7633166e48189c8e","host","__wbg_new_4473c9af1cac368b","URL","__wbg_signal_259ba662a5555524","signal","__wbg_new_7456dc18cc110e9c","AbortController","__wbg_abort_3c64506fb0036132","abort","__wbg_newwithstrandinit_c07f0662ece15bc6","Request","__wbg_now_5fa0ca001e042f8a","now","__wbg_process_e56fd54cf6319b6c","process","__wbindgen_is_object","__wbg_versions_77e21455908dad33","versions","__wbg_node_0dd25d832e4785d5","__wbg_require_0db1598d9ccecb30","__wbg_crypto_b95d7173266618a9","crypto","__wbg_msCrypto_5a86d77a66230f81","msCrypto","__wbg_getRandomValues_b14734aa289bc356","getRandomValues","__wbg_static_accessor_NODE_MODULE_26b231378c1be7dd","__wbg_randomFillSync_91e2b39becca6147","randomFillSync","__wbg_get_f45dff51f52d7222","__wbg_length_7b60f47bde714631","__wbg_new_16f24b0728c5e67b","__wbg_BigInt_229ec68d668024d2","BigInt","__wbindgen_is_function","__wbg_newnoargs_f579424187aa1717","Function","__wbg_next_c7a2a6b012059a5e","next","__wbg_next_dd1a890d37e38d73","__wbg_done_982b1c7ac0cbc69d","done","__wbg_value_2def2d1fb38b02cd","__wbg_iterator_4b9cedbeda0c0e30","Symbol","iterator","__wbg_get_8bbb82393651dd9c","Reflect","__wbg_call_89558c3e96703ca1","__wbg_new_d3138911a89329b0","__wbg_self_e23d74ae45fb17d1","self","__wbg_window_b4be7f48b24ac56e","window","__wbg_globalThis_d61b1f48a57191ae","globalThis","__wbg_global_e7669da72fd7f239","global","__wbindgen_is_undefined","__wbg_isArray_8480ed76e5369634","__wbg_push_a72df856079e6930","__wbg_BigInt_5179c5cb9cc5bfa4","__wbg_toString_438e03f57fe1aad9","__wbg_toString_ca043cc7e2bb8f6e","__wbg_new_55259b13834a484c","__wbg_setname_b9dec29a5b82e0e1","__wbg_call_94697a95cb7e239c","__wbg_valueOf_39e0d6bc7e4232b9","valueOf","__wbg_toString_9b85345d84562096","__wbg_new_4beacc9c71572250","state0","Promise","__wbg_adapter_488","__wbg_resolve_4f8f547f26b30b27","resolve","__wbg_then_a6860c82b90816ca","then","__wbg_then_58a04e42527f52c6","__wbg_buffer_5e74a88a1424a2e0","__wbg_newwithbyteoffsetandlength_278ec7532799393a","__wbg_new_e3b800e570795b3c","__wbg_set_5b8081e9d002f0df","__wbg_length_30803400a8f15c59","__wbg_instanceof_Uint8Array_8a8537f46e056474","__wbg_newwithlength_5f4ce114a24dfe1e","__wbg_subarray_a68f835ca2af506f","__wbg_has_3850edde6df9191b","has","__wbg_set_c42875065132a932","__wbg_stringify_f8bfc9e2d1e8b6a0","__wbindgen_debug_string","__wbindgen_throw","__wbindgen_memory","__wbindgen_closure_wrapper2131","makeClosure","__wbindgen_closure_wrapper7194","__wbindgen_closure_wrapper8075","exports","originalModule","webpackPolyfill","children","defineProperty","enumerable","l"],"mappings":"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","file":"static/js/0.944b4fcf.chunk.js","sourcesContent":["import * as wasm from './ergo_lib_wasm_bg.wasm';\n\nconst heap = new Array(32).fill(undefined);\n\nheap.push(undefined, null, true, false);\n\nfunction getObject(idx) { return heap[idx]; }\n\nlet heap_next = heap.length;\n\nfunction dropObject(idx) {\n    if (idx < 36) return;\n    heap[idx] = heap_next;\n    heap_next = idx;\n}\n\nfunction takeObject(idx) {\n    const ret = getObject(idx);\n    dropObject(idx);\n    return ret;\n}\n\nfunction addHeapObject(obj) {\n    if (heap_next === heap.length) heap.push(heap.length + 1);\n    const idx = heap_next;\n    heap_next = heap[idx];\n\n    heap[idx] = obj;\n    return idx;\n}\n\nconst lTextDecoder = typeof TextDecoder === 'undefined' ? (0, module.require)('util').TextDecoder : TextDecoder;\n\nlet cachedTextDecoder = new lTextDecoder('utf-8', { ignoreBOM: true, fatal: true });\n\ncachedTextDecoder.decode();\n\nlet cachegetUint8Memory0 = null;\nfunction getUint8Memory0() {\n    if (cachegetUint8Memory0 === null || cachegetUint8Memory0.buffer !== wasm.memory.buffer) {\n        cachegetUint8Memory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachegetUint8Memory0;\n}\n\nfunction getStringFromWasm0(ptr, len) {\n    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));\n}\n\nlet WASM_VECTOR_LEN = 0;\n\nconst lTextEncoder = typeof TextEncoder === 'undefined' ? (0, module.require)('util').TextEncoder : TextEncoder;\n\nlet cachedTextEncoder = new lTextEncoder('utf-8');\n\nconst encodeString = (typeof cachedTextEncoder.encodeInto === 'function'\n    ? function (arg, view) {\n    return cachedTextEncoder.encodeInto(arg, view);\n}\n    : function (arg, view) {\n    const buf = cachedTextEncoder.encode(arg);\n    view.set(buf);\n    return {\n        read: arg.length,\n        written: buf.length\n    };\n});\n\nfunction passStringToWasm0(arg, malloc, realloc) {\n\n    if (realloc === undefined) {\n        const buf = cachedTextEncoder.encode(arg);\n        const ptr = malloc(buf.length);\n        getUint8Memory0().subarray(ptr, ptr + buf.length).set(buf);\n        WASM_VECTOR_LEN = buf.length;\n        return ptr;\n    }\n\n    let len = arg.length;\n    let ptr = malloc(len);\n\n    const mem = getUint8Memory0();\n\n    let offset = 0;\n\n    for (; offset < len; offset++) {\n        const code = arg.charCodeAt(offset);\n        if (code > 0x7F) break;\n        mem[ptr + offset] = code;\n    }\n\n    if (offset !== len) {\n        if (offset !== 0) {\n            arg = arg.slice(offset);\n        }\n        ptr = realloc(ptr, len, len = offset + arg.length * 3);\n        const view = getUint8Memory0().subarray(ptr + offset, ptr + len);\n        const ret = encodeString(arg, view);\n\n        offset += ret.written;\n    }\n\n    WASM_VECTOR_LEN = offset;\n    return ptr;\n}\n\nfunction isLikeNone(x) {\n    return x === undefined || x === null;\n}\n\nlet cachegetInt32Memory0 = null;\nfunction getInt32Memory0() {\n    if (cachegetInt32Memory0 === null || cachegetInt32Memory0.buffer !== wasm.memory.buffer) {\n        cachegetInt32Memory0 = new Int32Array(wasm.memory.buffer);\n    }\n    return cachegetInt32Memory0;\n}\n\nlet cachegetFloat64Memory0 = null;\nfunction getFloat64Memory0() {\n    if (cachegetFloat64Memory0 === null || cachegetFloat64Memory0.buffer !== wasm.memory.buffer) {\n        cachegetFloat64Memory0 = new Float64Array(wasm.memory.buffer);\n    }\n    return cachegetFloat64Memory0;\n}\n\nfunction debugString(val) {\n    // primitive types\n    const type = typeof val;\n    if (type == 'number' || type == 'boolean' || val == null) {\n        return  `${val}`;\n    }\n    if (type == 'string') {\n        return `\"${val}\"`;\n    }\n    if (type == 'symbol') {\n        const description = val.description;\n        if (description == null) {\n            return 'Symbol';\n        } else {\n            return `Symbol(${description})`;\n        }\n    }\n    if (type == 'function') {\n        const name = val.name;\n        if (typeof name == 'string' && name.length > 0) {\n            return `Function(${name})`;\n        } else {\n            return 'Function';\n        }\n    }\n    // objects\n    if (Array.isArray(val)) {\n        const length = val.length;\n        let debug = '[';\n        if (length > 0) {\n            debug += debugString(val[0]);\n        }\n        for(let i = 1; i < length; i++) {\n            debug += ', ' + debugString(val[i]);\n        }\n        debug += ']';\n        return debug;\n    }\n    // Test for built-in\n    const builtInMatches = /\\[object ([^\\]]+)\\]/.exec(toString.call(val));\n    let className;\n    if (builtInMatches.length > 1) {\n        className = builtInMatches[1];\n    } else {\n        // Failed to match the standard '[object ClassName]'\n        return toString.call(val);\n    }\n    if (className == 'Object') {\n        // we're a user defined class or Object\n        // JSON.stringify avoids problems with cycles, and is generally much\n        // easier than looping through ownProperties of `val`.\n        try {\n            return 'Object(' + JSON.stringify(val) + ')';\n        } catch (_) {\n            return 'Object';\n        }\n    }\n    // errors\n    if (val instanceof Error) {\n        return `${val.name}: ${val.message}\\n${val.stack}`;\n    }\n    // TODO we could test for more things here, like `Set`s and `Map`s.\n    return className;\n}\n\nfunction makeClosure(arg0, arg1, dtor, f) {\n    const state = { a: arg0, b: arg1, cnt: 1, dtor };\n    const real = (...args) => {\n        // First up with a closure we increment the internal reference\n        // count. This ensures that the Rust closure environment won't\n        // be deallocated while we're invoking it.\n        state.cnt++;\n        try {\n            return f(state.a, state.b, ...args);\n        } finally {\n            if (--state.cnt === 0) {\n                wasm.__wbindgen_export_2.get(state.dtor)(state.a, state.b);\n                state.a = 0;\n\n            }\n        }\n    };\n    real.original = state;\n\n    return real;\n}\nfunction __wbg_adapter_40(arg0, arg1) {\n    wasm._dyn_core__ops__function__Fn_____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__he9829e0f34e66daf(arg0, arg1);\n}\n\nfunction makeMutClosure(arg0, arg1, dtor, f) {\n    const state = { a: arg0, b: arg1, cnt: 1, dtor };\n    const real = (...args) => {\n        // First up with a closure we increment the internal reference\n        // count. This ensures that the Rust closure environment won't\n        // be deallocated while we're invoking it.\n        state.cnt++;\n        const a = state.a;\n        state.a = 0;\n        try {\n            return f(a, state.b, ...args);\n        } finally {\n            if (--state.cnt === 0) {\n                wasm.__wbindgen_export_2.get(state.dtor)(a, state.b);\n\n            } else {\n                state.a = a;\n            }\n        }\n    };\n    real.original = state;\n\n    return real;\n}\nfunction __wbg_adapter_43(arg0, arg1) {\n    wasm._dyn_core__ops__function__FnMut_____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__h7946170bcdef0d18(arg0, arg1);\n}\n\nfunction __wbg_adapter_46(arg0, arg1, arg2) {\n    wasm._dyn_core__ops__function__FnMut__A____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__hce99cc980fba3524(arg0, arg1, addHeapObject(arg2));\n}\n\nlet cachegetUint32Memory0 = null;\nfunction getUint32Memory0() {\n    if (cachegetUint32Memory0 === null || cachegetUint32Memory0.buffer !== wasm.memory.buffer) {\n        cachegetUint32Memory0 = new Uint32Array(wasm.memory.buffer);\n    }\n    return cachegetUint32Memory0;\n}\n\nfunction passArrayJsValueToWasm0(array, malloc) {\n    const ptr = malloc(array.length * 4);\n    const mem = getUint32Memory0();\n    for (let i = 0; i < array.length; i++) {\n        mem[ptr / 4 + i] = addHeapObject(array[i]);\n    }\n    WASM_VECTOR_LEN = array.length;\n    return ptr;\n}\n/**\n* Encode a JS array as an Ergo tuple.\n* @param {any[]} items\n* @returns {any}\n*/\nexport function array_as_tuple(items) {\n    var ptr0 = passArrayJsValueToWasm0(items, wasm.__wbindgen_malloc);\n    var len0 = WASM_VECTOR_LEN;\n    var ret = wasm.array_as_tuple(ptr0, len0);\n    return takeObject(ret);\n}\n\nfunction _assertClass(instance, klass) {\n    if (!(instance instanceof klass)) {\n        throw new Error(`expected instance of ${klass.name}`);\n    }\n    return instance.ptr;\n}\n\nfunction getArrayU8FromWasm0(ptr, len) {\n    return getUint8Memory0().subarray(ptr / 1, ptr / 1 + len);\n}\n\nfunction passArray8ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 1);\n    getUint8Memory0().set(arg, ptr / 1);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n\nfunction passArray32ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 4);\n    getUint32Memory0().set(arg, ptr / 4);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n\nfunction getArrayI32FromWasm0(ptr, len) {\n    return getInt32Memory0().subarray(ptr / 4, ptr / 4 + len);\n}\n\nfunction getArrayJsValueFromWasm0(ptr, len) {\n    const mem = getUint32Memory0();\n    const slice = mem.subarray(ptr / 4, ptr / 4 + len);\n    const result = [];\n    for (let i = 0; i < slice.length; i++) {\n        result.push(takeObject(slice[i]));\n    }\n    return result;\n}\n\nlet stack_pointer = 32;\n\nfunction addBorrowedObject(obj) {\n    if (stack_pointer == 1) throw new Error('out of js stack');\n    heap[--stack_pointer] = obj;\n    return stack_pointer;\n}\n/**\n* Extracting hints form singed(invalid) Transaction\n* @param {Transaction} signed_transaction\n* @param {ErgoStateContext} state_context\n* @param {ErgoBoxes} boxes_to_spend\n* @param {ErgoBoxes} data_boxes\n* @param {Propositions} real_propositions\n* @param {Propositions} simulated_propositions\n* @returns {TransactionHintsBag}\n*/\nexport function extract_hints(signed_transaction, state_context, boxes_to_spend, data_boxes, real_propositions, simulated_propositions) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        _assertClass(signed_transaction, Transaction);\n        var ptr0 = signed_transaction.ptr;\n        signed_transaction.ptr = 0;\n        _assertClass(state_context, ErgoStateContext);\n        _assertClass(boxes_to_spend, ErgoBoxes);\n        _assertClass(data_boxes, ErgoBoxes);\n        _assertClass(real_propositions, Propositions);\n        var ptr1 = real_propositions.ptr;\n        real_propositions.ptr = 0;\n        _assertClass(simulated_propositions, Propositions);\n        var ptr2 = simulated_propositions.ptr;\n        simulated_propositions.ptr = 0;\n        wasm.extract_hints(retptr, ptr0, state_context.ptr, boxes_to_spend.ptr, data_boxes.ptr, ptr1, ptr2);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return TransactionHintsBag.__wrap(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* Decodes a base16 string into an array of bytes\n* @param {string} data\n* @returns {Uint8Array}\n*/\nexport function base16_decode(data) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        var ptr0 = passStringToWasm0(data, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        wasm.base16_decode(retptr, ptr0, len0);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        var r3 = getInt32Memory0()[retptr / 4 + 3];\n        if (r3) {\n            throw takeObject(r2);\n        }\n        var v1 = getArrayU8FromWasm0(r0, r1).slice();\n        wasm.__wbindgen_free(r0, r1 * 1);\n        return v1;\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* GET on /info endpoint\n* @param {NodeConf} node\n* @returns {Promise<any>}\n*/\nexport function get_info(node) {\n    _assertClass(node, NodeConf);\n    var ret = wasm.get_info(node.ptr);\n    return takeObject(ret);\n}\n\n/**\n* GET on /blocks/{header_id}/header endpoint\n* @param {NodeConf} node\n* @param {BlockId} header_id\n* @returns {Promise<any>}\n*/\nexport function get_header(node, header_id) {\n    _assertClass(node, NodeConf);\n    _assertClass(header_id, BlockId);\n    var ret = wasm.get_header(node.ptr, header_id.ptr);\n    return takeObject(ret);\n}\n\n/**\n* GET on /nipopow/proof/{minChainLength}/{suffixLength}/{headerId} endpoint\n* @param {NodeConf} node\n* @param {number} min_chain_length\n* @param {number} suffix_len\n* @param {BlockId} header_id\n* @returns {Promise<any>}\n*/\nexport function get_nipopow_proof_by_header_id(node, min_chain_length, suffix_len, header_id) {\n    _assertClass(node, NodeConf);\n    _assertClass(header_id, BlockId);\n    var ret = wasm.get_nipopow_proof_by_header_id(node.ptr, min_chain_length, suffix_len, header_id.ptr);\n    return takeObject(ret);\n}\n\n/**\n* GET on /blocks/{header_id}/proofFor/{tx_id} to request the merkle proof for a given transaction\n* that belongs to the given header ID.\n* @param {NodeConf} node\n* @param {BlockId} header_id\n* @param {TxId} tx_id\n* @returns {Promise<any>}\n*/\nexport function get_blocks_header_id_proof_for_tx_id(node, header_id, tx_id) {\n    _assertClass(node, NodeConf);\n    _assertClass(header_id, BlockId);\n    _assertClass(tx_id, TxId);\n    var ret = wasm.get_blocks_header_id_proof_for_tx_id(node.ptr, header_id.ptr, tx_id.ptr);\n    return takeObject(ret);\n}\n\n/**\n* Given a list of seed nodes, search for peer nodes with an active REST API on port 9053.\n*  - `seeds` represents a list of ergo node URLs from which to start peer discovery.\n*  - `max_parallel_tasks` represents the maximum number of tasks to spawn for ergo node HTTP\n*    requests. Note that the actual number of parallel HTTP requests may well be higher than this\n*    number.\n*  - `timeout` represents the amount of time that is spent search for peers. Once the timeout\n*    value is reached, return with the vec of active peers that have been discovered up to that\n*    point in time.\n*  - `is_chrome` **MUST** be set to true if running this function on a Chromium-based browser.\n*    There are some limitations on this platform regarding network requests. Please see the\n*    documentation for [`peer_discovery_chrome`].\n* @param {(URL)[]} seeds\n* @param {number} max_parallel_requests\n* @param {number} timeout_sec\n* @param {boolean} is_chrome\n* @returns {Promise<PeerUrls>}\n*/\nexport function peer_discovery(seeds, max_parallel_requests, timeout_sec, is_chrome) {\n    var ptr0 = passArrayJsValueToWasm0(seeds, wasm.__wbindgen_malloc);\n    var len0 = WASM_VECTOR_LEN;\n    var ret = wasm.peer_discovery(ptr0, len0, max_parallel_requests, timeout_sec, is_chrome);\n    return takeObject(ret);\n}\n\n/**\n* An incremental (reusable) version of [`peer_discovery_chrome`] which allows for peer discovery\n* to be split into separate sub-tasks.\n*\n* NOTE: intended to be used only on Chromium based browsers. It works on Firefox and Safari, but\n* using `peer_discovery` above gives better performance.\n* @param {ChromePeerDiscoveryScan} scan\n* @param {number} max_parallel_requests\n* @param {number} timeout_sec\n* @returns {Promise<any>}\n*/\nexport function incremental_peer_discovery_chrome(scan, max_parallel_requests, timeout_sec) {\n    _assertClass(scan, ChromePeerDiscoveryScan);\n    var ret = wasm.incremental_peer_discovery_chrome(scan.ptr, max_parallel_requests, timeout_sec);\n    return takeObject(ret);\n}\n\n/**\n* Verify that the signature is presented to satisfy SigmaProp conditions.\n* @param {Address} address\n* @param {Uint8Array} message\n* @param {Uint8Array} signature\n* @returns {boolean}\n*/\nexport function verify_signature(address, message, signature) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        _assertClass(address, Address);\n        var ptr0 = passArray8ToWasm0(message, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ptr1 = passArray8ToWasm0(signature, wasm.__wbindgen_malloc);\n        var len1 = WASM_VECTOR_LEN;\n        wasm.verify_signature(retptr, address.ptr, ptr0, len0, ptr1, len1);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return r0 !== 0;\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\nfunction handleError(f, args) {\n    try {\n        return f.apply(this, args);\n    } catch (e) {\n        wasm.__wbindgen_exn_store(addHeapObject(e));\n    }\n}\nfunction __wbg_adapter_488(arg0, arg1, arg2, arg3) {\n    wasm.wasm_bindgen__convert__closures__invoke2_mut__h590f1690a559e987(arg0, arg1, addHeapObject(arg2), addHeapObject(arg3));\n}\n\n/**\n* newtype for box registers R4 - R9\n*/\nexport const NonMandatoryRegisterId = Object.freeze({\n/**\n* id for R4 register\n*/\nR4:4,\"4\":\"R4\",\n/**\n* id for R5 register\n*/\nR5:5,\"5\":\"R5\",\n/**\n* id for R6 register\n*/\nR6:6,\"6\":\"R6\",\n/**\n* id for R7 register\n*/\nR7:7,\"7\":\"R7\",\n/**\n* id for R8 register\n*/\nR8:8,\"8\":\"R8\",\n/**\n* id for R9 register\n*/\nR9:9,\"9\":\"R9\", });\n/**\n* Network type\n*/\nexport const NetworkPrefix = Object.freeze({\n/**\n* Mainnet\n*/\nMainnet:0,\"0\":\"Mainnet\",\n/**\n* Testnet\n*/\nTestnet:16,\"16\":\"Testnet\", });\n/**\n* Address types\n*/\nexport const AddressTypePrefix = Object.freeze({\n/**\n* 0x01 - Pay-to-PublicKey(P2PK) address\n*/\nP2Pk:1,\"1\":\"P2Pk\",\n/**\n* 0x02 - Pay-to-Script-Hash(P2SH)\n*/\nPay2Sh:2,\"2\":\"Pay2Sh\",\n/**\n* 0x03 - Pay-to-Script(P2S)\n*/\nPay2S:3,\"3\":\"Pay2S\", });\n/**\n*\n* * An address is a short string corresponding to some script used to protect a box. Unlike (string-encoded) binary\n* * representation of a script, an address has some useful characteristics:\n* *\n* * - Integrity of an address could be checked., as it is incorporating a checksum.\n* * - A prefix of address is showing network and an address type.\n* * - An address is using an encoding (namely, Base58) which is avoiding similarly l0Oking characters, friendly to\n* * double-clicking and line-breaking in emails.\n* *\n* *\n* *\n* * An address is encoding network type, address type, checksum, and enough information to watch for a particular scripts.\n* *\n* * Possible network types are:\n* * Mainnet - 0x00\n* * Testnet - 0x10\n* *\n* * For an address type, we form content bytes as follows:\n* *\n* * P2PK - serialized (compressed) public key\n* * P2SH - first 192 bits of the Blake2b256 hash of serialized script bytes\n* * P2S  - serialized script\n* *\n* * Address examples for testnet:\n* *\n* * 3   - P2PK (3WvsT2Gm4EpsM9Pg18PdY6XyhNNMqXDsvJTbbf6ihLvAmSb7u5RN)\n* * ?   - P2SH (rbcrmKEYduUvADj9Ts3dSVSG27h54pgrq5fPuwB)\n* * ?   - P2S (Ms7smJwLGbUAjuWQ)\n* *\n* * for mainnet:\n* *\n* * 9  - P2PK (9fRAWhdxEsTcdb8PhGNrZfwqa65zfkuYHAMmkQLcic1gdLSV5vA)\n* * ?  - P2SH (8UApt8czfFVuTgQmMwtsRBZ4nfWquNiSwCWUjMg)\n* * ?  - P2S (4MQyML64GnzMxZgm, BxKBaHkvrTvLZrDcZjcsxsF7aSsrN73ijeFZXtbj4CXZHHcvBtqSxQ)\n* *\n* *\n* * Prefix byte = network type + address type\n* *\n* * checksum = blake2b256(prefix byte ++ content bytes)\n* *\n* * address = prefix byte ++ content bytes ++ checksum\n* *\n*\n*/\nexport class Address {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Address.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_address_free(ptr);\n    }\n    /**\n    * Re-create the address from ErgoTree that was built from the address\n    *\n    * At some point in the past a user entered an address from which the ErgoTree was built.\n    * Re-create the address from this ErgoTree.\n    * `tree` - ErgoTree that was created from an Address\n    * @param {ErgoTree} ergo_tree\n    * @returns {Address}\n    */\n    static recreate_from_ergo_tree(ergo_tree) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(ergo_tree, ErgoTree);\n            wasm.address_recreate_from_ergo_tree(retptr, ergo_tree.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Address.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Create a P2PK address from serialized PK bytes(EcPoint/GroupElement)\n    * @param {Uint8Array} bytes\n    * @returns {Address}\n    */\n    static p2pk_from_pk_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.address_p2pk_from_pk_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Address.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Decode (base58) testnet address from string, checking that address is from the testnet\n    * @param {string} s\n    * @returns {Address}\n    */\n    static from_testnet_str(s) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(s, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.address_from_testnet_str(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Address.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Decode (base58) mainnet address from string, checking that address is from the mainnet\n    * @param {string} s\n    * @returns {Address}\n    */\n    static from_mainnet_str(s) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(s, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.address_from_mainnet_str(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Address.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Decode (base58) address from string without checking the network prefix\n    * @param {string} s\n    * @returns {Address}\n    */\n    static from_base58(s) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(s, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.address_from_base58(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Address.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Encode (base58) address\n    * @param {number} network_prefix\n    * @returns {string}\n    */\n    to_base58(network_prefix) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.address_to_base58(retptr, this.ptr, network_prefix);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * Decode from a serialized address (that includes the network prefix)\n    * @param {Uint8Array} data\n    * @returns {Address}\n    */\n    static from_bytes(data) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passArray8ToWasm0(data, wasm.__wbindgen_malloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.address_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Address.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Encode address as serialized bytes (that includes the network prefix)\n    * @param {number} network_prefix\n    * @returns {Uint8Array}\n    */\n    to_bytes(network_prefix) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.address_to_bytes(retptr, this.ptr, network_prefix);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Returns underlying value for each address type\n    * (serialized EcPoint for P2PK, stored bytes for P2SH and P2S)\n    * @returns {Uint8Array}\n    */\n    content_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.address_content_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Get the type of the address\n    * @returns {number}\n    */\n    address_type_prefix() {\n        var ret = wasm.address_address_type_prefix(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Create an address from a public key\n    * @param {Uint8Array} bytes\n    * @returns {Address}\n    */\n    static from_public_key(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.address_from_public_key(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Address.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Creates an ErgoTree script from the address\n    * @returns {ErgoTree}\n    */\n    to_ergo_tree() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.address_to_ergo_tree(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ErgoTree.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n* BatchMerkleProof type to validate root hash for multiple nodes\n*/\nexport class BatchMerkleProof {\n\n    static __wrap(ptr) {\n        const obj = Object.create(BatchMerkleProof.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_batchmerkleproof_free(ptr);\n    }\n    /**\n    * Creates a new [`BatchMerkleProof`] from json representation\n    * @param {any} json\n    * @returns {BatchMerkleProof}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.batchmerkleproof_from_json(retptr, addBorrowedObject(json));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return BatchMerkleProof.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Converts [`BatchMerkleProof`] to json representation\n    * @returns {any}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.batchmerkleproof_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Calculates root hash for [`BatchMerkleProof`] and compares it against expected root hash\n    * @param {Uint8Array} expected_root\n    * @returns {boolean}\n    */\n    valid(expected_root) {\n        var ptr0 = passArray8ToWasm0(expected_root, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.batchmerkleproof_valid(this.ptr, ptr0, len0);\n        return ret !== 0;\n    }\n}\n/**\n* Block header\n*/\nexport class BlockHeader {\n\n    static __wrap(ptr) {\n        const obj = Object.create(BlockHeader.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_blockheader_free(ptr);\n    }\n    /**\n    * Parse from JSON (Node API)\n    * @param {string} json\n    * @returns {BlockHeader}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.blockheader_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return BlockHeader.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Get Header's id\n    * @returns {BlockId}\n    */\n    id() {\n        var ret = wasm.blockheader_id(this.ptr);\n        return BlockId.__wrap(ret);\n    }\n    /**\n    * Get transactions root\n    * @returns {Uint8Array}\n    */\n    transactions_root() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.blockheader_transactions_root(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n* Collection of BlockHeaders\n*/\nexport class BlockHeaders {\n\n    static __wrap(ptr) {\n        const obj = Object.create(BlockHeaders.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_blockheaders_free(ptr);\n    }\n    /**\n    * parse BlockHeader array from JSON (Node API)\n    * @param {any[]} json_vals\n    * @returns {BlockHeaders}\n    */\n    static from_json(json_vals) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passArrayJsValueToWasm0(json_vals, wasm.__wbindgen_malloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.blockheaders_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return BlockHeaders.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Create new collection with one element\n    * @param {BlockHeader} b\n    */\n    constructor(b) {\n        _assertClass(b, BlockHeader);\n        var ret = wasm.blockheaders_new(b.ptr);\n        return BlockHeaders.__wrap(ret);\n    }\n    /**\n    * Returns the number of elements in the collection\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.blockheaders_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Add an element to the collection\n    * @param {BlockHeader} b\n    */\n    add(b) {\n        _assertClass(b, BlockHeader);\n        wasm.blockheaders_add(this.ptr, b.ptr);\n    }\n    /**\n    * Returns the element of the collection with a given index\n    * @param {number} index\n    * @returns {BlockHeader}\n    */\n    get(index) {\n        var ret = wasm.blockheaders_get(this.ptr, index);\n        return BlockHeader.__wrap(ret);\n    }\n}\n/**\n* Block id\n*/\nexport class BlockId {\n\n    static __wrap(ptr) {\n        const obj = Object.create(BlockId.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_blockid_free(ptr);\n    }\n    /**\n    * Parse from base 16 encoded string\n    * @param {string} id\n    * @returns {BlockId}\n    */\n    static from_str(id) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(id, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.blockid_from_str(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return BlockId.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Equality check\n    * @param {BlockId} id\n    * @returns {boolean}\n    */\n    equals(id) {\n        _assertClass(id, BlockId);\n        var ret = wasm.blockid_equals(this.ptr, id.ptr);\n        return ret !== 0;\n    }\n}\n/**\n* Box id (32-byte digest)\n*/\nexport class BoxId {\n\n    static __wrap(ptr) {\n        const obj = Object.create(BoxId.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_boxid_free(ptr);\n    }\n    /**\n    * Parse box id (32 byte digest) from base16-encoded string\n    * @param {string} box_id_str\n    * @returns {BoxId}\n    */\n    static from_str(box_id_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(box_id_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.boxid_from_str(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return BoxId.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Base16 encoded string\n    * @returns {string}\n    */\n    to_str() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.boxid_to_str(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * Returns byte array (32 bytes)\n    * @returns {Uint8Array}\n    */\n    as_bytes() {\n        var ret = wasm.boxid_as_bytes(this.ptr);\n        return takeObject(ret);\n    }\n}\n/**\n* Selected boxes with change boxes (by [`BoxSelector`])\n*/\nexport class BoxSelection {\n\n    static __wrap(ptr) {\n        const obj = Object.create(BoxSelection.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_boxselection_free(ptr);\n    }\n    /**\n    * Create a selection to easily inject custom selection algorithms\n    * @param {ErgoBoxes} boxes\n    * @param {ErgoBoxAssetsDataList} change\n    */\n    constructor(boxes, change) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(boxes, ErgoBoxes);\n            _assertClass(change, ErgoBoxAssetsDataList);\n            wasm.boxselection_new(retptr, boxes.ptr, change.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return BoxSelection.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Selected boxes to spend as transaction inputs\n    * @returns {ErgoBoxes}\n    */\n    boxes() {\n        var ret = wasm.boxselection_boxes(this.ptr);\n        return ErgoBoxes.__wrap(ret);\n    }\n    /**\n    * Selected boxes to use as change\n    * @returns {ErgoBoxAssetsDataList}\n    */\n    change() {\n        var ret = wasm.boxselection_change(this.ptr);\n        return ErgoBoxAssetsDataList.__wrap(ret);\n    }\n}\n/**\n* Box value in nanoERGs with bound checks\n*/\nexport class BoxValue {\n\n    static __wrap(ptr) {\n        const obj = Object.create(BoxValue.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_boxvalue_free(ptr);\n    }\n    /**\n    * Recommended (safe) minimal box value to use in case box size estimation is unavailable.\n    * Allows box size upto 2777 bytes with current min box value per byte of 360 nanoERGs\n    * @returns {BoxValue}\n    */\n    static SAFE_USER_MIN() {\n        var ret = wasm.boxvalue_SAFE_USER_MIN();\n        return BoxValue.__wrap(ret);\n    }\n    /**\n    * Number of units inside one ERGO (i.e. one ERG using nano ERG representation)\n    * @returns {I64}\n    */\n    static UNITS_PER_ERGO() {\n        var ret = wasm.boxvalue_UNITS_PER_ERGO();\n        return I64.__wrap(ret);\n    }\n    /**\n    * Create from i64 with bounds check\n    * @param {I64} v\n    * @returns {BoxValue}\n    */\n    static from_i64(v) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(v, I64);\n            wasm.boxvalue_from_i64(retptr, v.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return BoxValue.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Get value as signed 64-bit long (I64)\n    * @returns {I64}\n    */\n    as_i64() {\n        var ret = wasm.boxvalue_as_i64(this.ptr);\n        return I64.__wrap(ret);\n    }\n    /**\n    * big-endian byte array representation\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.boxvalue_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n* Node info\n*/\nexport class ChromePeerDiscoveryScan {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ChromePeerDiscoveryScan.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_chromepeerdiscoveryscan_free(ptr);\n    }\n    /**\n    * Create new scan. Note: `seeds` must not be empty.\n    * @param {(URL)[]} seeds\n    */\n    constructor(seeds) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passArrayJsValueToWasm0(seeds, wasm.__wbindgen_malloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.chromepeerdiscoveryscan_new(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ChromePeerDiscoveryScan.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Returns list of non-seed peers with an active REST API.\n    * @returns {PeerUrls}\n    */\n    active_peers() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.chromepeerdiscoveryscan_active_peers(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return PeerUrls.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n* CommitmentHint\n*/\nexport class CommitmentHint {\n\n    static __wrap(ptr) {\n        const obj = Object.create(CommitmentHint.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_commitmenthint_free(ptr);\n    }\n}\n/**\n* Ergo constant(evaluated) values\n*/\nexport class Constant {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Constant.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_constant_free(ptr);\n    }\n    /**\n    * Returns the debug representation of the type of the constant\n    * @returns {string}\n    */\n    dbg_tpe() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.constant_dbg_tpe(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * Returns the debug representation of the value of the constant\n    * @returns {string}\n    */\n    dbg_inner() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.constant_dbg_inner(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * Decode from Base16-encoded ErgoTree serialized value\n    * @param {string} base16_bytes_str\n    * @returns {Constant}\n    */\n    static decode_from_base16(base16_bytes_str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(base16_bytes_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.constant_decode_from_base16(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Constant.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Encode as Base16-encoded ErgoTree serialized value or return an error if serialization\n    * failed\n    * @returns {string}\n    */\n    encode_to_base16() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.constant_encode_to_base16(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr0 = r0;\n            var len0 = r1;\n            if (r3) {\n                ptr0 = 0; len0 = 0;\n                throw takeObject(r2);\n            }\n            return getStringFromWasm0(ptr0, len0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(ptr0, len0);\n        }\n    }\n    /**\n    * Returns serialized bytes or fails with error if Constant cannot be serialized\n    * @returns {Uint8Array}\n    */\n    sigma_serialize_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.constant_sigma_serialize_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            if (r3) {\n                throw takeObject(r2);\n            }\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Create from i32 value\n    * @param {number} v\n    * @returns {Constant}\n    */\n    static from_i32(v) {\n        var ret = wasm.constant_from_i32(v);\n        return Constant.__wrap(ret);\n    }\n    /**\n    * Extract i32 value, returning error if wrong type\n    * @returns {number}\n    */\n    to_i32() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.constant_to_i32(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return r0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Create from i64\n    * @param {I64} v\n    * @returns {Constant}\n    */\n    static from_i64(v) {\n        _assertClass(v, I64);\n        var ret = wasm.constant_from_i64(v.ptr);\n        return Constant.__wrap(ret);\n    }\n    /**\n    * Extract i64 value, returning error if wrong type\n    * @returns {I64}\n    */\n    to_i64() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.constant_to_i64(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return I64.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Create BigInt constant from byte array (signed bytes bit-endian)\n    * @param {Uint8Array} num\n    * @returns {Constant}\n    */\n    static from_bigint_signed_bytes_be(num) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passArray8ToWasm0(num, wasm.__wbindgen_malloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.constant_from_bigint_signed_bytes_be(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Constant.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Create from byte array\n    * @param {Uint8Array} v\n    * @returns {Constant}\n    */\n    static from_byte_array(v) {\n        var ptr0 = passArray8ToWasm0(v, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.constant_from_byte_array(ptr0, len0);\n        return Constant.__wrap(ret);\n    }\n    /**\n    * Extract byte array, returning error if wrong type\n    * @returns {Uint8Array}\n    */\n    to_byte_array() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.constant_to_byte_array(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Create `Coll[Int]` from integer array\n    * @param {Int32Array} arr\n    * @returns {Constant}\n    */\n    static from_i32_array(arr) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passArray32ToWasm0(arr, wasm.__wbindgen_malloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.constant_from_i32_array(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Constant.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Extract `Coll[Int]` as integer array\n    * @returns {Int32Array}\n    */\n    to_i32_array() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.constant_to_i32_array(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            if (r3) {\n                throw takeObject(r2);\n            }\n            var v0 = getArrayI32FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 4);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Create `Coll[Long]` from string array\n    * @param {any[]} arr\n    * @returns {Constant}\n    */\n    static from_i64_str_array(arr) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passArrayJsValueToWasm0(arr, wasm.__wbindgen_malloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.constant_from_i64_str_array(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Constant.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Extract `Coll[Long]` as string array\n    * @returns {any[]}\n    */\n    to_i64_str_array() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.constant_to_i64_str_array(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            if (r3) {\n                throw takeObject(r2);\n            }\n            var v0 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 4);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Extract `Coll[Coll[Byte]]` as array of byte arrays\n    * @returns {(Uint8Array)[]}\n    */\n    to_coll_coll_byte() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.constant_to_coll_coll_byte(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            if (r3) {\n                throw takeObject(r2);\n            }\n            var v0 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 4);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Create `Coll[Coll[Byte]]` from array byte array\n    * @param {(Uint8Array)[]} arr\n    * @returns {Constant}\n    */\n    static from_coll_coll_byte(arr) {\n        var ptr0 = passArrayJsValueToWasm0(arr, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.constant_from_coll_coll_byte(ptr0, len0);\n        return Constant.__wrap(ret);\n    }\n    /**\n    * Parse raw `EcPoint` value from bytes and make `ProveDlog` constant\n    * @param {Uint8Array} bytes\n    * @returns {Constant}\n    */\n    static from_ecpoint_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.constant_from_ecpoint_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Constant.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Parse raw `EcPoint` value from bytes and make `GroupElement` constant\n    * @param {Uint8Array} bytes\n    * @returns {Constant}\n    */\n    static from_ecpoint_bytes_group_element(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.constant_from_ecpoint_bytes_group_element(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Constant.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Create `(Coll[Byte], Coll[Byte])` tuple Constant\n    * @param {Uint8Array} bytes1\n    * @param {Uint8Array} bytes2\n    * @returns {Constant}\n    */\n    static from_tuple_coll_bytes(bytes1, bytes2) {\n        var ptr0 = passArray8ToWasm0(bytes1, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ptr1 = passArray8ToWasm0(bytes2, wasm.__wbindgen_malloc);\n        var len1 = WASM_VECTOR_LEN;\n        var ret = wasm.constant_from_tuple_coll_bytes(ptr0, len0, ptr1, len1);\n        return Constant.__wrap(ret);\n    }\n    /**\n    * Extract `(Coll[Byte], Coll[Byte])` tuple from Constant as array of Uint8Array\n    * @returns {(Uint8Array)[]}\n    */\n    to_tuple_coll_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.constant_to_tuple_coll_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            if (r3) {\n                throw takeObject(r2);\n            }\n            var v0 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 4);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Create `(Int, Int)` tuple Constant\n    * @returns {any[]}\n    */\n    to_tuple_i32() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.constant_to_tuple_i32(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            if (r3) {\n                throw takeObject(r2);\n            }\n            var v0 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 4);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Create `(Long, Long)` tuple Constant\n    * @param {I64} l1\n    * @param {I64} l2\n    * @returns {Constant}\n    */\n    static from_tuple_i64(l1, l2) {\n        _assertClass(l1, I64);\n        _assertClass(l2, I64);\n        var ret = wasm.constant_from_tuple_i64(l1.ptr, l2.ptr);\n        return Constant.__wrap(ret);\n    }\n    /**\n    * Extract `(Long, Long)` tuple from Constant as array of strings\n    * @returns {any[]}\n    */\n    to_tuple_i64() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.constant_to_tuple_i64(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            if (r3) {\n                throw takeObject(r2);\n            }\n            var v0 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 4);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Create from ErgoBox value\n    * @param {ErgoBox} v\n    * @returns {Constant}\n    */\n    static from_ergo_box(v) {\n        _assertClass(v, ErgoBox);\n        var ret = wasm.constant_from_ergo_box(v.ptr);\n        return Constant.__wrap(ret);\n    }\n    /**\n    * Extract ErgoBox value, returning error if wrong type\n    * @returns {ErgoBox}\n    */\n    to_ergo_box() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.constant_to_ergo_box(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ErgoBox.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Create Constant with Unit value\n    * @returns {Constant}\n    */\n    static unit() {\n        var ret = wasm.constant_unit();\n        return Constant.__wrap(ret);\n    }\n    /**\n    * Returns true if constant value is Unit\n    * @returns {boolean}\n    */\n    is_unit() {\n        var ret = wasm.constant_is_unit(this.ptr);\n        return ret !== 0;\n    }\n    /**\n    * Create a Constant from JS value\n    * JS types are converted to the following Ergo types:\n    * Number -> Int,\n    * String -> Long,\n    * BigInt -> BigInt,\n    * use array_as_tuple() to encode Ergo tuples\n    * @param {any} value\n    * @returns {Constant}\n    */\n    static from_js(value) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.constant_from_js(retptr, addBorrowedObject(value));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Constant.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Extract JS value from Constant\n    * Ergo types are converted to the following JS types:\n    * Byte -> Number,\n    * Short -> Number,\n    * Int -> Number,\n    * Long -> String,\n    * BigInt -> BigInt,\n    * Ergo tuples are encoded as arrays\n    * @returns {any}\n    */\n    to_js() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.constant_to_js(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n* User-defined variables to be put into context\n*/\nexport class ContextExtension {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ContextExtension.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_contextextension_free(ptr);\n    }\n    /**\n    * Create new ContextExtension instance\n    */\n    constructor() {\n        var ret = wasm.contextextension_new();\n        return ContextExtension.__wrap(ret);\n    }\n    /**\n    * Set the supplied pair in the ContextExtension\n    * @param {number} id\n    * @param {Constant} value\n    */\n    set_pair(id, value) {\n        _assertClass(value, Constant);\n        wasm.contextextension_set_pair(this.ptr, id, value.ptr);\n    }\n    /**\n    * Returns the number of elements in the collection\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.contextextension_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * get from map or fail if key is missing\n    * @param {number} key\n    * @returns {Constant}\n    */\n    get(key) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.contextextension_get(retptr, this.ptr, key);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Constant.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Returns all keys in the map\n    * @returns {Uint8Array}\n    */\n    keys() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.contextextension_keys(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Returns serialized bytes or fails with error if ContextExtension cannot be serialized\n    * @returns {Uint8Array}\n    */\n    sigma_serialize_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.contextextension_sigma_serialize_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            if (r3) {\n                throw takeObject(r2);\n            }\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n* Defines the contract(script) that will be guarding box contents\n*/\nexport class Contract {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Contract.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_contract_free(ptr);\n    }\n    /**\n    * Create new contract from ErgoTree\n    * @param {ErgoTree} ergo_tree\n    * @returns {Contract}\n    */\n    static new(ergo_tree) {\n        _assertClass(ergo_tree, ErgoTree);\n        var ptr0 = ergo_tree.ptr;\n        ergo_tree.ptr = 0;\n        var ret = wasm.contract_new(ptr0);\n        return Contract.__wrap(ret);\n    }\n    /**\n    * create new contract that allow spending of the guarded box by a given recipient ([`Address`])\n    * @param {Address} recipient\n    * @returns {Contract}\n    */\n    static pay_to_address(recipient) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(recipient, Address);\n            wasm.contract_pay_to_address(retptr, recipient.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Contract.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Compiles a contract from ErgoScript source code\n    * @param {string} source\n    * @returns {Contract}\n    */\n    static compile(source) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(source, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.contract_compile(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Contract.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Get the ErgoTree of the contract\n    * @returns {ErgoTree}\n    */\n    ergo_tree() {\n        var ret = wasm.contract_ergo_tree(this.ptr);\n        return ErgoTree.__wrap(ret);\n    }\n}\n/**\n* Inputs, that are used to enrich script context, but won't be spent by the transaction\n*/\nexport class DataInput {\n\n    static __wrap(ptr) {\n        const obj = Object.create(DataInput.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_datainput_free(ptr);\n    }\n    /**\n    * Parse box id (32 byte digest) from base16-encoded string\n    * @param {BoxId} box_id\n    */\n    constructor(box_id) {\n        _assertClass(box_id, BoxId);\n        var ptr0 = box_id.ptr;\n        box_id.ptr = 0;\n        var ret = wasm.datainput_new(ptr0);\n        return DataInput.__wrap(ret);\n    }\n    /**\n    * Get box id\n    * @returns {BoxId}\n    */\n    box_id() {\n        var ret = wasm.datainput_box_id(this.ptr);\n        return BoxId.__wrap(ret);\n    }\n}\n/**\n* DataInput collection\n*/\nexport class DataInputs {\n\n    static __wrap(ptr) {\n        const obj = Object.create(DataInputs.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_datainputs_free(ptr);\n    }\n    /**\n    * Create empty DataInputs\n    */\n    constructor() {\n        var ret = wasm.datainputs_new();\n        return DataInputs.__wrap(ret);\n    }\n    /**\n    * Returns the number of elements in the collection\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.datainputs_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Returns the element of the collection with a given index\n    * @param {number} index\n    * @returns {DataInput}\n    */\n    get(index) {\n        var ret = wasm.datainputs_get(this.ptr, index);\n        return DataInput.__wrap(ret);\n    }\n    /**\n    * Adds an elements to the collection\n    * @param {DataInput} elem\n    */\n    add(elem) {\n        _assertClass(elem, DataInput);\n        wasm.datainputs_add(this.ptr, elem.ptr);\n    }\n}\n/**\n* According to\n* BIP-44 <https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki>\n* and EIP-3 <https://github.com/ergoplatform/eips/blob/master/eip-0003.md>\n*/\nexport class DerivationPath {\n\n    static __wrap(ptr) {\n        const obj = Object.create(DerivationPath.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_derivationpath_free(ptr);\n    }\n    /**\n    * Create derivation path for a given account index (hardened) and address indices\n    * `m / 44' / 429' / acc' / 0 / address[0] / address[1] / ...`\n    * or `m / 44' / 429' / acc' / 0` if address indices are empty\n    * change is always zero according to EIP-3\n    * acc is expected as a 31-bit value (32th bit should not be set)\n    * @param {number} acc\n    * @param {Uint32Array} address_indices\n    * @returns {DerivationPath}\n    */\n    static new(acc, address_indices) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passArray32ToWasm0(address_indices, wasm.__wbindgen_malloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.derivationpath_new(retptr, acc, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return DerivationPath.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Create root derivation path\n    * @returns {DerivationPath}\n    */\n    static master_path() {\n        var ret = wasm.derivationpath_master_path();\n        return DerivationPath.__wrap(ret);\n    }\n    /**\n    * Returns the length of the derivation path\n    * @returns {number}\n    */\n    depth() {\n        var ret = wasm.derivationpath_depth(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Returns a new path with the last element of the deriviation path being increased, e.g. m/1/2 -> m/1/3\n    * Returns an empty path error if the path is empty (master node)\n    * @returns {DerivationPath}\n    */\n    next() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.derivationpath_next(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return DerivationPath.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * String representation of derivation path\n    * E.g m/44'/429'/0'/0/1\n    * @returns {string}\n    */\n    toString() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.derivationpath_toString(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * Create a derivation path from a formatted string\n    * E.g \"m/44'/429'/0'/0/1\"\n    * @param {string} path\n    * @returns {DerivationPath}\n    */\n    static from_string(path) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(path, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.derivationpath_from_string(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return DerivationPath.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * For 0x21 Sign Transaction command of Ergo Ledger App Protocol\n    * P2PK Sign (0x0D) instruction\n    * Sign calculated TX hash with private key for provided BIP44 path.\n    * Data:\n    *\n    * Field\n    * Size (B)\n    * Description\n    *\n    * BIP32 path length\n    * 1\n    * Value: 0x02-0x0A (2-10). Number of path components\n    *\n    * First derivation index\n    * 4\n    * Big-endian. Value: 44’\n    *\n    * Second derivation index\n    * 4\n    * Big-endian. Value: 429’ (Ergo coin id)\n    *\n    * Optional Third index\n    * 4\n    * Big-endian. Any valid bip44 hardened value.\n    * ...\n    * Optional Last index\n    * 4\n    * Big-endian. Any valid bip44 value.\n    * @returns {Uint8Array}\n    */\n    ledger_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.derivationpath_ledger_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n* Ergo box, that is taking part in some transaction on the chain\n* Differs with [`ErgoBoxCandidate`] by added transaction id and an index in the input of that transaction\n*/\nexport class ErgoBox {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ErgoBox.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_ergobox_free(ptr);\n    }\n    /**\n    * make a new box with:\n    * `value` - amount of money associated with the box\n    * `contract` - guarding contract([`Contract`]), which should be evaluated to true in order\n    * to open(spend) this box\n    * `creation_height` - height when a transaction containing the box is created.\n    * `tx_id` - transaction id in which this box was \"created\" (participated in outputs)\n    * `index` - index (in outputs) in the transaction\n    * @param {BoxValue} value\n    * @param {number} creation_height\n    * @param {Contract} contract\n    * @param {TxId} tx_id\n    * @param {number} index\n    * @param {Tokens} tokens\n    */\n    constructor(value, creation_height, contract, tx_id, index, tokens) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(value, BoxValue);\n            _assertClass(contract, Contract);\n            _assertClass(tx_id, TxId);\n            _assertClass(tokens, Tokens);\n            wasm.ergobox_new(retptr, value.ptr, creation_height, contract.ptr, tx_id.ptr, index, tokens.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ErgoBox.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Get box id\n    * @returns {BoxId}\n    */\n    box_id() {\n        var ret = wasm.ergobox_box_id(this.ptr);\n        return BoxId.__wrap(ret);\n    }\n    /**\n    * Get id of transaction which created the box\n    * @returns {TxId}\n    */\n    tx_id() {\n        var ret = wasm.ergobox_tx_id(this.ptr);\n        return TxId.__wrap(ret);\n    }\n    /**\n    * Index of this box in transaction outputs\n    * @returns {number}\n    */\n    index() {\n        var ret = wasm.ergobox_index(this.ptr);\n        return ret;\n    }\n    /**\n    * Get box creation height\n    * @returns {number}\n    */\n    creation_height() {\n        var ret = wasm.ergobox_creation_height(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Get tokens for box\n    * @returns {Tokens}\n    */\n    tokens() {\n        var ret = wasm.ergobox_tokens(this.ptr);\n        return Tokens.__wrap(ret);\n    }\n    /**\n    * Get ergo tree for box\n    * @returns {ErgoTree}\n    */\n    ergo_tree() {\n        var ret = wasm.ergobox_ergo_tree(this.ptr);\n        return ErgoTree.__wrap(ret);\n    }\n    /**\n    * Get box value in nanoERGs\n    * @returns {BoxValue}\n    */\n    value() {\n        var ret = wasm.ergobox_value(this.ptr);\n        return BoxValue.__wrap(ret);\n    }\n    /**\n    * Returns value (ErgoTree constant) stored in the register or None if the register is empty\n    * @param {number} register_id\n    * @returns {Constant | undefined}\n    */\n    register_value(register_id) {\n        var ret = wasm.ergobox_register_value(this.ptr, register_id);\n        return ret === 0 ? undefined : Constant.__wrap(ret);\n    }\n    /**\n    * JSON representation as text (compatible with Ergo Node/Explorer API, numbers are encoded as numbers)\n    * @returns {string}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ergobox_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr0 = r0;\n            var len0 = r1;\n            if (r3) {\n                ptr0 = 0; len0 = 0;\n                throw takeObject(r2);\n            }\n            return getStringFromWasm0(ptr0, len0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(ptr0, len0);\n        }\n    }\n    /**\n    * JSON representation according to EIP-12 <https://github.com/ergoplatform/eips/pull/23>\n    * (similar to [`Self::to_json`], but as JS object with box value and token amounts encoding as strings)\n    * @returns {any}\n    */\n    to_js_eip12() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ergobox_to_js_eip12(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * parse from JSON\n    * supports Ergo Node/Explorer API and box values and token amount encoded as strings\n    * @param {string} json\n    * @returns {ErgoBox}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.ergobox_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ErgoBox.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Serialized additional register as defined in ErgoBox serialization (registers count,\n    * followed by every non-empyt register value serialized)\n    * @returns {Uint8Array}\n    */\n    serialized_additional_registers() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ergobox_serialized_additional_registers(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            if (r3) {\n                throw takeObject(r2);\n            }\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Returns serialized bytes or fails with error if cannot be serialized\n    * @returns {Uint8Array}\n    */\n    sigma_serialize_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ergobox_sigma_serialize_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            if (r3) {\n                throw takeObject(r2);\n            }\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Parses ErgoBox or fails with error\n    * @param {Uint8Array} data\n    * @returns {ErgoBox}\n    */\n    static sigma_parse_bytes(data) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passArray8ToWasm0(data, wasm.__wbindgen_malloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.ergobox_sigma_parse_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ErgoBox.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n* Pair of <value, tokens> for an box\n*/\nexport class ErgoBoxAssetsData {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ErgoBoxAssetsData.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_ergoboxassetsdata_free(ptr);\n    }\n    /**\n    * Create new instance\n    * @param {BoxValue} value\n    * @param {Tokens} tokens\n    */\n    constructor(value, tokens) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(value, BoxValue);\n            _assertClass(tokens, Tokens);\n            wasm.ergoboxassetsdata_new(retptr, value.ptr, tokens.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ErgoBoxAssetsData.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Value part of the box\n    * @returns {BoxValue}\n    */\n    value() {\n        var ret = wasm.ergoboxassetsdata_value(this.ptr);\n        return BoxValue.__wrap(ret);\n    }\n    /**\n    * Tokens part of the box\n    * @returns {Tokens}\n    */\n    tokens() {\n        var ret = wasm.ergoboxassetsdata_tokens(this.ptr);\n        return Tokens.__wrap(ret);\n    }\n}\n/**\n* List of asset data for a box\n*/\nexport class ErgoBoxAssetsDataList {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ErgoBoxAssetsDataList.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_ergoboxassetsdatalist_free(ptr);\n    }\n    /**\n    * Create empty Tokens\n    */\n    constructor() {\n        var ret = wasm.ergoboxassetsdatalist_new();\n        return ErgoBoxAssetsDataList.__wrap(ret);\n    }\n    /**\n    * Returns the number of elements in the collection\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.ergoboxassetsdatalist_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Returns the element of the collection with a given index\n    * @param {number} index\n    * @returns {ErgoBoxAssetsData}\n    */\n    get(index) {\n        var ret = wasm.ergoboxassetsdatalist_get(this.ptr, index);\n        return ErgoBoxAssetsData.__wrap(ret);\n    }\n    /**\n    * Adds an elements to the collection\n    * @param {ErgoBoxAssetsData} elem\n    */\n    add(elem) {\n        _assertClass(elem, ErgoBoxAssetsData);\n        wasm.ergoboxassetsdatalist_add(this.ptr, elem.ptr);\n    }\n}\n/**\n* ErgoBox candidate not yet included in any transaction on the chain\n*/\nexport class ErgoBoxCandidate {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ErgoBoxCandidate.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_ergoboxcandidate_free(ptr);\n    }\n    /**\n    * Create a box with miner's contract and given value\n    * @param {BoxValue} fee_amount\n    * @param {number} creation_height\n    * @returns {ErgoBoxCandidate}\n    */\n    static new_miner_fee_box(fee_amount, creation_height) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(fee_amount, BoxValue);\n            wasm.ergoboxcandidate_new_miner_fee_box(retptr, fee_amount.ptr, creation_height);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ErgoBoxCandidate.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Returns value (ErgoTree constant) stored in the register or None if the register is empty\n    * @param {number} register_id\n    * @returns {Constant | undefined}\n    */\n    register_value(register_id) {\n        var ret = wasm.ergoboxcandidate_register_value(this.ptr, register_id);\n        return ret === 0 ? undefined : Constant.__wrap(ret);\n    }\n    /**\n    * Get box creation height\n    * @returns {number}\n    */\n    creation_height() {\n        var ret = wasm.ergoboxcandidate_creation_height(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Get tokens for box\n    * @returns {Tokens}\n    */\n    tokens() {\n        var ret = wasm.ergoboxcandidate_tokens(this.ptr);\n        return Tokens.__wrap(ret);\n    }\n    /**\n    * Get ergo tree for box\n    * @returns {ErgoTree}\n    */\n    ergo_tree() {\n        var ret = wasm.ergoboxcandidate_ergo_tree(this.ptr);\n        return ErgoTree.__wrap(ret);\n    }\n    /**\n    * Get box value in nanoERGs\n    * @returns {BoxValue}\n    */\n    value() {\n        var ret = wasm.ergoboxcandidate_value(this.ptr);\n        return BoxValue.__wrap(ret);\n    }\n    /**\n    * Serialized additional register as defined in ErgoBox serialization (registers count,\n    * followed by every non-empyt register value serialized)\n    * @returns {Uint8Array}\n    */\n    serialized_additional_registers() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ergoboxcandidate_serialized_additional_registers(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            if (r3) {\n                throw takeObject(r2);\n            }\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n* ErgoBoxCandidate builder\n*/\nexport class ErgoBoxCandidateBuilder {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ErgoBoxCandidateBuilder.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_ergoboxcandidatebuilder_free(ptr);\n    }\n    /**\n    * Create builder with required box parameters:\n    * `value` - amount of money associated with the box\n    * `contract` - guarding contract([`Contract`]), which should be evaluated to true in order\n    * to open(spend) this box\n    * `creation_height` - height when a transaction containing the box is created.\n    * It should not exceed height of the block, containing the transaction with this box.\n    * @param {BoxValue} value\n    * @param {Contract} contract\n    * @param {number} creation_height\n    */\n    constructor(value, contract, creation_height) {\n        _assertClass(value, BoxValue);\n        _assertClass(contract, Contract);\n        var ret = wasm.ergoboxcandidatebuilder_new(value.ptr, contract.ptr, creation_height);\n        return ErgoBoxCandidateBuilder.__wrap(ret);\n    }\n    /**\n    * Set minimal value (per byte of the serialized box size)\n    * @param {number} new_min_value_per_byte\n    */\n    set_min_box_value_per_byte(new_min_value_per_byte) {\n        wasm.ergoboxcandidatebuilder_set_min_box_value_per_byte(this.ptr, new_min_value_per_byte);\n    }\n    /**\n    * Get minimal value (per byte of the serialized box size)\n    * @returns {number}\n    */\n    min_box_value_per_byte() {\n        var ret = wasm.ergoboxcandidatebuilder_min_box_value_per_byte(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Set new box value\n    * @param {BoxValue} new_value\n    */\n    set_value(new_value) {\n        _assertClass(new_value, BoxValue);\n        var ptr0 = new_value.ptr;\n        new_value.ptr = 0;\n        wasm.ergoboxcandidatebuilder_set_value(this.ptr, ptr0);\n    }\n    /**\n    * Get box value\n    * @returns {BoxValue}\n    */\n    value() {\n        var ret = wasm.ergoboxcandidatebuilder_value(this.ptr);\n        return BoxValue.__wrap(ret);\n    }\n    /**\n    * Calculate serialized box size(in bytes)\n    * @returns {number}\n    */\n    calc_box_size_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ergoboxcandidatebuilder_calc_box_size_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return r0 >>> 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Calculate minimal box value for the current box serialized size(in bytes)\n    * @returns {BoxValue}\n    */\n    calc_min_box_value() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ergoboxcandidatebuilder_calc_min_box_value(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return BoxValue.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Set register with a given id (R4-R9) to the given value\n    * @param {number} register_id\n    * @param {Constant} value\n    */\n    set_register_value(register_id, value) {\n        _assertClass(value, Constant);\n        wasm.ergoboxcandidatebuilder_set_register_value(this.ptr, register_id, value.ptr);\n    }\n    /**\n    * Returns register value for the given register id (R4-R9), or None if the register is empty\n    * @param {number} register_id\n    * @returns {Constant | undefined}\n    */\n    register_value(register_id) {\n        var ret = wasm.ergoboxcandidatebuilder_register_value(this.ptr, register_id);\n        return ret === 0 ? undefined : Constant.__wrap(ret);\n    }\n    /**\n    * Delete register value(make register empty) for the given register id (R4-R9)\n    * @param {number} register_id\n    */\n    delete_register_value(register_id) {\n        wasm.ergoboxcandidatebuilder_delete_register_value(this.ptr, register_id);\n    }\n    /**\n    * Mint token, as defined in <https://github.com/ergoplatform/eips/blob/master/eip-0004.md>\n    * `token` - token id(box id of the first input box in transaction) and token amount,\n    * `token_name` - token name (will be encoded in R4),\n    * `token_desc` - token description (will be encoded in R5),\n    * `num_decimals` - number of decimals (will be encoded in R6)\n    * @param {Token} token\n    * @param {string} token_name\n    * @param {string} token_desc\n    * @param {number} num_decimals\n    */\n    mint_token(token, token_name, token_desc, num_decimals) {\n        _assertClass(token, Token);\n        var ptr0 = passStringToWasm0(token_name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ptr1 = passStringToWasm0(token_desc, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len1 = WASM_VECTOR_LEN;\n        wasm.ergoboxcandidatebuilder_mint_token(this.ptr, token.ptr, ptr0, len0, ptr1, len1, num_decimals);\n    }\n    /**\n    * Add given token id and token amount\n    * @param {TokenId} token_id\n    * @param {TokenAmount} amount\n    */\n    add_token(token_id, amount) {\n        _assertClass(token_id, TokenId);\n        _assertClass(amount, TokenAmount);\n        wasm.ergoboxcandidatebuilder_add_token(this.ptr, token_id.ptr, amount.ptr);\n    }\n    /**\n    * Build the box candidate\n    * @returns {ErgoBoxCandidate}\n    */\n    build() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ergoboxcandidatebuilder_build(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ErgoBoxCandidate.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n* Collection of ErgoBoxCandidates\n*/\nexport class ErgoBoxCandidates {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ErgoBoxCandidates.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_ergoboxcandidates_free(ptr);\n    }\n    /**\n    * Create new outputs\n    * @param {ErgoBoxCandidate} box_candidate\n    */\n    constructor(box_candidate) {\n        _assertClass(box_candidate, ErgoBoxCandidate);\n        var ret = wasm.ergoboxcandidates_new(box_candidate.ptr);\n        return ErgoBoxCandidates.__wrap(ret);\n    }\n    /**\n    * sometimes it's useful to keep track of an empty list\n    * but keep in mind Ergo transactions need at least 1 output\n    * @returns {ErgoBoxCandidates}\n    */\n    static empty() {\n        var ret = wasm.ergoboxcandidates_empty();\n        return ErgoBoxCandidates.__wrap(ret);\n    }\n    /**\n    * Returns the number of elements in the collection\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.ergoboxcandidates_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Returns the element of the collection with a given index\n    * @param {number} index\n    * @returns {ErgoBoxCandidate}\n    */\n    get(index) {\n        var ret = wasm.ergoboxcandidates_get(this.ptr, index);\n        return ErgoBoxCandidate.__wrap(ret);\n    }\n    /**\n    * Add an element to the collection\n    * @param {ErgoBoxCandidate} b\n    */\n    add(b) {\n        _assertClass(b, ErgoBoxCandidate);\n        wasm.ergoboxcandidates_add(this.ptr, b.ptr);\n    }\n}\n/**\n* Collection of ErgoBox'es\n*/\nexport class ErgoBoxes {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ErgoBoxes.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_ergoboxes_free(ptr);\n    }\n    /**\n    * parse ErgoBox array from json\n    * @param {any[]} json_vals\n    * @returns {ErgoBoxes}\n    */\n    static from_boxes_json(json_vals) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passArrayJsValueToWasm0(json_vals, wasm.__wbindgen_malloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.ergoboxes_from_boxes_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ErgoBoxes.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Create new collection with one element\n    * @param {ErgoBox} b\n    */\n    constructor(b) {\n        _assertClass(b, ErgoBox);\n        var ret = wasm.ergoboxes_new(b.ptr);\n        return ErgoBoxes.__wrap(ret);\n    }\n    /**\n    * Returns the number of elements in the collection\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.ergoboxes_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Add an element to the collection\n    * @param {ErgoBox} b\n    */\n    add(b) {\n        _assertClass(b, ErgoBox);\n        wasm.ergoboxes_add(this.ptr, b.ptr);\n    }\n    /**\n    * Returns the element of the collection with a given index\n    * @param {number} index\n    * @returns {ErgoBox}\n    */\n    get(index) {\n        var ret = wasm.ergoboxes_get(this.ptr, index);\n        return ErgoBox.__wrap(ret);\n    }\n    /**\n    * Empty ErgoBoxes\n    * @returns {ErgoBoxes}\n    */\n    static empty() {\n        var ret = wasm.ergoboxes_empty();\n        return ErgoBoxes.__wrap(ret);\n    }\n}\n/**\n* Blockchain state (last headers, etc.)\n*/\nexport class ErgoStateContext {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ErgoStateContext.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_ergostatecontext_free(ptr);\n    }\n    /**\n    * Create new context from pre-header\n    * @param {PreHeader} pre_header\n    * @param {BlockHeaders} headers\n    */\n    constructor(pre_header, headers) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(pre_header, PreHeader);\n            var ptr0 = pre_header.ptr;\n            pre_header.ptr = 0;\n            _assertClass(headers, BlockHeaders);\n            var ptr1 = headers.ptr;\n            headers.ptr = 0;\n            wasm.ergostatecontext_new(retptr, ptr0, ptr1);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ErgoStateContext.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n* The root of ErgoScript IR. Serialized instances of this class are self sufficient and can be passed around.\n*/\nexport class ErgoTree {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ErgoTree.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_ergotree_free(ptr);\n    }\n    /**\n    * Decode from base16 encoded serialized ErgoTree\n    * @param {string} s\n    * @returns {ErgoTree}\n    */\n    static from_base16_bytes(s) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(s, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.ergotree_from_base16_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ErgoTree.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Decode from encoded serialized ErgoTree\n    * @param {Uint8Array} data\n    * @returns {ErgoTree}\n    */\n    static from_bytes(data) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passArray8ToWasm0(data, wasm.__wbindgen_malloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.ergotree_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ErgoTree.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Returns serialized bytes or fails with error if ErgoTree cannot be serialized\n    * @returns {Uint8Array}\n    */\n    sigma_serialize_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ergotree_sigma_serialize_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            if (r3) {\n                throw takeObject(r2);\n            }\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Returns Base16-encoded serialized bytes\n    * @returns {string}\n    */\n    to_base16_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ergotree_to_base16_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr0 = r0;\n            var len0 = r1;\n            if (r3) {\n                ptr0 = 0; len0 = 0;\n                throw takeObject(r2);\n            }\n            return getStringFromWasm0(ptr0, len0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(ptr0, len0);\n        }\n    }\n    /**\n    * Returns constants number as stored in serialized ErgoTree or error if the parsing of\n    * constants is failed\n    * @returns {number}\n    */\n    constants_len() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ergotree_constants_len(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return r0 >>> 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Returns constant with given index (as stored in serialized ErgoTree)\n    * or None if index is out of bounds\n    * or error if constants parsing were failed\n    * @param {number} index\n    * @returns {Constant | undefined}\n    */\n    get_constant(index) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ergotree_get_constant(retptr, this.ptr, index);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return r0 === 0 ? undefined : Constant.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Consumes the calling ErgoTree and returns new ErgoTree with a new constant value\n    * for a given index in constants list (as stored in serialized ErgoTree), or an error.\n    * After the call the calling ErgoTree will be null.\n    * @param {number} index\n    * @param {Constant} constant\n    * @returns {ErgoTree}\n    */\n    with_constant(index, constant) {\n        try {\n            const ptr = this.__destroy_into_raw();\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(constant, Constant);\n            wasm.ergotree_with_constant(retptr, ptr, index, constant.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ErgoTree.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Serialized proposition expression of SigmaProp type with\n    * ConstantPlaceholder nodes instead of Constant nodes\n    * @returns {Uint8Array}\n    */\n    template_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ergotree_template_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            if (r3) {\n                throw takeObject(r2);\n            }\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n* Extented public key implemented according to BIP-32\n*/\nexport class ExtPubKey {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ExtPubKey.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_extpubkey_free(ptr);\n    }\n    /**\n    * Create ExtPubKey from public key bytes (from SEC1 compressed), chain code and derivation\n    * path\n    * @param {Uint8Array} public_key_bytes\n    * @param {Uint8Array} chain_code\n    * @param {DerivationPath} derivation_path\n    * @returns {ExtPubKey}\n    */\n    static new(public_key_bytes, chain_code, derivation_path) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passArray8ToWasm0(public_key_bytes, wasm.__wbindgen_malloc);\n            var len0 = WASM_VECTOR_LEN;\n            var ptr1 = passArray8ToWasm0(chain_code, wasm.__wbindgen_malloc);\n            var len1 = WASM_VECTOR_LEN;\n            _assertClass(derivation_path, DerivationPath);\n            wasm.extpubkey_new(retptr, ptr0, len0, ptr1, len1, derivation_path.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ExtPubKey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Soft derivation of the child public key with a given index\n    * index is expected to be a 31-bit value(32th bit should not be set)\n    * @param {number} index\n    * @returns {ExtPubKey}\n    */\n    child(index) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.extpubkey_child(retptr, this.ptr, index);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ExtPubKey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Derive a new extended pub key from the derivation path\n    * @param {DerivationPath} path\n    * @returns {ExtPubKey}\n    */\n    derive(path) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(path, DerivationPath);\n            var ptr0 = path.ptr;\n            path.ptr = 0;\n            wasm.extpubkey_derive(retptr, this.ptr, ptr0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ExtPubKey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Create address (P2PK) from this extended public key\n    * @returns {Address}\n    */\n    to_address() {\n        var ret = wasm.extpubkey_to_address(this.ptr);\n        return Address.__wrap(ret);\n    }\n    /**\n    * Chain code of the `ExtPubKey`\n    * @returns {Uint8Array}\n    */\n    chain_code() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.extpubkey_chain_code(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Public key bytes of the `ExtPubKey`\n    * @returns {Uint8Array}\n    */\n    pub_key_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.extpubkey_pub_key_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n* Extented secret key implemented according to BIP-32\n*/\nexport class ExtSecretKey {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ExtSecretKey.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_extsecretkey_free(ptr);\n    }\n    /**\n    * Create ExtSecretKey from secret key bytes, chain code and derivation path\n    * @param {Uint8Array} secret_key_bytes\n    * @param {Uint8Array} chain_code\n    * @param {DerivationPath} derivation_path\n    * @returns {ExtSecretKey}\n    */\n    static new(secret_key_bytes, chain_code, derivation_path) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passArray8ToWasm0(secret_key_bytes, wasm.__wbindgen_malloc);\n            var len0 = WASM_VECTOR_LEN;\n            var ptr1 = passArray8ToWasm0(chain_code, wasm.__wbindgen_malloc);\n            var len1 = WASM_VECTOR_LEN;\n            _assertClass(derivation_path, DerivationPath);\n            wasm.extsecretkey_new(retptr, ptr0, len0, ptr1, len1, derivation_path.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ExtSecretKey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Derive root extended secret key\n    * @param {Uint8Array} seed_bytes\n    * @returns {ExtSecretKey}\n    */\n    static derive_master(seed_bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passArray8ToWasm0(seed_bytes, wasm.__wbindgen_malloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.extsecretkey_derive_master(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ExtSecretKey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Derive a new extended secret key from the provided index\n    * The index is in the form of soft or hardened indices\n    * For example: 4 or 4' respectively\n    * @param {string} index\n    * @returns {ExtSecretKey}\n    */\n    child(index) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(index, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.extsecretkey_child(retptr, this.ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ExtSecretKey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Derive a new extended secret key from the derivation path\n    * @param {DerivationPath} path\n    * @returns {ExtSecretKey}\n    */\n    derive(path) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(path, DerivationPath);\n            var ptr0 = path.ptr;\n            path.ptr = 0;\n            wasm.extsecretkey_derive(retptr, this.ptr, ptr0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ExtSecretKey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * The bytes of the associated secret key\n    * @returns {Uint8Array}\n    */\n    secret_key_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.extsecretkey_secret_key_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            if (r3) {\n                throw takeObject(r2);\n            }\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * The extended public key associated with this secret key\n    * @returns {ExtPubKey}\n    */\n    public_key() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.extsecretkey_public_key(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ExtPubKey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Derivation path associated with the ext secret key\n    * @returns {DerivationPath}\n    */\n    path() {\n        var ret = wasm.extsecretkey_path(this.ptr);\n        return DerivationPath.__wrap(ret);\n    }\n}\n/**\n* HintsBag\n*/\nexport class HintsBag {\n\n    static __wrap(ptr) {\n        const obj = Object.create(HintsBag.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_hintsbag_free(ptr);\n    }\n    /**\n    * Empty HintsBag\n    * @returns {HintsBag}\n    */\n    static empty() {\n        var ret = wasm.hintsbag_empty();\n        return HintsBag.__wrap(ret);\n    }\n    /**\n    * Add commitment hint to the bag\n    * @param {CommitmentHint} hint\n    */\n    add_commitment(hint) {\n        _assertClass(hint, CommitmentHint);\n        var ptr0 = hint.ptr;\n        hint.ptr = 0;\n        wasm.hintsbag_add_commitment(this.ptr, ptr0);\n    }\n    /**\n    * Length of HintsBag\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.hintsbag_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Get commitment\n    * @param {number} index\n    * @returns {CommitmentHint}\n    */\n    get(index) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.hintsbag_get(retptr, this.ptr, index);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return CommitmentHint.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n* Wrapper for i64 for JS/TS because JS Number can only represent 53 bits\n* see <https://stackoverflow.com/questions/17320706/javascript-long-integer>\n*/\nexport class I64 {\n\n    static __wrap(ptr) {\n        const obj = Object.create(I64.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_i64_free(ptr);\n    }\n    /**\n    * Create from a standard rust string representation\n    * @param {string} string\n    * @returns {I64}\n    */\n    static from_str(string) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(string, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.i64_from_str(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return I64.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * String representation of the value for use from environments that don't support i64\n    * @returns {string}\n    */\n    to_str() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.i64_to_str(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * Get the value as JS number (64-bit float)\n    * @returns {number}\n    */\n    as_num() {\n        var ret = wasm.i64_as_num(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * Addition with overflow check\n    * @param {I64} other\n    * @returns {I64}\n    */\n    checked_add(other) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(other, I64);\n            wasm.i64_checked_add(retptr, this.ptr, other.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return I64.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n* Signed inputs used in signed transactions\n*/\nexport class Input {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Input.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_input_free(ptr);\n    }\n    /**\n    * Get box id\n    * @returns {BoxId}\n    */\n    box_id() {\n        var ret = wasm.input_box_id(this.ptr);\n        return BoxId.__wrap(ret);\n    }\n    /**\n    * Get the spending proof\n    * @returns {ProverResult}\n    */\n    spending_proof() {\n        var ret = wasm.input_spending_proof(this.ptr);\n        return ProverResult.__wrap(ret);\n    }\n}\n/**\n* Collection of signed inputs\n*/\nexport class Inputs {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Inputs.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_inputs_free(ptr);\n    }\n    /**\n    * Create empty Inputs\n    */\n    constructor() {\n        var ret = wasm.inputs_new();\n        return Inputs.__wrap(ret);\n    }\n    /**\n    * Returns the number of elements in the collection\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.inputs_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Returns the element of the collection with a given index\n    * @param {number} index\n    * @returns {Input}\n    */\n    get(index) {\n        var ret = wasm.inputs_get(this.ptr, index);\n        return Input.__wrap(ret);\n    }\n}\n/**\n* A level node in a merkle proof\n*/\nexport class LevelNode {\n\n    static __wrap(ptr) {\n        const obj = Object.create(LevelNode.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_levelnode_free(ptr);\n    }\n    /**\n    * Creates a new LevelNode from a 32 byte hash and side that the node belongs on in the tree. Fails if the digest is not 32 bytes\n    * @param {Uint8Array} hash\n    * @param {number} side\n    * @returns {LevelNode}\n    */\n    static new(hash, side) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passArray8ToWasm0(hash, wasm.__wbindgen_malloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.levelnode_new(retptr, ptr0, len0, side);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return LevelNode.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Returns the associated digest (hash) with this node. Returns an empty array if there's no hash\n    * @returns {Uint8Array}\n    */\n    get digest() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.levelnode_digest(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Returns the associated side with this node (0 = Left, 1 = Right)\n    * @returns {number}\n    */\n    get side() {\n        var ret = wasm.levelnode_side(this.ptr);\n        return ret;\n    }\n}\n/**\n* A MerkleProof type. Given leaf data and levels (bottom-upwards), the root hash can be computed and validated\n*/\nexport class MerkleProof {\n\n    static __wrap(ptr) {\n        const obj = Object.create(MerkleProof.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_merkleproof_free(ptr);\n    }\n    /**\n    * Creates a new merkle proof with given leaf data and level data (bottom-upwards)\n    * You can verify it against a Blakeb256 root hash by using [`Self::valid()`]\n    * Add a node by using [`Self::add_node()`]\n    * Each digest on the level must be exactly 32 bytes\n    * @param {Uint8Array} leaf_data\n    * @returns {MerkleProof}\n    */\n    static new(leaf_data) {\n        var ptr0 = passArray8ToWasm0(leaf_data, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.merkleproof_new(ptr0, len0);\n        return MerkleProof.__wrap(ret);\n    }\n    /**\n    * Adds a new node to the MerkleProof above the current nodes\n    * @param {LevelNode} level\n    */\n    add_node(level) {\n        _assertClass(level, LevelNode);\n        wasm.merkleproof_add_node(this.ptr, level.ptr);\n    }\n    /**\n    * Validates the Merkle proof against the root hash\n    * @param {Uint8Array} expected_root\n    * @returns {boolean}\n    */\n    valid(expected_root) {\n        var ptr0 = passArray8ToWasm0(expected_root, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.merkleproof_valid(this.ptr, ptr0, len0);\n        return ret !== 0;\n    }\n}\n/**\n* helper methods to get the fee address for various networks\n*/\nexport class MinerAddress {\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_mineraddress_free(ptr);\n    }\n    /**\n    * Miner fee Base58 encoded P2S address on mainnet\n    * @returns {string}\n    */\n    static mainnet_fee_address() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.mineraddress_mainnet_fee_address(retptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * Miner fee Base58 encoded P2S address on testnet\n    * @returns {string}\n    */\n    static testnet_fee_address() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.mineraddress_testnet_fee_address(retptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n}\n/**\n* Mnemonic\n*/\nexport class Mnemonic {\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_mnemonic_free(ptr);\n    }\n    /**\n    * Convert a mnemonic phrase into a mnemonic seed\n    * mnemonic_pass is optional and is used to salt the seed\n    * @param {string} mnemonic_phrase\n    * @param {string} mnemonic_pass\n    * @returns {Uint8Array}\n    */\n    static to_seed(mnemonic_phrase, mnemonic_pass) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(mnemonic_phrase, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            var ptr1 = passStringToWasm0(mnemonic_pass, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len1 = WASM_VECTOR_LEN;\n            wasm.mnemonic_to_seed(retptr, ptr0, len0, ptr1, len1);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v2 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v2;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n* Combination of an Address with a network\n* These two combined together form a base58 encoding\n*/\nexport class NetworkAddress {\n\n    static __wrap(ptr) {\n        const obj = Object.create(NetworkAddress.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_networkaddress_free(ptr);\n    }\n    /**\n    * create a new NetworkAddress(address + network prefix) for a given network type\n    * @param {number} network\n    * @param {Address} address\n    * @returns {NetworkAddress}\n    */\n    static new(network, address) {\n        _assertClass(address, Address);\n        var ret = wasm.networkaddress_new(network, address.ptr);\n        return NetworkAddress.__wrap(ret);\n    }\n    /**\n    * Decode (base58) a NetworkAddress (address + network prefix) from string\n    * @param {string} s\n    * @returns {NetworkAddress}\n    */\n    static from_base58(s) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(s, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.networkaddress_from_base58(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return NetworkAddress.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Encode (base58) address\n    * @returns {string}\n    */\n    to_base58() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.networkaddress_to_base58(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * Decode from a serialized address\n    * @param {Uint8Array} data\n    * @returns {NetworkAddress}\n    */\n    static from_bytes(data) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passArray8ToWasm0(data, wasm.__wbindgen_malloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.networkaddress_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return NetworkAddress.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Encode address as serialized bytes\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.networkaddress_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Network for the address\n    * @returns {number}\n    */\n    network() {\n        var ret = wasm.networkaddress_network(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Get address without network information\n    * @returns {Address}\n    */\n    address() {\n        var ret = wasm.networkaddress_address(this.ptr);\n        return Address.__wrap(ret);\n    }\n}\n/**\n* A structure representing NiPoPow proof.\n*/\nexport class NipopowProof {\n\n    static __wrap(ptr) {\n        const obj = Object.create(NipopowProof.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_nipopowproof_free(ptr);\n    }\n    /**\n    * Implementation of the ≥ algorithm from [`KMZ17`], see Algorithm 4\n    *\n    * [`KMZ17`]: https://fc20.ifca.ai/preproceedings/74.pdf\n    * @param {NipopowProof} that\n    * @returns {boolean}\n    */\n    is_better_than(that) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(that, NipopowProof);\n            wasm.nipopowproof_is_better_than(retptr, this.ptr, that.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return r0 !== 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * JSON representation as text\n    * @returns {string}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.nipopowproof_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr0 = r0;\n            var len0 = r1;\n            if (r3) {\n                ptr0 = 0; len0 = 0;\n                throw takeObject(r2);\n            }\n            return getStringFromWasm0(ptr0, len0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(ptr0, len0);\n        }\n    }\n    /**\n    * Get suffix head\n    * @returns {PoPowHeader}\n    */\n    suffix_head() {\n        var ret = wasm.nipopowproof_suffix_head(this.ptr);\n        return PoPowHeader.__wrap(ret);\n    }\n    /**\n    * Parse from JSON\n    * supports Ergo Node/Explorer API and box values and token amount encoded as strings\n    * @param {string} json\n    * @returns {NipopowProof}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.nipopowproof_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return NipopowProof.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n* A verifier for PoPoW proofs. During its lifetime, it processes many proofs with the aim of\n* deducing at any given point what is the best (sub)chain rooted at the specified genesis.\n*/\nexport class NipopowVerifier {\n\n    static __wrap(ptr) {\n        const obj = Object.create(NipopowVerifier.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_nipopowverifier_free(ptr);\n    }\n    /**\n    * Create new instance\n    * @param {BlockId} genesis_block_id\n    */\n    constructor(genesis_block_id) {\n        _assertClass(genesis_block_id, BlockId);\n        var ptr0 = genesis_block_id.ptr;\n        genesis_block_id.ptr = 0;\n        var ret = wasm.nipopowverifier_new(ptr0);\n        return NipopowVerifier.__wrap(ret);\n    }\n    /**\n    * Return best proof\n    * @returns {NipopowProof | undefined}\n    */\n    best_proof() {\n        var ret = wasm.nipopowverifier_best_proof(this.ptr);\n        return ret === 0 ? undefined : NipopowProof.__wrap(ret);\n    }\n    /**\n    * Returns chain of `BlockHeader`s from the best proof.\n    * @returns {BlockHeaders}\n    */\n    best_chain() {\n        var ret = wasm.nipopowverifier_best_chain(this.ptr);\n        return BlockHeaders.__wrap(ret);\n    }\n    /**\n    * Process given proof\n    * @param {NipopowProof} new_proof\n    */\n    process(new_proof) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(new_proof, NipopowProof);\n            var ptr0 = new_proof.ptr;\n            new_proof.ptr = 0;\n            wasm.nipopowverifier_process(retptr, this.ptr, ptr0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n* Node configuration\n*/\nexport class NodeConf {\n\n    static __wrap(ptr) {\n        const obj = Object.create(NodeConf.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_nodeconf_free(ptr);\n    }\n    /**\n    * Create a node configuration\n    * @param {URL} url\n    */\n    constructor(url) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.nodeconf_new(retptr, addBorrowedObject(url));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return NodeConf.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            heap[stack_pointer++] = undefined;\n        }\n    }\n}\n/**\n* Node info\n*/\nexport class NodeInfo {\n\n    static __wrap(ptr) {\n        const obj = Object.create(NodeInfo.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_nodeinfo_free(ptr);\n    }\n    /**\n    * Get name of the ergo node\n    * @returns {string}\n    */\n    name() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.nodeinfo_name(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * Returns true iff the ergo node is at least v4.0.28. This is important since nipopow proofs\n    * only work correctly from this version onwards.\n    * @returns {boolean}\n    */\n    is_at_least_version_4_0_28() {\n        var ret = wasm.nodeinfo_is_at_least_version_4_0_28(this.ptr);\n        return ret !== 0;\n    }\n}\n/**\n* List of peer urls returned from `peer_discovery`. We need this wrapper struct because the\n* `wasm_bindgen` macro currently cannot deal with `Result<Box<[T]>, JsValue>`, for any value `T`\n* that can be converted into a `JsValue` (`Result<Box<[web_sys::Url]>, JsValue>` would be a\n* convenient return type for `peer_discovery`).\n*/\nexport class PeerUrls {\n\n    static __wrap(ptr) {\n        const obj = Object.create(PeerUrls.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_peerurls_free(ptr);\n    }\n    /**\n    * Returns the number of elements in the collection\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.peerurls_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Returns the element of the collection with a given index\n    * @param {number} index\n    * @returns {URL}\n    */\n    get(index) {\n        var ret = wasm.peerurls_get(this.ptr, index);\n        return takeObject(ret);\n    }\n}\n/**\n* PoPowHeader structure. Represents the block header and unpacked interlinks\n*/\nexport class PoPowHeader {\n\n    static __wrap(ptr) {\n        const obj = Object.create(PoPowHeader.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_popowheader_free(ptr);\n    }\n    /**\n    * Returns block header\n    * @returns {BlockHeader}\n    */\n    header() {\n        var ret = wasm.popowheader_header(this.ptr);\n        return BlockHeader.__wrap(ret);\n    }\n    /**\n    * Returns interlinks for PoPowHeader\n    * @returns {any}\n    */\n    interlinks() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.popowheader_interlinks(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Returns interlinks proof [`crate::batchmerkleproof::BatchMerkleProof`]\n    * @returns {BatchMerkleProof}\n    */\n    interlinks_proof() {\n        var ret = wasm.popowheader_interlinks_proof(this.ptr);\n        return BatchMerkleProof.__wrap(ret);\n    }\n    /**\n    * Validates interlinks merkle root with compact merkle multiproof. See [`PoPowHeader::interlinks_proof`] for BatchMerkleProof access\n    * @returns {boolean}\n    */\n    check_interlinks_proof() {\n        var ret = wasm.popowheader_check_interlinks_proof(this.ptr);\n        return ret !== 0;\n    }\n    /**\n    * Returns block height for Header\n    * @returns {number}\n    */\n    height() {\n        var ret = wasm.popowheader_height(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Returns Block ID for Header\n    * @returns {BlockId}\n    */\n    id() {\n        var ret = wasm.popowheader_id(this.ptr);\n        return BlockId.__wrap(ret);\n    }\n}\n/**\n* Block header with the current `spendingTransaction`, that can be predicted\n* by a miner before it's formation\n*/\nexport class PreHeader {\n\n    static __wrap(ptr) {\n        const obj = Object.create(PreHeader.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_preheader_free(ptr);\n    }\n    /**\n    * Create using data from block header\n    * @param {BlockHeader} block_header\n    * @returns {PreHeader}\n    */\n    static from_block_header(block_header) {\n        _assertClass(block_header, BlockHeader);\n        var ptr0 = block_header.ptr;\n        block_header.ptr = 0;\n        var ret = wasm.preheader_from_block_header(ptr0);\n        return PreHeader.__wrap(ret);\n    }\n}\n/**\n* Propositions list(public keys)\n*/\nexport class Propositions {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Propositions.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_propositions_free(ptr);\n    }\n    /**\n    * Create empty proposition holder\n    */\n    constructor() {\n        var ret = wasm.propositions_new();\n        return Propositions.__wrap(ret);\n    }\n    /**\n    * Adding new proposition\n    * @param {Uint8Array} proposition\n    */\n    add_proposition_from_byte(proposition) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passArray8ToWasm0(proposition, wasm.__wbindgen_malloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.propositions_add_proposition_from_byte(retptr, this.ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n* Proof of correctness of tx spending\n*/\nexport class ProverResult {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ProverResult.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_proverresult_free(ptr);\n    }\n    /**\n    * Get proof\n    * @returns {Uint8Array}\n    */\n    proof() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.proverresult_proof(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Get extension\n    * @returns {ContextExtension}\n    */\n    extension() {\n        var ret = wasm.proverresult_extension(this.ptr);\n        return ContextExtension.__wrap(ret);\n    }\n    /**\n    * JSON representation as text (compatible with Ergo Node/Explorer API, numbers are encoded as numbers)\n    * @returns {string}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.proverresult_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr0 = r0;\n            var len0 = r1;\n            if (r3) {\n                ptr0 = 0; len0 = 0;\n                throw takeObject(r2);\n            }\n            return getStringFromWasm0(ptr0, len0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(ptr0, len0);\n        }\n    }\n}\n/**\n* Represent `reduced` transaction, i.e. unsigned transaction where each unsigned input\n* is augmented with ReducedInput which contains a script reduction result.\n* After an unsigned transaction is reduced it can be signed without context.\n* Thus, it can be serialized and transferred for example to Cold Wallet and signed\n* in an environment where secrets are known.\n* see EIP-19 for more details -\n* <https://github.com/ergoplatform/eips/blob/f280890a4163f2f2e988a0091c078e36912fc531/eip-0019.md>\n*/\nexport class ReducedTransaction {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ReducedTransaction.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_reducedtransaction_free(ptr);\n    }\n    /**\n    * Returns `reduced` transaction, i.e. unsigned transaction where each unsigned input\n    * is augmented with ReducedInput which contains a script reduction result.\n    * @param {UnsignedTransaction} unsigned_tx\n    * @param {ErgoBoxes} boxes_to_spend\n    * @param {ErgoBoxes} data_boxes\n    * @param {ErgoStateContext} state_context\n    * @returns {ReducedTransaction}\n    */\n    static from_unsigned_tx(unsigned_tx, boxes_to_spend, data_boxes, state_context) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(unsigned_tx, UnsignedTransaction);\n            _assertClass(boxes_to_spend, ErgoBoxes);\n            _assertClass(data_boxes, ErgoBoxes);\n            _assertClass(state_context, ErgoStateContext);\n            wasm.reducedtransaction_from_unsigned_tx(retptr, unsigned_tx.ptr, boxes_to_spend.ptr, data_boxes.ptr, state_context.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ReducedTransaction.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Returns serialized bytes or fails with error if cannot be serialized\n    * @returns {Uint8Array}\n    */\n    sigma_serialize_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.reducedtransaction_sigma_serialize_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            if (r3) {\n                throw takeObject(r2);\n            }\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Parses ReducedTransaction or fails with error\n    * @param {Uint8Array} data\n    * @returns {ReducedTransaction}\n    */\n    static sigma_parse_bytes(data) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passArray8ToWasm0(data, wasm.__wbindgen_malloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.reducedtransaction_sigma_parse_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ReducedTransaction.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Returns the unsigned transaction\n    * @returns {UnsignedTransaction}\n    */\n    unsigned_tx() {\n        var ret = wasm.reducedtransaction_unsigned_tx(this.ptr);\n        return UnsignedTransaction.__wrap(ret);\n    }\n}\n/**\n* Secret key for the prover\n*/\nexport class SecretKey {\n\n    static __wrap(ptr) {\n        const obj = Object.create(SecretKey.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_secretkey_free(ptr);\n    }\n    /**\n    * generate random key\n    * @returns {SecretKey}\n    */\n    static random_dlog() {\n        var ret = wasm.secretkey_random_dlog();\n        return SecretKey.__wrap(ret);\n    }\n    /**\n    * Parse dlog secret key from bytes (SEC-1-encoded scalar)\n    * @param {Uint8Array} bytes\n    * @returns {SecretKey}\n    */\n    static dlog_from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.secretkey_dlog_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return SecretKey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Address (encoded public image)\n    * @returns {Address}\n    */\n    get_address() {\n        var ret = wasm.secretkey_get_address(this.ptr);\n        return Address.__wrap(ret);\n    }\n    /**\n    * Encode from a serialized key\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.secretkey_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n* SecretKey collection\n*/\nexport class SecretKeys {\n\n    static __wrap(ptr) {\n        const obj = Object.create(SecretKeys.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_secretkeys_free(ptr);\n    }\n    /**\n    * Create empty SecretKeys\n    */\n    constructor() {\n        var ret = wasm.secretkeys_new();\n        return SecretKeys.__wrap(ret);\n    }\n    /**\n    * Returns the number of elements in the collection\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.secretkeys_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Returns the element of the collection with a given index\n    * @param {number} index\n    * @returns {SecretKey}\n    */\n    get(index) {\n        var ret = wasm.secretkeys_get(this.ptr, index);\n        return SecretKey.__wrap(ret);\n    }\n    /**\n    * Adds an elements to the collection\n    * @param {SecretKey} elem\n    */\n    add(elem) {\n        _assertClass(elem, SecretKey);\n        wasm.secretkeys_add(this.ptr, elem.ptr);\n    }\n}\n/**\n* Naive box selector, collects inputs until target balance is reached\n*/\nexport class SimpleBoxSelector {\n\n    static __wrap(ptr) {\n        const obj = Object.create(SimpleBoxSelector.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_simpleboxselector_free(ptr);\n    }\n    /**\n    * Create empty SimpleBoxSelector\n    */\n    constructor() {\n        var ret = wasm.simpleboxselector_new();\n        return SimpleBoxSelector.__wrap(ret);\n    }\n    /**\n    * Selects inputs to satisfy target balance and tokens.\n    * `inputs` - available inputs (returns an error, if empty),\n    * `target_balance` - coins (in nanoERGs) needed,\n    * `target_tokens` - amount of tokens needed.\n    * Returns selected inputs and box assets(value+tokens) with change.\n    * @param {ErgoBoxes} inputs\n    * @param {BoxValue} target_balance\n    * @param {Tokens} target_tokens\n    * @returns {BoxSelection}\n    */\n    select(inputs, target_balance, target_tokens) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(inputs, ErgoBoxes);\n            _assertClass(target_balance, BoxValue);\n            _assertClass(target_tokens, Tokens);\n            wasm.simpleboxselector_select(retptr, this.ptr, inputs.ptr, target_balance.ptr, target_tokens.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return BoxSelection.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n* Token represented with token id paired with it's amount\n*/\nexport class Token {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Token.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_token_free(ptr);\n    }\n    /**\n    * Create a token with given token id and amount\n    * @param {TokenId} token_id\n    * @param {TokenAmount} amount\n    */\n    constructor(token_id, amount) {\n        _assertClass(token_id, TokenId);\n        _assertClass(amount, TokenAmount);\n        var ret = wasm.token_new(token_id.ptr, amount.ptr);\n        return Token.__wrap(ret);\n    }\n    /**\n    * Get token id\n    * @returns {TokenId}\n    */\n    id() {\n        var ret = wasm.token_id(this.ptr);\n        return TokenId.__wrap(ret);\n    }\n    /**\n    * Get token amount\n    * @returns {TokenAmount}\n    */\n    amount() {\n        var ret = wasm.token_amount(this.ptr);\n        return TokenAmount.__wrap(ret);\n    }\n    /**\n    * JSON representation as text (compatible with Ergo Node/Explorer API, numbers are encoded as numbers)\n    * @returns {string}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.token_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr0 = r0;\n            var len0 = r1;\n            if (r3) {\n                ptr0 = 0; len0 = 0;\n                throw takeObject(r2);\n            }\n            return getStringFromWasm0(ptr0, len0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(ptr0, len0);\n        }\n    }\n    /**\n    * JSON representation according to EIP-12 <https://github.com/ergoplatform/eips/pull/23>\n    * (similar to [`Self::to_json`], but as JS object with token amount encoding as string)\n    * @returns {any}\n    */\n    to_js_eip12() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.token_to_js_eip12(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n* Token amount with bound checks\n*/\nexport class TokenAmount {\n\n    static __wrap(ptr) {\n        const obj = Object.create(TokenAmount.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_tokenamount_free(ptr);\n    }\n    /**\n    * Create from i64 with bounds check\n    * @param {I64} v\n    * @returns {TokenAmount}\n    */\n    static from_i64(v) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(v, I64);\n            wasm.tokenamount_from_i64(retptr, v.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TokenAmount.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Get value as signed 64-bit long (I64)\n    * @returns {I64}\n    */\n    as_i64() {\n        var ret = wasm.tokenamount_as_i64(this.ptr);\n        return I64.__wrap(ret);\n    }\n    /**\n    * big-endian byte array representation\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.tokenamount_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n* Token id (32 byte digest)\n*/\nexport class TokenId {\n\n    static __wrap(ptr) {\n        const obj = Object.create(TokenId.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_tokenid_free(ptr);\n    }\n    /**\n    * Create token id from ergo box id (32 byte digest)\n    * @param {BoxId} box_id\n    * @returns {TokenId}\n    */\n    static from_box_id(box_id) {\n        _assertClass(box_id, BoxId);\n        var ret = wasm.tokenid_from_box_id(box_id.ptr);\n        return TokenId.__wrap(ret);\n    }\n    /**\n    * Parse token id (32 byte digest) from base16-encoded string\n    * @param {string} str\n    * @returns {TokenId}\n    */\n    static from_str(str) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.tokenid_from_str(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TokenId.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Base16 encoded string\n    * @returns {string}\n    */\n    to_str() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.tokenid_to_str(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * Returns byte array (32 bytes)\n    * @returns {Uint8Array}\n    */\n    as_bytes() {\n        var ret = wasm.tokenid_as_bytes(this.ptr);\n        return takeObject(ret);\n    }\n}\n/**\n* Array of tokens\n*/\nexport class Tokens {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Tokens.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_tokens_free(ptr);\n    }\n    /**\n    * Create empty Tokens\n    */\n    constructor() {\n        var ret = wasm.tokens_new();\n        return Tokens.__wrap(ret);\n    }\n    /**\n    * Returns the number of elements in the collection\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.tokens_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Returns the element of the collection with a given index\n    * @param {number} index\n    * @returns {Token}\n    */\n    get(index) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.tokens_get(retptr, this.ptr, index);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Token.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Adds an elements to the collection\n    * @param {Token} elem\n    */\n    add(elem) {\n        _assertClass(elem, Token);\n        wasm.tokens_add(this.ptr, elem.ptr);\n    }\n}\n/**\n*\n* * ErgoTransaction is an atomic state transition operation. It destroys Boxes from the state\n* * and creates new ones. If transaction is spending boxes protected by some non-trivial scripts,\n* * its inputs should also contain proof of spending correctness - context extension (user-defined\n* * key-value map) and data inputs (links to existing boxes in the state) that may be used during\n* * script reduction to crypto, signatures that satisfies the remaining cryptographic protection\n* * of the script.\n* * Transactions are not encrypted, so it is possible to browse and view every transaction ever\n* * collected into a block.\n*\n*/\nexport class Transaction {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Transaction.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transaction_free(ptr);\n    }\n    /**\n    * Create Transaction from UnsignedTransaction and an array of proofs in the same order as\n    * UnsignedTransaction.inputs with empty proof indicated with empty byte array\n    * @param {UnsignedTransaction} unsigned_tx\n    * @param {(Uint8Array)[]} proofs\n    * @returns {Transaction}\n    */\n    static from_unsigned_tx(unsigned_tx, proofs) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(unsigned_tx, UnsignedTransaction);\n            var ptr0 = unsigned_tx.ptr;\n            unsigned_tx.ptr = 0;\n            var ptr1 = passArrayJsValueToWasm0(proofs, wasm.__wbindgen_malloc);\n            var len1 = WASM_VECTOR_LEN;\n            wasm.transaction_from_unsigned_tx(retptr, ptr0, ptr1, len1);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Transaction.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Get id for transaction\n    * @returns {TxId}\n    */\n    id() {\n        var ret = wasm.transaction_id(this.ptr);\n        return TxId.__wrap(ret);\n    }\n    /**\n    * JSON representation as text (compatible with Ergo Node/Explorer API, numbers are encoded as numbers)\n    * @returns {string}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transaction_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr0 = r0;\n            var len0 = r1;\n            if (r3) {\n                ptr0 = 0; len0 = 0;\n                throw takeObject(r2);\n            }\n            return getStringFromWasm0(ptr0, len0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(ptr0, len0);\n        }\n    }\n    /**\n    * JSON representation according to EIP-12 <https://github.com/ergoplatform/eips/pull/23>\n    * (similar to [`Self::to_json`], but as JS object with box value and token amount encoding as strings)\n    * @returns {any}\n    */\n    to_js_eip12() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transaction_to_js_eip12(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * parse from JSON\n    * supports Ergo Node/Explorer API and box values and token amount encoded as strings\n    * @param {string} json\n    * @returns {Transaction}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.transaction_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Transaction.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Inputs for transaction\n    * @returns {Inputs}\n    */\n    inputs() {\n        var ret = wasm.transaction_inputs(this.ptr);\n        return Inputs.__wrap(ret);\n    }\n    /**\n    * Data inputs for transaction\n    * @returns {DataInputs}\n    */\n    data_inputs() {\n        var ret = wasm.transaction_data_inputs(this.ptr);\n        return DataInputs.__wrap(ret);\n    }\n    /**\n    * Output candidates for transaction\n    * @returns {ErgoBoxCandidates}\n    */\n    output_candidates() {\n        var ret = wasm.transaction_output_candidates(this.ptr);\n        return ErgoBoxCandidates.__wrap(ret);\n    }\n    /**\n    * Returns ErgoBox's created from ErgoBoxCandidate's with tx id and indices\n    * @returns {ErgoBoxes}\n    */\n    outputs() {\n        var ret = wasm.transaction_outputs(this.ptr);\n        return ErgoBoxes.__wrap(ret);\n    }\n    /**\n    * Returns serialized bytes or fails with error if cannot be serialized\n    * @returns {Uint8Array}\n    */\n    sigma_serialize_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transaction_sigma_serialize_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            if (r3) {\n                throw takeObject(r2);\n            }\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Parses Transaction or fails with error\n    * @param {Uint8Array} data\n    * @returns {Transaction}\n    */\n    static sigma_parse_bytes(data) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passArray8ToWasm0(data, wasm.__wbindgen_malloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.transaction_sigma_parse_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Transaction.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Check the signature of the transaction's input corresponding\n    * to the given input box, guarded by P2PK script\n    * @param {ErgoBox} input_box\n    * @returns {boolean}\n    */\n    verify_p2pk_input(input_box) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(input_box, ErgoBox);\n            var ptr0 = input_box.ptr;\n            input_box.ptr = 0;\n            wasm.transaction_verify_p2pk_input(retptr, this.ptr, ptr0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return r0 !== 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n* TransactionHintsBag\n*/\nexport class TransactionHintsBag {\n\n    static __wrap(ptr) {\n        const obj = Object.create(TransactionHintsBag.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transactionhintsbag_free(ptr);\n    }\n    /**\n    * Empty TransactionHintsBag\n    * @returns {TransactionHintsBag}\n    */\n    static empty() {\n        var ret = wasm.transactionhintsbag_empty();\n        return TransactionHintsBag.__wrap(ret);\n    }\n    /**\n    * Adding hints for input\n    * @param {number} index\n    * @param {HintsBag} hints_bag\n    */\n    add_hints_for_input(index, hints_bag) {\n        _assertClass(hints_bag, HintsBag);\n        wasm.transactionhintsbag_add_hints_for_input(this.ptr, index, hints_bag.ptr);\n    }\n    /**\n    * Outputting HintsBag corresponding for an input index\n    * @param {number} index\n    * @returns {HintsBag}\n    */\n    all_hints_for_input(index) {\n        var ret = wasm.transactionhintsbag_all_hints_for_input(this.ptr, index);\n        return HintsBag.__wrap(ret);\n    }\n    /**\n    * Return JSON object (node format)\n    * @returns {any}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionhintsbag_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Parse from JSON object (node format)\n    * @param {string} json\n    * @returns {TransactionHintsBag}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.transactionhintsbag_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TransactionHintsBag.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n* Unsigned transaction builder\n*/\nexport class TxBuilder {\n\n    static __wrap(ptr) {\n        const obj = Object.create(TxBuilder.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_txbuilder_free(ptr);\n    }\n    /**\n    * Suggested transaction fee (semi-default value used across wallets and dApps as of Oct 2020)\n    * @returns {BoxValue}\n    */\n    static SUGGESTED_TX_FEE() {\n        var ret = wasm.txbuilder_SUGGESTED_TX_FEE();\n        return BoxValue.__wrap(ret);\n    }\n    /**\n    * Creates new TxBuilder\n    * `box_selection` - selected input boxes (via [`super::box_selector`])\n    * `output_candidates` - output boxes to be \"created\" in this transaction,\n    * `current_height` - chain height that will be used in additionally created boxes (change, miner's fee, etc.),\n    * `fee_amount` - miner's fee,\n    * `change_address` - change (inputs - outputs) will be sent to this address,\n    * will be given to miners,\n    * @param {BoxSelection} box_selection\n    * @param {ErgoBoxCandidates} output_candidates\n    * @param {number} current_height\n    * @param {BoxValue} fee_amount\n    * @param {Address} change_address\n    * @returns {TxBuilder}\n    */\n    static new(box_selection, output_candidates, current_height, fee_amount, change_address) {\n        _assertClass(box_selection, BoxSelection);\n        _assertClass(output_candidates, ErgoBoxCandidates);\n        _assertClass(fee_amount, BoxValue);\n        _assertClass(change_address, Address);\n        var ret = wasm.txbuilder_new(box_selection.ptr, output_candidates.ptr, current_height, fee_amount.ptr, change_address.ptr);\n        return TxBuilder.__wrap(ret);\n    }\n    /**\n    * Set transaction's data inputs\n    * @param {DataInputs} data_inputs\n    */\n    set_data_inputs(data_inputs) {\n        _assertClass(data_inputs, DataInputs);\n        wasm.txbuilder_set_data_inputs(this.ptr, data_inputs.ptr);\n    }\n    /**\n    * Set context extension for a given input\n    * @param {BoxId} box_id\n    * @param {ContextExtension} context_extension\n    */\n    set_context_extension(box_id, context_extension) {\n        _assertClass(box_id, BoxId);\n        _assertClass(context_extension, ContextExtension);\n        wasm.txbuilder_set_context_extension(this.ptr, box_id.ptr, context_extension.ptr);\n    }\n    /**\n    * Permits the burn of the given token amount, i.e. allows this token amount to be omitted in the outputs\n    * @param {Tokens} tokens\n    */\n    set_token_burn_permit(tokens) {\n        _assertClass(tokens, Tokens);\n        wasm.txbuilder_set_token_burn_permit(this.ptr, tokens.ptr);\n    }\n    /**\n    * Build the unsigned transaction\n    * @returns {UnsignedTransaction}\n    */\n    build() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.txbuilder_build(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return UnsignedTransaction.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Get box selection\n    * @returns {BoxSelection}\n    */\n    box_selection() {\n        var ret = wasm.txbuilder_box_selection(this.ptr);\n        return BoxSelection.__wrap(ret);\n    }\n    /**\n    * Get data inputs\n    * @returns {DataInputs}\n    */\n    data_inputs() {\n        var ret = wasm.txbuilder_data_inputs(this.ptr);\n        return DataInputs.__wrap(ret);\n    }\n    /**\n    * Get outputs EXCLUDING fee and change\n    * @returns {ErgoBoxCandidates}\n    */\n    output_candidates() {\n        var ret = wasm.txbuilder_output_candidates(this.ptr);\n        return ErgoBoxCandidates.__wrap(ret);\n    }\n    /**\n    * Get current height\n    * @returns {number}\n    */\n    current_height() {\n        var ret = wasm.txbuilder_current_height(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Get fee amount\n    * @returns {BoxValue}\n    */\n    fee_amount() {\n        var ret = wasm.txbuilder_fee_amount(this.ptr);\n        return BoxValue.__wrap(ret);\n    }\n    /**\n    * Get change address\n    * @returns {Address}\n    */\n    change_address() {\n        var ret = wasm.txbuilder_change_address(this.ptr);\n        return Address.__wrap(ret);\n    }\n}\n/**\n* Transaction id\n*/\nexport class TxId {\n\n    static __wrap(ptr) {\n        const obj = Object.create(TxId.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_txid_free(ptr);\n    }\n    /**\n    * Zero (empty) transaction id (to use as dummy value in tests)\n    * @returns {TxId}\n    */\n    static zero() {\n        var ret = wasm.txid_zero();\n        return TxId.__wrap(ret);\n    }\n    /**\n    * get the tx id as bytes\n    * @returns {string}\n    */\n    to_str() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.txid_to_str(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * convert a hex string into a TxId\n    * @param {string} s\n    * @returns {TxId}\n    */\n    static from_str(s) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(s, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.txid_from_str(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TxId.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n* Unsigned inputs used in constructing unsigned transactions\n*/\nexport class UnsignedInput {\n\n    static __wrap(ptr) {\n        const obj = Object.create(UnsignedInput.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_unsignedinput_free(ptr);\n    }\n    /**\n    * Create new unsigned input instance from box id and extension\n    * @param {BoxId} box_id\n    * @param {ContextExtension} ext\n    */\n    constructor(box_id, ext) {\n        _assertClass(box_id, BoxId);\n        _assertClass(ext, ContextExtension);\n        var ret = wasm.unsignedinput_new(box_id.ptr, ext.ptr);\n        return UnsignedInput.__wrap(ret);\n    }\n    /**\n    * Create a new unsigned input from the provided box id\n    * using an empty context extension\n    * @param {BoxId} box_id\n    * @returns {UnsignedInput}\n    */\n    static from_box_id(box_id) {\n        _assertClass(box_id, BoxId);\n        var ret = wasm.unsignedinput_from_box_id(box_id.ptr);\n        return UnsignedInput.__wrap(ret);\n    }\n    /**\n    * Get box id\n    * @returns {BoxId}\n    */\n    box_id() {\n        var ret = wasm.unsignedinput_box_id(this.ptr);\n        return BoxId.__wrap(ret);\n    }\n    /**\n    * Get extension\n    * @returns {ContextExtension}\n    */\n    extension() {\n        var ret = wasm.unsignedinput_extension(this.ptr);\n        return ContextExtension.__wrap(ret);\n    }\n}\n/**\n* Collection of unsigned signed inputs\n*/\nexport class UnsignedInputs {\n\n    static __wrap(ptr) {\n        const obj = Object.create(UnsignedInputs.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_unsignedinputs_free(ptr);\n    }\n    /**\n    * Create empty UnsignedInputs\n    */\n    constructor() {\n        var ret = wasm.unsignedinputs_new();\n        return UnsignedInputs.__wrap(ret);\n    }\n    /**\n    * Returns the number of elements in the collection\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.unsignedinputs_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Returns the element of the collection with a given index\n    * @param {number} index\n    * @returns {UnsignedInput}\n    */\n    get(index) {\n        var ret = wasm.unsignedinputs_get(this.ptr, index);\n        return UnsignedInput.__wrap(ret);\n    }\n    /**\n    * Add an element to the collection\n    * @param {UnsignedInput} b\n    */\n    add(b) {\n        _assertClass(b, UnsignedInput);\n        wasm.unsignedinputs_add(this.ptr, b.ptr);\n    }\n}\n/**\n* Unsigned (inputs without proofs) transaction\n*/\nexport class UnsignedTransaction {\n\n    static __wrap(ptr) {\n        const obj = Object.create(UnsignedTransaction.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_unsignedtransaction_free(ptr);\n    }\n    /**\n    * Create a new unsigned transaction\n    * @param {UnsignedInputs} inputs\n    * @param {DataInputs} data_inputs\n    * @param {ErgoBoxCandidates} output_candidates\n    */\n    constructor(inputs, data_inputs, output_candidates) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(inputs, UnsignedInputs);\n            _assertClass(data_inputs, DataInputs);\n            _assertClass(output_candidates, ErgoBoxCandidates);\n            wasm.unsignedtransaction_new(retptr, inputs.ptr, data_inputs.ptr, output_candidates.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return UnsignedTransaction.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Consumes the calling UnsignedTransaction and returns a new UnsignedTransaction containing\n    * the ContextExtension in the provided input box id or returns an error if the input box cannot be found.\n    * After the call the calling UnsignedTransaction will be null.\n    * @param {BoxId} input_id\n    * @param {ContextExtension} ext\n    * @returns {UnsignedTransaction}\n    */\n    with_input_context_ext(input_id, ext) {\n        try {\n            const ptr = this.__destroy_into_raw();\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(input_id, BoxId);\n            _assertClass(ext, ContextExtension);\n            wasm.unsignedtransaction_with_input_context_ext(retptr, ptr, input_id.ptr, ext.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return UnsignedTransaction.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Get id for transaction\n    * @returns {TxId}\n    */\n    id() {\n        var ret = wasm.unsignedtransaction_id(this.ptr);\n        return TxId.__wrap(ret);\n    }\n    /**\n    * Inputs for transaction\n    * @returns {UnsignedInputs}\n    */\n    inputs() {\n        var ret = wasm.unsignedtransaction_inputs(this.ptr);\n        return UnsignedInputs.__wrap(ret);\n    }\n    /**\n    * Data inputs for transaction\n    * @returns {DataInputs}\n    */\n    data_inputs() {\n        var ret = wasm.unsignedtransaction_data_inputs(this.ptr);\n        return DataInputs.__wrap(ret);\n    }\n    /**\n    * Output candidates for transaction\n    * @returns {ErgoBoxCandidates}\n    */\n    output_candidates() {\n        var ret = wasm.unsignedtransaction_output_candidates(this.ptr);\n        return ErgoBoxCandidates.__wrap(ret);\n    }\n    /**\n    * JSON representation as text (compatible with Ergo Node/Explorer API, numbers are encoded as numbers)\n    * @returns {string}\n    */\n    to_json() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.unsignedtransaction_to_json(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr0 = r0;\n            var len0 = r1;\n            if (r3) {\n                ptr0 = 0; len0 = 0;\n                throw takeObject(r2);\n            }\n            return getStringFromWasm0(ptr0, len0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(ptr0, len0);\n        }\n    }\n    /**\n    * JSON representation according to EIP-12 <https://github.com/ergoplatform/eips/pull/23>\n    * (similar to [`Self::to_json`], but as JS object with box value and token amount encoding as strings)\n    * @returns {any}\n    */\n    to_js_eip12() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.unsignedtransaction_to_js_eip12(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * parse from JSON\n    * supports Ergo Node/Explorer API and box values and token amount encoded as strings\n    * @param {string} json\n    * @returns {UnsignedTransaction}\n    */\n    static from_json(json) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.unsignedtransaction_from_json(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return UnsignedTransaction.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Returns distinct token id from output_candidates as array of byte arrays\n    * @returns {(Uint8Array)[]}\n    */\n    distinct_token_ids() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.unsignedtransaction_distinct_token_ids(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 4);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n* A collection of secret keys. This simplified signing by matching the secret keys to the correct inputs automatically.\n*/\nexport class Wallet {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Wallet.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_wallet_free(ptr);\n    }\n    /**\n    * Create wallet instance loading secret key from mnemonic\n    * Returns None if a DlogSecretKey cannot be parsed from the provided phrase\n    * @param {string} mnemonic_phrase\n    * @param {string} mnemonic_pass\n    * @returns {Wallet}\n    */\n    static from_mnemonic(mnemonic_phrase, mnemonic_pass) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(mnemonic_phrase, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            var ptr1 = passStringToWasm0(mnemonic_pass, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len1 = WASM_VECTOR_LEN;\n            wasm.wallet_from_mnemonic(retptr, ptr0, len0, ptr1, len1);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Wallet.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Create wallet using provided secret key\n    * @param {SecretKeys} secret\n    * @returns {Wallet}\n    */\n    static from_secrets(secret) {\n        _assertClass(secret, SecretKeys);\n        var ret = wasm.wallet_from_secrets(secret.ptr);\n        return Wallet.__wrap(ret);\n    }\n    /**\n    * Add a secret to the wallets prover\n    * @param {SecretKey} secret\n    */\n    add_secret(secret) {\n        _assertClass(secret, SecretKey);\n        wasm.wallet_add_secret(this.ptr, secret.ptr);\n    }\n    /**\n    * Sign a transaction:\n    * `tx` - transaction to sign\n    * `boxes_to_spend` - boxes corresponding to [`UnsignedTransaction::inputs`]\n    * `data_boxes` - boxes corresponding to [`UnsignedTransaction::data_inputs`]\n    * @param {ErgoStateContext} _state_context\n    * @param {UnsignedTransaction} tx\n    * @param {ErgoBoxes} boxes_to_spend\n    * @param {ErgoBoxes} data_boxes\n    * @returns {Transaction}\n    */\n    sign_transaction(_state_context, tx, boxes_to_spend, data_boxes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(_state_context, ErgoStateContext);\n            _assertClass(tx, UnsignedTransaction);\n            _assertClass(boxes_to_spend, ErgoBoxes);\n            _assertClass(data_boxes, ErgoBoxes);\n            wasm.wallet_sign_transaction(retptr, this.ptr, _state_context.ptr, tx.ptr, boxes_to_spend.ptr, data_boxes.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Transaction.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Sign a multi signature transaction:\n    * `tx` - transaction to sign\n    * `boxes_to_spend` - boxes corresponding to [`UnsignedTransaction::inputs`]\n    * `data_boxes` - boxes corresponding to [`UnsignedTransaction::data_inputs`]\n    * `tx_hints` - transaction hints bag corresponding to [`TransactionHintsBag`]\n    * @param {ErgoStateContext} _state_context\n    * @param {UnsignedTransaction} tx\n    * @param {ErgoBoxes} boxes_to_spend\n    * @param {ErgoBoxes} data_boxes\n    * @param {TransactionHintsBag} tx_hints\n    * @returns {Transaction}\n    */\n    sign_transaction_multi(_state_context, tx, boxes_to_spend, data_boxes, tx_hints) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(_state_context, ErgoStateContext);\n            _assertClass(tx, UnsignedTransaction);\n            _assertClass(boxes_to_spend, ErgoBoxes);\n            _assertClass(data_boxes, ErgoBoxes);\n            _assertClass(tx_hints, TransactionHintsBag);\n            wasm.wallet_sign_transaction_multi(retptr, this.ptr, _state_context.ptr, tx.ptr, boxes_to_spend.ptr, data_boxes.ptr, tx_hints.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Transaction.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Sign a transaction:\n    * `reduced_tx` - reduced transaction, i.e. unsigned transaction where for each unsigned input\n    * added a script reduction result.\n    * @param {ReducedTransaction} reduced_tx\n    * @returns {Transaction}\n    */\n    sign_reduced_transaction(reduced_tx) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(reduced_tx, ReducedTransaction);\n            wasm.wallet_sign_reduced_transaction(retptr, this.ptr, reduced_tx.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Transaction.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Sign a multi signature reduced transaction:\n    * `reduced_tx` - reduced transaction, i.e. unsigned transaction where for each unsigned input\n    * added a script reduction result.\n    * `tx_hints` - transaction hints bag corresponding to [`TransactionHintsBag`]\n    * @param {ReducedTransaction} reduced_tx\n    * @param {TransactionHintsBag} tx_hints\n    * @returns {Transaction}\n    */\n    sign_reduced_transaction_multi(reduced_tx, tx_hints) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(reduced_tx, ReducedTransaction);\n            _assertClass(tx_hints, TransactionHintsBag);\n            wasm.wallet_sign_reduced_transaction_multi(retptr, this.ptr, reduced_tx.ptr, tx_hints.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Transaction.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Generate Commitments for unsigned tx\n    * @param {ErgoStateContext} _state_context\n    * @param {UnsignedTransaction} tx\n    * @param {ErgoBoxes} boxes_to_spend\n    * @param {ErgoBoxes} data_boxes\n    * @returns {TransactionHintsBag}\n    */\n    generate_commitments(_state_context, tx, boxes_to_spend, data_boxes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(_state_context, ErgoStateContext);\n            _assertClass(tx, UnsignedTransaction);\n            _assertClass(boxes_to_spend, ErgoBoxes);\n            _assertClass(data_boxes, ErgoBoxes);\n            wasm.wallet_generate_commitments(retptr, this.ptr, _state_context.ptr, tx.ptr, boxes_to_spend.ptr, data_boxes.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TransactionHintsBag.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Generate Commitments for reduced Transaction\n    * @param {ReducedTransaction} reduced_tx\n    * @returns {TransactionHintsBag}\n    */\n    generate_commitments_for_reduced_transaction(reduced_tx) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(reduced_tx, ReducedTransaction);\n            wasm.wallet_generate_commitments_for_reduced_transaction(retptr, this.ptr, reduced_tx.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TransactionHintsBag.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Sign an arbitrary message using a P2PK address\n    * @param {Address} address\n    * @param {Uint8Array} message\n    * @returns {Uint8Array}\n    */\n    sign_message_using_p2pk(address, message) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(address, Address);\n            var ptr0 = passArray8ToWasm0(message, wasm.__wbindgen_malloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.wallet_sign_message_using_p2pk(retptr, this.ptr, address.ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n\nexport function __wbindgen_object_drop_ref(arg0) {\n    takeObject(arg0);\n};\n\nexport function __wbg_peerurls_new(arg0) {\n    var ret = PeerUrls.__wrap(arg0);\n    return addHeapObject(ret);\n};\n\nexport function __wbindgen_object_clone_ref(arg0) {\n    var ret = getObject(arg0);\n    return addHeapObject(ret);\n};\n\nexport function __wbindgen_number_new(arg0) {\n    var ret = arg0;\n    return addHeapObject(ret);\n};\n\nexport function __wbindgen_string_new(arg0, arg1) {\n    var ret = getStringFromWasm0(arg0, arg1);\n    return addHeapObject(ret);\n};\n\nexport function __wbindgen_is_string(arg0) {\n    var ret = typeof(getObject(arg0)) === 'string';\n    return ret;\n};\n\nexport function __wbindgen_string_get(arg0, arg1) {\n    const obj = getObject(arg1);\n    var ret = typeof(obj) === 'string' ? obj : undefined;\n    var ptr0 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    var len0 = WASM_VECTOR_LEN;\n    getInt32Memory0()[arg0 / 4 + 1] = len0;\n    getInt32Memory0()[arg0 / 4 + 0] = ptr0;\n};\n\nexport function __wbg_merkleproof_new(arg0) {\n    var ret = MerkleProof.__wrap(arg0);\n    return addHeapObject(ret);\n};\n\nexport function __wbg_chromepeerdiscoveryscan_new(arg0) {\n    var ret = ChromePeerDiscoveryScan.__wrap(arg0);\n    return addHeapObject(ret);\n};\n\nexport function __wbg_blockheader_new(arg0) {\n    var ret = BlockHeader.__wrap(arg0);\n    return addHeapObject(ret);\n};\n\nexport function __wbg_nipopowproof_new(arg0) {\n    var ret = NipopowProof.__wrap(arg0);\n    return addHeapObject(ret);\n};\n\nexport function __wbg_nodeinfo_new(arg0) {\n    var ret = NodeInfo.__wrap(arg0);\n    return addHeapObject(ret);\n};\n\nexport function __wbindgen_ge(arg0, arg1) {\n    var ret = getObject(arg0) >= getObject(arg1);\n    return ret;\n};\n\nexport function __wbindgen_number_get(arg0, arg1) {\n    const obj = getObject(arg1);\n    var ret = typeof(obj) === 'number' ? obj : undefined;\n    getFloat64Memory0()[arg0 / 8 + 1] = isLikeNone(ret) ? 0 : ret;\n    getInt32Memory0()[arg0 / 4 + 0] = !isLikeNone(ret);\n};\n\nexport function __wbindgen_is_bigint(arg0) {\n    var ret = typeof(getObject(arg0)) === 'bigint';\n    return ret;\n};\n\nexport function __wbindgen_json_parse(arg0, arg1) {\n    var ret = JSON.parse(getStringFromWasm0(arg0, arg1));\n    return addHeapObject(ret);\n};\n\nexport function __wbindgen_json_serialize(arg0, arg1) {\n    const obj = getObject(arg1);\n    var ret = JSON.stringify(obj === undefined ? null : obj);\n    var ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    var len0 = WASM_VECTOR_LEN;\n    getInt32Memory0()[arg0 / 4 + 1] = len0;\n    getInt32Memory0()[arg0 / 4 + 0] = ptr0;\n};\n\nexport function __wbindgen_error_new(arg0, arg1) {\n    var ret = new Error(getStringFromWasm0(arg0, arg1));\n    return addHeapObject(ret);\n};\n\nexport function __wbg_new_693216e109162396() {\n    var ret = new Error();\n    return addHeapObject(ret);\n};\n\nexport function __wbg_stack_0ddaca5d1abfb52f(arg0, arg1) {\n    var ret = getObject(arg1).stack;\n    var ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    var len0 = WASM_VECTOR_LEN;\n    getInt32Memory0()[arg0 / 4 + 1] = len0;\n    getInt32Memory0()[arg0 / 4 + 0] = ptr0;\n};\n\nexport function __wbg_error_09919627ac0992f5(arg0, arg1) {\n    try {\n        console.error(getStringFromWasm0(arg0, arg1));\n    } finally {\n        wasm.__wbindgen_free(arg0, arg1);\n    }\n};\n\nexport function __wbg_fetch_96cb59599250c5c7(arg0) {\n    var ret = fetch(getObject(arg0));\n    return addHeapObject(ret);\n};\n\nexport function __wbindgen_cb_drop(arg0) {\n    const obj = takeObject(arg0).original;\n    if (obj.cnt-- == 1) {\n        obj.a = 0;\n        return true;\n    }\n    var ret = false;\n    return ret;\n};\n\nexport function __wbg_instanceof_Window_434ce1849eb4e0fc(arg0) {\n    var ret = getObject(arg0) instanceof Window;\n    return ret;\n};\n\nexport function __wbg_performance_bbca4ccfaef860b2(arg0) {\n    var ret = getObject(arg0).performance;\n    return isLikeNone(ret) ? 0 : addHeapObject(ret);\n};\n\nexport function __wbg_clearTimeout_0ca9612f07e1cdae(arg0, arg1) {\n    getObject(arg0).clearTimeout(arg1);\n};\n\nexport function __wbg_setTimeout_1c75092906446b91() { return handleError(function (arg0, arg1, arg2) {\n    var ret = getObject(arg0).setTimeout(getObject(arg1), arg2);\n    return ret;\n}, arguments) };\n\nexport function __wbg_new_226d109446575877() { return handleError(function () {\n    var ret = new Headers();\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_append_4d85f35672cbffa7() { return handleError(function (arg0, arg1, arg2, arg3, arg4) {\n    getObject(arg0).append(getStringFromWasm0(arg1, arg2), getStringFromWasm0(arg3, arg4));\n}, arguments) };\n\nexport function __wbg_fetch_fe54824ee845f6b4(arg0, arg1) {\n    var ret = getObject(arg0).fetch(getObject(arg1));\n    return addHeapObject(ret);\n};\n\nexport function __wbg_instanceof_Response_ea36d565358a42f7(arg0) {\n    var ret = getObject(arg0) instanceof Response;\n    return ret;\n};\n\nexport function __wbg_url_6e564c9e212456f8(arg0, arg1) {\n    var ret = getObject(arg1).url;\n    var ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    var len0 = WASM_VECTOR_LEN;\n    getInt32Memory0()[arg0 / 4 + 1] = len0;\n    getInt32Memory0()[arg0 / 4 + 0] = ptr0;\n};\n\nexport function __wbg_status_3a55bb50e744b834(arg0) {\n    var ret = getObject(arg0).status;\n    return ret;\n};\n\nexport function __wbg_headers_e4204c6775f7b3b4(arg0) {\n    var ret = getObject(arg0).headers;\n    return addHeapObject(ret);\n};\n\nexport function __wbg_arrayBuffer_0e2a43f68a8b3e49() { return handleError(function (arg0) {\n    var ret = getObject(arg0).arrayBuffer();\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_host_7633166e48189c8e(arg0, arg1) {\n    var ret = getObject(arg1).host;\n    var ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    var len0 = WASM_VECTOR_LEN;\n    getInt32Memory0()[arg0 / 4 + 1] = len0;\n    getInt32Memory0()[arg0 / 4 + 0] = ptr0;\n};\n\nexport function __wbg_new_4473c9af1cac368b() { return handleError(function (arg0, arg1) {\n    var ret = new URL(getStringFromWasm0(arg0, arg1));\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_signal_259ba662a5555524(arg0) {\n    var ret = getObject(arg0).signal;\n    return addHeapObject(ret);\n};\n\nexport function __wbg_new_7456dc18cc110e9c() { return handleError(function () {\n    var ret = new AbortController();\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_abort_3c64506fb0036132(arg0) {\n    getObject(arg0).abort();\n};\n\nexport function __wbg_newwithstrandinit_c07f0662ece15bc6() { return handleError(function (arg0, arg1, arg2) {\n    var ret = new Request(getStringFromWasm0(arg0, arg1), getObject(arg2));\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_now_5fa0ca001e042f8a(arg0) {\n    var ret = getObject(arg0).now();\n    return ret;\n};\n\nexport function __wbg_process_e56fd54cf6319b6c(arg0) {\n    var ret = getObject(arg0).process;\n    return addHeapObject(ret);\n};\n\nexport function __wbindgen_is_object(arg0) {\n    const val = getObject(arg0);\n    var ret = typeof(val) === 'object' && val !== null;\n    return ret;\n};\n\nexport function __wbg_versions_77e21455908dad33(arg0) {\n    var ret = getObject(arg0).versions;\n    return addHeapObject(ret);\n};\n\nexport function __wbg_node_0dd25d832e4785d5(arg0) {\n    var ret = getObject(arg0).node;\n    return addHeapObject(ret);\n};\n\nexport function __wbg_require_0db1598d9ccecb30() { return handleError(function (arg0, arg1, arg2) {\n    var ret = getObject(arg0).require(getStringFromWasm0(arg1, arg2));\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_crypto_b95d7173266618a9(arg0) {\n    var ret = getObject(arg0).crypto;\n    return addHeapObject(ret);\n};\n\nexport function __wbg_msCrypto_5a86d77a66230f81(arg0) {\n    var ret = getObject(arg0).msCrypto;\n    return addHeapObject(ret);\n};\n\nexport function __wbg_getRandomValues_b14734aa289bc356() { return handleError(function (arg0, arg1) {\n    getObject(arg0).getRandomValues(getObject(arg1));\n}, arguments) };\n\nexport function __wbg_static_accessor_NODE_MODULE_26b231378c1be7dd() {\n    var ret = module;\n    return addHeapObject(ret);\n};\n\nexport function __wbg_randomFillSync_91e2b39becca6147() { return handleError(function (arg0, arg1, arg2) {\n    getObject(arg0).randomFillSync(getArrayU8FromWasm0(arg1, arg2));\n}, arguments) };\n\nexport function __wbg_get_f45dff51f52d7222(arg0, arg1) {\n    var ret = getObject(arg0)[arg1 >>> 0];\n    return addHeapObject(ret);\n};\n\nexport function __wbg_length_7b60f47bde714631(arg0) {\n    var ret = getObject(arg0).length;\n    return ret;\n};\n\nexport function __wbg_new_16f24b0728c5e67b() {\n    var ret = new Array();\n    return addHeapObject(ret);\n};\n\nexport function __wbg_BigInt_229ec68d668024d2(arg0) {\n    var ret = BigInt(getObject(arg0));\n    return addHeapObject(ret);\n};\n\nexport function __wbindgen_is_function(arg0) {\n    var ret = typeof(getObject(arg0)) === 'function';\n    return ret;\n};\n\nexport function __wbg_newnoargs_f579424187aa1717(arg0, arg1) {\n    var ret = new Function(getStringFromWasm0(arg0, arg1));\n    return addHeapObject(ret);\n};\n\nexport function __wbg_next_c7a2a6b012059a5e(arg0) {\n    var ret = getObject(arg0).next;\n    return addHeapObject(ret);\n};\n\nexport function __wbg_next_dd1a890d37e38d73() { return handleError(function (arg0) {\n    var ret = getObject(arg0).next();\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_done_982b1c7ac0cbc69d(arg0) {\n    var ret = getObject(arg0).done;\n    return ret;\n};\n\nexport function __wbg_value_2def2d1fb38b02cd(arg0) {\n    var ret = getObject(arg0).value;\n    return addHeapObject(ret);\n};\n\nexport function __wbg_iterator_4b9cedbeda0c0e30() {\n    var ret = Symbol.iterator;\n    return addHeapObject(ret);\n};\n\nexport function __wbg_get_8bbb82393651dd9c() { return handleError(function (arg0, arg1) {\n    var ret = Reflect.get(getObject(arg0), getObject(arg1));\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_call_89558c3e96703ca1() { return handleError(function (arg0, arg1) {\n    var ret = getObject(arg0).call(getObject(arg1));\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_new_d3138911a89329b0() {\n    var ret = new Object();\n    return addHeapObject(ret);\n};\n\nexport function __wbg_self_e23d74ae45fb17d1() { return handleError(function () {\n    var ret = self.self;\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_window_b4be7f48b24ac56e() { return handleError(function () {\n    var ret = window.window;\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_globalThis_d61b1f48a57191ae() { return handleError(function () {\n    var ret = globalThis.globalThis;\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_global_e7669da72fd7f239() { return handleError(function () {\n    var ret = global.global;\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbindgen_is_undefined(arg0) {\n    var ret = getObject(arg0) === undefined;\n    return ret;\n};\n\nexport function __wbg_isArray_8480ed76e5369634(arg0) {\n    var ret = Array.isArray(getObject(arg0));\n    return ret;\n};\n\nexport function __wbg_push_a72df856079e6930(arg0, arg1) {\n    var ret = getObject(arg0).push(getObject(arg1));\n    return ret;\n};\n\nexport function __wbg_BigInt_5179c5cb9cc5bfa4() { return handleError(function (arg0) {\n    var ret = BigInt(getObject(arg0));\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_toString_438e03f57fe1aad9() { return handleError(function (arg0, arg1) {\n    var ret = getObject(arg0).toString(arg1);\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_toString_ca043cc7e2bb8f6e(arg0, arg1, arg2) {\n    var ret = getObject(arg1).toString(arg2);\n    var ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    var len0 = WASM_VECTOR_LEN;\n    getInt32Memory0()[arg0 / 4 + 1] = len0;\n    getInt32Memory0()[arg0 / 4 + 0] = ptr0;\n};\n\nexport function __wbg_new_55259b13834a484c(arg0, arg1) {\n    var ret = new Error(getStringFromWasm0(arg0, arg1));\n    return addHeapObject(ret);\n};\n\nexport function __wbg_setname_b9dec29a5b82e0e1(arg0, arg1, arg2) {\n    getObject(arg0).name = getStringFromWasm0(arg1, arg2);\n};\n\nexport function __wbg_call_94697a95cb7e239c() { return handleError(function (arg0, arg1, arg2) {\n    var ret = getObject(arg0).call(getObject(arg1), getObject(arg2));\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_valueOf_39e0d6bc7e4232b9(arg0) {\n    var ret = getObject(arg0).valueOf();\n    return ret;\n};\n\nexport function __wbg_toString_9b85345d84562096(arg0) {\n    var ret = getObject(arg0).toString();\n    return addHeapObject(ret);\n};\n\nexport function __wbg_new_4beacc9c71572250(arg0, arg1) {\n    try {\n        var state0 = {a: arg0, b: arg1};\n        var cb0 = (arg0, arg1) => {\n            const a = state0.a;\n            state0.a = 0;\n            try {\n                return __wbg_adapter_488(a, state0.b, arg0, arg1);\n            } finally {\n                state0.a = a;\n            }\n        };\n        var ret = new Promise(cb0);\n        return addHeapObject(ret);\n    } finally {\n        state0.a = state0.b = 0;\n    }\n};\n\nexport function __wbg_resolve_4f8f547f26b30b27(arg0) {\n    var ret = Promise.resolve(getObject(arg0));\n    return addHeapObject(ret);\n};\n\nexport function __wbg_then_a6860c82b90816ca(arg0, arg1) {\n    var ret = getObject(arg0).then(getObject(arg1));\n    return addHeapObject(ret);\n};\n\nexport function __wbg_then_58a04e42527f52c6(arg0, arg1, arg2) {\n    var ret = getObject(arg0).then(getObject(arg1), getObject(arg2));\n    return addHeapObject(ret);\n};\n\nexport function __wbg_buffer_5e74a88a1424a2e0(arg0) {\n    var ret = getObject(arg0).buffer;\n    return addHeapObject(ret);\n};\n\nexport function __wbg_newwithbyteoffsetandlength_278ec7532799393a(arg0, arg1, arg2) {\n    var ret = new Uint8Array(getObject(arg0), arg1 >>> 0, arg2 >>> 0);\n    return addHeapObject(ret);\n};\n\nexport function __wbg_new_e3b800e570795b3c(arg0) {\n    var ret = new Uint8Array(getObject(arg0));\n    return addHeapObject(ret);\n};\n\nexport function __wbg_set_5b8081e9d002f0df(arg0, arg1, arg2) {\n    getObject(arg0).set(getObject(arg1), arg2 >>> 0);\n};\n\nexport function __wbg_length_30803400a8f15c59(arg0) {\n    var ret = getObject(arg0).length;\n    return ret;\n};\n\nexport function __wbg_instanceof_Uint8Array_8a8537f46e056474(arg0) {\n    var ret = getObject(arg0) instanceof Uint8Array;\n    return ret;\n};\n\nexport function __wbg_newwithlength_5f4ce114a24dfe1e(arg0) {\n    var ret = new Uint8Array(arg0 >>> 0);\n    return addHeapObject(ret);\n};\n\nexport function __wbg_subarray_a68f835ca2af506f(arg0, arg1, arg2) {\n    var ret = getObject(arg0).subarray(arg1 >>> 0, arg2 >>> 0);\n    return addHeapObject(ret);\n};\n\nexport function __wbg_has_3850edde6df9191b() { return handleError(function (arg0, arg1) {\n    var ret = Reflect.has(getObject(arg0), getObject(arg1));\n    return ret;\n}, arguments) };\n\nexport function __wbg_set_c42875065132a932() { return handleError(function (arg0, arg1, arg2) {\n    var ret = Reflect.set(getObject(arg0), getObject(arg1), getObject(arg2));\n    return ret;\n}, arguments) };\n\nexport function __wbg_stringify_f8bfc9e2d1e8b6a0() { return handleError(function (arg0) {\n    var ret = JSON.stringify(getObject(arg0));\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbindgen_debug_string(arg0, arg1) {\n    var ret = debugString(getObject(arg1));\n    var ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    var len0 = WASM_VECTOR_LEN;\n    getInt32Memory0()[arg0 / 4 + 1] = len0;\n    getInt32Memory0()[arg0 / 4 + 0] = ptr0;\n};\n\nexport function __wbindgen_throw(arg0, arg1) {\n    throw new Error(getStringFromWasm0(arg0, arg1));\n};\n\nexport function __wbindgen_memory() {\n    var ret = wasm.memory;\n    return addHeapObject(ret);\n};\n\nexport function __wbindgen_closure_wrapper2131(arg0, arg1, arg2) {\n    var ret = makeClosure(arg0, arg1, 345, __wbg_adapter_40);\n    return addHeapObject(ret);\n};\n\nexport function __wbindgen_closure_wrapper7194(arg0, arg1, arg2) {\n    var ret = makeMutClosure(arg0, arg1, 906, __wbg_adapter_43);\n    return addHeapObject(ret);\n};\n\nexport function __wbindgen_closure_wrapper8075(arg0, arg1, arg2) {\n    var ret = makeMutClosure(arg0, arg1, 1030, __wbg_adapter_46);\n    return addHeapObject(ret);\n};\n\n","module.exports = function(originalModule) {\n\tif (!originalModule.webpackPolyfill) {\n\t\tvar module = Object.create(originalModule);\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"exports\", {\n\t\t\tenumerable: true\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n","import * as wasm from \"./ergo_lib_wasm_bg.wasm\";\nexport * from \"./ergo_lib_wasm_bg.js\";"],"sourceRoot":""}